<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ILSI.ilsi &mdash; ILSI 1.1.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> ILSI
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../updates.html">Updates</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ILSI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ILSI.ilsi</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ILSI.ilsi</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">LinAlgError</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils_stress</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="c1"># from time import time as give_time</span>


<div class="viewcode-block" id="forward_model"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.forward_model">[docs]</a><span class="k">def</span> <span class="nf">forward_model</span><span class="p">(</span><span class="n">n_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the forward modeling matrix ``G`` given a collection</span>
<span class="sd">    of fault normals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    n_: (n_earthquakes, 3) numpy.ndarray</span>
<span class="sd">        The i-th row n_ are the components of the i-th</span>
<span class="sd">        fault normal in the (north, west, south) coordinate</span>
<span class="sd">        system.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    G: (3 x n_earthquakes, 5) numpy.ndarray</span>
<span class="sd">        The forward modeling matrix giving the slip (shear stress)</span>
<span class="sd">        directions on the faults characterized by `n_`, given the 5</span>
<span class="sd">        elements of the deviatoric stress tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="n">n_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_earthquakes</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">):</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">n_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">n1</span><span class="o">**</span><span class="mi">3</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">n1</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n3</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">n3</span> <span class="o">*</span> <span class="n">n1</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">n3</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">n3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">n1</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">n3</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">n3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">n2</span><span class="o">**</span><span class="mi">3</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">n3</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">n3</span> <span class="o">*</span> <span class="n">n2</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n3</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">n3</span> <span class="o">-</span> <span class="n">n3</span> <span class="o">*</span> <span class="n">n1</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">n3</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n3</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">n3</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">n3</span> <span class="o">-</span> <span class="n">n3</span> <span class="o">*</span> <span class="n">n2</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">G</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">n3</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="Tarantola_Valette"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.Tarantola_Valette">[docs]</a><span class="k">def</span> <span class="nf">Tarantola_Valette</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">C_d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">C_d_inv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">C_m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">C_m_inv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">m_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">inversion_space</span><span class="o">=</span><span class="s2">&quot;model_space&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns Tarantola&#39;s and Valette&#39;s least square solution for</span>
<span class="sd">    a given linear operator `G` and observation vector `data`. If the</span>
<span class="sd">    covariance matrices of the observations and of the model</span>
<span class="sd">    parameters are not known, we assume them to be identity. The</span>
<span class="sd">    inversion can be performed either in the data space or in</span>
<span class="sd">    the model space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    G: (n, m) numpy.ndarray</span>
<span class="sd">        The linear operator projecting elements of the model</span>
<span class="sd">        space m onto the data space: d = G.m</span>
<span class="sd">        n is the dimension of the data space,</span>
<span class="sd">        m is the dimension of the model space.</span>
<span class="sd">    data: (3k,) or (3k, 1) or (k, 3) numpy.ndarray</span>
<span class="sd">        Vector of observations. k is the number of focal mechanisms. `data`</span>
<span class="sd">        is reshaped to (n=3k, 1) before the inversion.</span>
<span class="sd">    C_d: (n, n) numpy.ndarray, default to None</span>
<span class="sd">        Covariance matrix of the observations. It quantifies</span>
<span class="sd">        the errors in the observations and propagates them</span>
<span class="sd">        in the inversion to give more weight to the observations</span>
<span class="sd">        with low errors. If None, then `C_d` is filled with zeros</span>
<span class="sd">        (assume no error in data).</span>
<span class="sd">    C_m: (m, m) numpy.ndarray, default to None</span>
<span class="sd">        Covariance matrix of the model parameters. It quantifies</span>
<span class="sd">        the errors in the model parameters and propagates them</span>
<span class="sd">        in the inversion to determine the range of acceptable</span>
<span class="sd">        model parameters for a given set of observations.</span>
<span class="sd">        If None, then `C_m` is identity.</span>
<span class="sd">    m_prior: (m,) or (m, 1) numpy.ndarray, default to None</span>
<span class="sd">        If one already has a rough estimate of what the model</span>
<span class="sd">        parameters are, then m_prior should be filled with this estimate.</span>
<span class="sd">        If None, `m_prior` is set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    m_inv: (m, 1) numpy.ndarray</span>
<span class="sd">        The inverted model parameters.</span>
<span class="sd">    C_m_posterior: (5, 5) numpy.ndarray</span>
<span class="sd">        Posterior covariance of the model parameter distribution.</span>
<span class="sd">    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray</span>
<span class="sd">        Posterior covariance of the data distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># t_start = give_time()</span>
    <span class="n">dim_D</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dim_M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">C_d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim_D</span><span class="p">,</span> <span class="n">dim_D</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">C_d_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim_D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">C_d_inv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">inversion_space</span> <span class="o">==</span> <span class="s2">&quot;model_space&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">C_d_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C_d</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot invert data covariance matrix:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">C_d</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">C_m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim_M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">C_m_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">C_m</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">C_m_inv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">inversion_space</span> <span class="o">==</span> <span class="s2">&quot;model_space&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">C_m_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C_m</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot invert model covariance matrix:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">C_m</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">m_prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">m_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim_M</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># make sure data is a column vector</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inversion_space</span> <span class="o">==</span> <span class="s2">&quot;data_space&quot;</span><span class="p">:</span>
        <span class="c1"># perform the inversion in the data space</span>
        <span class="c1"># pre-compute recurrent terms:</span>
        <span class="n">Cm_Gt</span> <span class="o">=</span> <span class="n">C_m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Cm_Gt</span><span class="p">)</span> <span class="o">+</span> <span class="n">C_d</span><span class="p">)</span>
        <span class="n">Cm_Gt_inv</span> <span class="o">=</span> <span class="n">Cm_Gt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">)</span>
        <span class="n">m_inv</span> <span class="o">=</span> <span class="n">m_prior</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Cm_Gt_inv</span><span class="p">,</span> <span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">m_prior</span><span class="p">))</span>
        <span class="n">C_m_posterior</span> <span class="o">=</span> <span class="n">C_m</span> <span class="o">-</span> <span class="p">(</span><span class="n">Cm_Gt_inv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C_m</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">inversion_space</span> <span class="o">==</span> <span class="s2">&quot;model_space&quot;</span><span class="p">:</span>
        <span class="c1"># perform the inversion in the model space</span>
        <span class="c1"># pre-compute recurrent terms</span>
        <span class="n">Gt_Cdinv</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C_d_inv</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Gt_Cdinv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">+</span> <span class="n">C_m_inv</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Could not solve the inverse problem in the model space.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Forward modelling matrix:&quot;</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inverse data cov matrix:&quot;</span><span class="p">,</span> <span class="n">C_d_inv</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inverse model cov matrix:&quot;</span><span class="p">,</span> <span class="n">C_m_inv</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Gt_Cdinv</span><span class="p">,</span> <span class="n">G</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
        <span class="n">m_inv</span> <span class="o">=</span> <span class="n">m_prior</span> <span class="o">+</span> <span class="p">(</span><span class="n">inv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Gt_Cdinv</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">G</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m_prior</span><span class="p">))</span>
        <span class="n">C_m_posterior</span> <span class="o">=</span> <span class="n">inv</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inversion_spce should either be &quot;model_space&quot; &#39;</span> <span class="s1">&#39;or &quot;data_space&quot;&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">C_d_posterior</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C_m_posterior</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="c1"># t_end = give_time()</span>
    <span class="c1"># print(&#39;{:.3f}sec on Tarantola&#39;.format(t_end-t_start))</span>
    <span class="k">return</span> <span class="n">m_inv</span><span class="p">,</span> <span class="n">C_m_posterior</span><span class="p">,</span> <span class="n">C_d_posterior</span></div>


<div class="viewcode-block" id="iterative_linear_si"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.iterative_linear_si">[docs]</a><span class="k">def</span> <span class="nf">iterative_linear_si</span><span class="p">(</span>
    <span class="n">strikes</span><span class="p">,</span>
    <span class="n">dips</span><span class="p">,</span>
    <span class="n">rakes</span><span class="p">,</span>
    <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">shear_update_atol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">return_eigen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterative stress inversion described in Beauce et al. 2022.</span>

<span class="sd">    This method assumes:</span>
<span class="sd">        - The tectonic stress field is uniform.</span>
<span class="sd">        - Wallace-Bott hypothesis: The slip vector points in the same</span>
<span class="sd">          direction as shear stress on the fault.</span>
<span class="sd">    The parameters we invert for are the directions of the three</span>
<span class="sd">    principal stresses and the shape ratio. Because this inversion does not</span>
<span class="sd">    aim at infering the absolute stress values, we only consider the</span>
<span class="sd">    deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot</span>
<span class="sd">    determine the norm of the stress tensor, therefore sum sigma**2 = 1.</span>
<span class="sd">    Each iteration of this inversion scheme is a linear inversion.</span>
<span class="sd">    N.B.: This routine is written assuming outward footwall normals and slip</span>
<span class="sd">    vectors of the hanging wall w.r.t. the footwall. Therefore, the stress</span>
<span class="sd">    tensor sign convention is compression negative.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    strikes: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    shear_update_atol: float, default to 1e-5</span>
<span class="sd">        Convergence criterion on the shear stress magnitude updates.</span>
<span class="sd">        Convergence is reached when the RMS difference between two</span>
<span class="sd">        estimates of shear stress magnitudes falls below that threshold.</span>
<span class="sd">    max_n_iterations: integer, default to 300</span>
<span class="sd">        The maximum number of iterations if shear stress magnitude update</span>
<span class="sd">        does not fall below `shear_update_atol`.</span>
<span class="sd">    Tarantola_kwargs: Dictionary, default to {}:</span>
<span class="sd">        If not None, should contain key word arguments</span>
<span class="sd">        for the Tarantola and Valette inversion. An empty dictionary</span>
<span class="sd">        uses the default values in `Tarantola_Valette`. If None, uses</span>
<span class="sd">        the Moore-Penrose inverse.</span>
<span class="sd">    return_eigen: boolean, default to True</span>
<span class="sd">        If True, returns the eigendecomposition of the inverted</span>
<span class="sd">        stress tensor in addition to returning the stress tensor.</span>
<span class="sd">    return_stats: boolean, default to True</span>
<span class="sd">        If True, the posterior data and model parameter distributions</span>
<span class="sd">        estimated from the Tarantola and Valette formula</span>
<span class="sd">        (cf. Tarantola_Valette routine).</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: dict {str: numpy.ndarray}</span>
<span class="sd">        - output[&quot;stress_tensor&quot;]: (3, 3) numpy.ndarray</span>
<span class="sd">            The inverted stress tensor in the (north, west, up)</span>
<span class="sd">            coordinate system.</span>
<span class="sd">        - output[&quot;principal_stresses&quot;]: (3,) numpy.ndarray, optional</span>
<span class="sd">            The three eigenvalues of the stress tensor, ordered from</span>
<span class="sd">            most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">            Returned if `return_eigen` is True.</span>
<span class="sd">        - output[&quot;principal_directions&quot;]: (3, 3) numpy.ndarray, optional</span>
<span class="sd">            The three eigenvectors of the stress tensor, stored in a matrix</span>
<span class="sd">            as column vectors and ordered from most compressive (sigma1)</span>
<span class="sd">            to least compressive (sigma3). The direction of sigma_i is</span>
<span class="sd">            given by: `principal_directions[:, i]`.</span>
<span class="sd">            Returned if `return_eigen` is True.</span>
<span class="sd">        - output[&quot;C_m_posterior&quot;]: (5, 5) numpy.ndarray, optional</span>
<span class="sd">            Posterior covariance of the model parameter distribution</span>
<span class="sd">            estimated from the Tarantola and Valette formula.</span>
<span class="sd">            Returned if `return_stats` is True.</span>
<span class="sd">        - output[&quot;C_d_posterior&quot;]: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray, optional</span>
<span class="sd">            Posterior covariance of the data distribution</span>
<span class="sd">            estimated from the Tarantola and Valette formula.</span>
<span class="sd">            Returned if `return_stats` is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># t_start = give_time()</span>
    <span class="c1"># First, convert the strike/dip/rake into slip and normal vectors.</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strikes</span><span class="p">)</span>
    <span class="n">n_</span><span class="p">,</span> <span class="n">d_</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">normal_slip_vectors</span><span class="p">(</span><span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;inward&quot;</span><span class="p">)</span>
    <span class="n">n_</span><span class="p">,</span> <span class="n">d_</span> <span class="o">=</span> <span class="n">n_</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">d_</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># Next, define the matrix that relates the stress tensor</span>
    <span class="c1"># to the observed slip vectors, given the fault geometries</span>
    <span class="c1"># characterized by the normal vectors.</span>
    <span class="c1"># For each earthquake, an (3 x 5) matrix relates the 5 independent</span>
    <span class="c1"># stress tensor components to the 3 slip vector components.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">forward_model</span><span class="p">(</span><span class="n">n_</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Tarantola_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># -----------------------------------------</span>
        <span class="c1"># copy Tarantola_kwargs because all modifications are made in-place</span>
        <span class="n">Tarantola_kwargs</span> <span class="o">=</span> <span class="n">Tarantola_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Tarantola_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># initialize shear magnitudes</span>
    <span class="k">if</span> <span class="s2">&quot;m_prior&quot;</span> <span class="ow">in</span> <span class="n">Tarantola_kwargs</span><span class="p">:</span>
        <span class="n">shear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="p">(</span><span class="n">G</span> <span class="o">@</span> <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;m_prior&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span>
                <span class="p">)</span>
                <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_n_iterations</span><span class="p">):</span>
        <span class="n">sigma</span><span class="p">,</span> <span class="n">C_m_posterior</span><span class="p">,</span> <span class="n">C_d_posterior</span> <span class="o">=</span> <span class="n">Tarantola_Valette</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">d_</span> <span class="o">*</span> <span class="n">shear</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="o">**</span><span class="n">Tarantola_kwargs</span>
        <span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="c1"># normalize the stress tensor to make sure the units of</span>
        <span class="c1"># shear does not explode or vanish (it can behave like a</span>
        <span class="c1"># geometrical series), this normalization gives the reduced</span>
        <span class="c1"># stress tensor (up to a multiplicative constant)</span>
        <span class="n">full_stress_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">4</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">-</span><span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">full_stress_tensor</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">norm</span>
        <span class="n">sigma</span> <span class="o">/=</span> <span class="n">norm</span>
        <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;m_prior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Note: From Tarantola&#39;s book: in an iterative non-linear</span>
        <span class="c1"># inversion, he does not input the posterior distribution from</span>
        <span class="c1"># previous iteration to the next iteration. Doing so leads to</span>
        <span class="c1"># vanishing or exploding covariance matrices!</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># compute shear magnitudes</span>
        <span class="n">shear0</span> <span class="o">=</span> <span class="n">shear</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">predicted_shear</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span> <span class="o">@</span> <span class="n">sigma</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">shear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">predicted_shear</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">shear_update</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">shear</span> <span class="o">-</span> <span class="n">shear0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># print(&#39;Shear stress update: {:.3e}&#39;.format(shear_update))</span>
        <span class="k">if</span> <span class="n">shear_update</span> <span class="o">&lt;</span> <span class="n">shear_update_atol</span><span class="p">:</span>
            <span class="c1"># convergence has been reached, according to the</span>
            <span class="c1"># user-prescribed criterion</span>
            <span class="c1"># print(&#39;Stop at iteration {:d}! (shear update: {:.3e})&#39;.format(j, shear_update))</span>
            <span class="k">break</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1"># build full stress tensor</span>
    <span class="n">full_stress_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">4</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">-</span><span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">full_stress_tensor</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">norm</span>
    <span class="n">full_stress_tensor</span> <span class="o">/=</span> <span class="n">norm</span>
    <span class="c1"># return output in dictionary</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_stress_tensor</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;predicted_shear_stress&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">predicted_shear</span>
    <span class="k">if</span> <span class="n">return_eigen</span><span class="p">:</span>
        <span class="c1"># solve the eigenvalue problem</span>
        <span class="p">(</span>
            <span class="n">principal_stresses</span><span class="p">,</span>
            <span class="n">principal_directions</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span><span class="n">full_stress_tensor</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;shear_stress_magnitudes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shear</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;principal_stresses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal_stresses</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;principal_directions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal_directions</span>
    <span class="k">if</span> <span class="n">return_stats</span><span class="p">:</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_d_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">C_d_posterior</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_m_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">C_m_posterior</span>
    <span class="c1"># t_end = give_time()</span>
    <span class="c1"># print(&#39;iterative_linear_si finished in {:.2f}sec&#39;.format(t_end-t_start))</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="Michael1984_inversion"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.Michael1984_inversion">[docs]</a><span class="k">def</span> <span class="nf">Michael1984_inversion</span><span class="p">(</span>
    <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span><span class="p">,</span> <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">return_eigen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_stats</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear inversion described in Michael 1984.</span>

<span class="sd">    This method assumes:</span>
<span class="sd">        - The tectonic stress field is uniform.</span>
<span class="sd">        - Wallace-Bott hypothesis: The slip vector points in the same</span>
<span class="sd">          direction as shear stress on the fault.</span>
<span class="sd">        - The resolved shear stress magnitude is constant on</span>
<span class="sd">          all faults.</span>
<span class="sd">    The parameters we invert for are the directions of the three</span>
<span class="sd">    principal stresses and the shape ratio. Because this inversion does not</span>
<span class="sd">    aim at infering the absolute stress values, we only consider the</span>
<span class="sd">    deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot</span>
<span class="sd">    determine the norm of the stress tensor, therefore sum sigma**2 = 1.</span>
<span class="sd">    Each iteration of this inversion scheme is a linear inversion.</span>
<span class="sd">    N.B.: This routine is written assuming outward footwall normals and slip</span>
<span class="sd">    vectors of the hanging wall w.r.t. the footwall. Therefore, the stress</span>
<span class="sd">    tensor sign convention is compression negative.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    strikes: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    Tarantola_kwargs: Dictionary, default to {}</span>
<span class="sd">        If not None, should contain key word arguments</span>
<span class="sd">        for the Tarantola and Valette inversion. An empty dictionary</span>
<span class="sd">        uses the default values in `Tarantola_Valette`. If None, uses</span>
<span class="sd">        the Moore-Penrose inverse.</span>
<span class="sd">    return_eigen: boolean, default to True</span>
<span class="sd">        If True, returns the eigendecomposition of the inverted</span>
<span class="sd">        stress tensor in addition to returning the stress tensor.</span>
<span class="sd">    return_stats: boolean, default to True</span>
<span class="sd">        If True, the posterior data and model parameter distributions</span>
<span class="sd">        estimated from the Tarantola and Valette formula</span>
<span class="sd">        (cf. Tarantola_Valette routine).</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: dict {str: numpy.ndarray}</span>
<span class="sd">        - output[&quot;stress_tensor&quot;]: (3, 3) numpy.ndarray</span>
<span class="sd">            The inverted stress tensor in the (north, west, up)</span>
<span class="sd">            coordinate system.</span>
<span class="sd">        - output[&quot;principal_stresses&quot;]: (3,) numpy.ndarray, optional</span>
<span class="sd">            The three eigenvalues of the stress tensor, ordered from</span>
<span class="sd">            most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">            Returned if `return_eigen` is True.</span>
<span class="sd">        - output[&quot;predicted_shear_stress&quot;]: (n_earthquakes, 3) numpy.ndarray</span>
<span class="sd">            The shear tractions resolved on the fault planes described by `strikes`,</span>
<span class="sd">            `dips` and `rakes` computed with the inverted stress tensor.</span>
<span class="sd">        - output[&quot;principal_directions&quot;]: (3, 3) numpy.ndarray, optional</span>
<span class="sd">            The three eigenvectors of the stress tensor, stored in a matrix</span>
<span class="sd">            as column vectors and ordered from most compressive (sigma1)</span>
<span class="sd">            to least compressive (sigma3). The direction of sigma_i is</span>
<span class="sd">            given by: `principal_directions[:, i]`.</span>
<span class="sd">            Returned if `return_eigen` is True.</span>
<span class="sd">        - output[&quot;C_m_posterior&quot;]: (5, 5) numpy.ndarray, optional</span>
<span class="sd">            Posterior covariance of the model parameter distribution</span>
<span class="sd">            estimated from the Tarantola and Valette formula.</span>
<span class="sd">            Returned if `return_stats` is True.</span>
<span class="sd">        - output[&quot;C_d_posterior&quot;]: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray, optional</span>
<span class="sd">            Posterior covariance of the data distribution</span>
<span class="sd">            estimated from the Tarantola and Valette formula.</span>
<span class="sd">            Returned if `return_stats` is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First, convert the strike/dip/rake into slip and normal vectors.</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strikes</span><span class="p">)</span>
    <span class="n">n_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># normal vectors</span>
    <span class="n">d_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># slip vectors</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">):</span>
        <span class="n">n_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">normal_slip_vectors</span><span class="p">(</span>
            <span class="n">strikes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dips</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rakes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;inward&quot;</span>
        <span class="p">)</span>
    <span class="c1"># Next, define the matrix that relates the stress tensor</span>
    <span class="c1"># to the observed slip vectors, given the fault geometries</span>
    <span class="c1"># characterized by the normal vectors.</span>
    <span class="c1"># For each earthquake, an (3 x 5) matrix relates the 5 independent</span>
    <span class="c1"># stress tensor components to the 3 slip vector components.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">forward_model</span><span class="p">(</span><span class="n">n_</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Tarantola_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigma</span><span class="p">,</span> <span class="n">C_m_posterior</span><span class="p">,</span> <span class="n">C_d_posterior</span> <span class="o">=</span> <span class="n">Tarantola_Valette</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">d_</span><span class="p">,</span> <span class="o">**</span><span class="n">Tarantola_kwargs</span>
        <span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We choose any inversion method to invert G:</span>
        <span class="n">G_pinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="c1"># Given how we defined G, the stress tensor components</span>
        <span class="c1"># we get are in this order:</span>
        <span class="c1"># sigma_11, sigma_12, sigma_13, sigma_22, sigma_23</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G_pinv</span><span class="p">,</span> <span class="n">d_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="c1"># fake C_m and C_d</span>
        <span class="n">C_m_posterior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">C_d_posterior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="n">full_stress_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">4</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">-</span><span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">full_stress_tensor</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">norm</span>
    <span class="n">full_stress_tensor</span> <span class="o">/=</span> <span class="n">norm</span>
    <span class="c1"># return output in dictionary</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_stress_tensor</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;predicted_shear_stress&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span> <span class="o">@</span> <span class="n">sigma</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_eigen</span><span class="p">:</span>
        <span class="c1"># solve the eigenvalue problem</span>
        <span class="p">(</span>
            <span class="n">principal_stresses</span><span class="p">,</span>
            <span class="n">principal_directions</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span><span class="n">full_stress_tensor</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;principal_stresses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal_stresses</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;principal_directions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal_directions</span>
    <span class="k">if</span> <span class="n">return_stats</span><span class="p">:</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_d_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">C_d_posterior</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_m_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">C_m_posterior</span>
    <span class="k">return</span> <span class="n">output</span></div>


<span class="c1"># ---------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#   Routines for inversion without instability parameter</span>
<span class="c1">#</span>
<span class="c1"># ---------------------------------------------------</span>


<div class="viewcode-block" id="inversion_one_set"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.inversion_one_set">[docs]</a><span class="k">def</span> <span class="nf">inversion_one_set</span><span class="p">(</span>
    <span class="n">strikes</span><span class="p">,</span>
    <span class="n">dips</span><span class="p">,</span>
    <span class="n">rakes</span><span class="p">,</span>
    <span class="n">n_random_selections</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">shear_update_atol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">variable_shear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">return_eigen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invert one set of focal mechanisms without seeking which nodal planes</span>
<span class="sd">    are more likely to be the fault planes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    strikes: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    n_random_selections: integer, default to 20</span>
<span class="sd">        Number of random selections of subsets of nodal planes on</span>
<span class="sd">        which the stress inversion is run. The final stress tensor</span>
<span class="sd">        is averaged over the n_random_selections solutions.</span>
<span class="sd">    shear_update_atol: float, default to 1e-5</span>
<span class="sd">        Convergence criterion on the shear stress magnitude updates.</span>
<span class="sd">        Convergence is reached when the RMS difference between two</span>
<span class="sd">        estimates of shear stress magnitudes falls below that threshold.</span>
<span class="sd">    max_n_iterations: integer, default to 300</span>
<span class="sd">        The maximum number of iterations if shear stress magnitude update</span>
<span class="sd">        does not fall below `shear_update_atol`.</span>
<span class="sd">    variable_shear: boolean, default to True</span>
<span class="sd">        If True, use the iterative linear method described in</span>
<span class="sd">        Beauce et al. 2022, else use the classic linear method</span>
<span class="sd">        due to Michael 1984.</span>
<span class="sd">    Tarantola_kwargs: Dictionary, default to {}</span>
<span class="sd">        If not None, should contain key word arguments</span>
<span class="sd">        for the Tarantola and Valette inversion. An empty dictionary</span>
<span class="sd">        uses the default values in `Tarantola_Valette`. If None, uses</span>
<span class="sd">        the Moore-Penrose inverse.</span>
<span class="sd">    return_stats: boolean, default to True</span>
<span class="sd">        If True, the posterior data and model parameter distributions</span>
<span class="sd">        estimated from the Tarantola and Valette formula</span>
<span class="sd">        (cf. Tarantola_Valette routine).</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: dict {str: numpy.ndarray}</span>
<span class="sd">        - output[&quot;stress_tensor&quot;]: (3, 3) numpy.ndarray</span>
<span class="sd">            The inverted stress tensor in the (north, west, up)</span>
<span class="sd">            coordinate system.</span>
<span class="sd">        - output[&quot;principal_stresses&quot;]: (3,) numpy.ndarray, optional</span>
<span class="sd">            The three eigenvalues of the stress tensor, ordered from</span>
<span class="sd">            most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">            Returned if `return_eigen` is True.</span>
<span class="sd">        - output[&quot;principal_directions&quot;]: (3, 3) numpy.ndarray, optional</span>
<span class="sd">            The three eigenvectors of the stress tensor, stored in a matrix</span>
<span class="sd">            as column vectors and ordered from most compressive (sigma1)</span>
<span class="sd">            to least compressive (sigma3). The direction of sigma_i is</span>
<span class="sd">            given by: `principal_directions[:, i]`.</span>
<span class="sd">            Returned if `return_eigen` is True.</span>
<span class="sd">        - output[&quot;C_m_posterior&quot;]: (5, 5) numpy.ndarray, optional</span>
<span class="sd">            Posterior covariance of the model parameter distribution</span>
<span class="sd">            estimated from the Tarantola and Valette formula.</span>
<span class="sd">            Returned if `return_stats` is True.</span>
<span class="sd">        - output[&quot;C_d_posterior&quot;]: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray, optional</span>
<span class="sd">            Posterior covariance of the data distribution</span>
<span class="sd">            estimated from the Tarantola and Valette formula.</span>
<span class="sd">            Returned if `return_stats` is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute auxiliary planes</span>
    <span class="n">strikes_1</span><span class="p">,</span> <span class="n">dips_1</span><span class="p">,</span> <span class="n">rakes_1</span> <span class="o">=</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span>
    <span class="n">strikes_2</span><span class="p">,</span> <span class="n">dips_2</span><span class="p">,</span> <span class="n">rakes_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">utils_stress</span><span class="o">.</span><span class="n">aux_plane</span><span class="p">,</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span><span class="p">))</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># define shape variable</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strikes</span><span class="p">)</span>
    <span class="c1"># define flat arrays</span>
    <span class="n">strikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">strikes_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">strikes_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">dips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dips_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dips_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">rakes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rakes_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rakes_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="c1"># initialize the average stress tensor array</span>
    <span class="n">avg_stress_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># initialize posterior covariance matrices</span>
    <span class="n">avg_C_m_posterior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">avg_C_d_posterior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n_earthquakes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="p">)</span>
    <span class="c1"># randomly select subsets of nodal planes and invert for the stress tensor</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_random_selections</span><span class="p">):</span>
        <span class="n">nodal_planes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span><span class="p">)</span>
        <span class="n">flat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">nodal_planes</span><span class="p">)</span>
        <span class="n">selected_strikes</span> <span class="o">=</span> <span class="n">strikes</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="n">selected_dips</span> <span class="o">=</span> <span class="n">dips</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="n">selected_rakes</span> <span class="o">=</span> <span class="n">rakes</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="c1"># invert this subset of nodal planes</span>
        <span class="k">if</span> <span class="n">variable_shear</span><span class="p">:</span>
            <span class="c1"># invert for both the stress tensor and values</span>
            <span class="c1"># of (normalized) resolved shear stress magnitude</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">iterative_linear_si</span><span class="p">(</span>
                <span class="n">selected_strikes</span><span class="p">,</span>
                <span class="n">selected_dips</span><span class="p">,</span>
                <span class="n">selected_rakes</span><span class="p">,</span>
                <span class="n">max_n_iterations</span><span class="o">=</span><span class="n">max_n_iterations</span><span class="p">,</span>
                <span class="n">shear_update_atol</span><span class="o">=</span><span class="n">shear_update_atol</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># invert only for the stress tensor, assuming</span>
            <span class="c1"># constant shear stress on all faults</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">Michael1984_inversion</span><span class="p">(</span>
                <span class="n">selected_strikes</span><span class="p">,</span>
                <span class="n">selected_dips</span><span class="p">,</span>
                <span class="n">selected_rakes</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># add them to the average</span>
        <span class="n">avg_stress_tensor</span> <span class="o">+=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span>
        <span class="n">avg_C_m_posterior</span> <span class="o">+=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;C_m_posterior&quot;</span><span class="p">]</span>
        <span class="n">avg_C_d_posterior</span> <span class="o">+=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;C_d_posterior&quot;</span><span class="p">]</span>
    <span class="n">avg_stress_tensor</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_random_selections</span><span class="p">)</span>
    <span class="n">avg_C_m_posterior</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_random_selections</span><span class="p">)</span>
    <span class="n">avg_C_d_posterior</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_random_selections</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">avg_stress_tensor</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">norm</span>
    <span class="n">avg_stress_tensor</span> <span class="o">/=</span> <span class="n">norm</span>
    <span class="c1"># return output in dictionary</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg_stress_tensor</span>
    <span class="k">if</span> <span class="n">return_eigen</span><span class="p">:</span>
        <span class="c1"># solve the eigenvalue problem</span>
        <span class="p">(</span>
            <span class="n">principal_stresses</span><span class="p">,</span>
            <span class="n">principal_directions</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span><span class="n">avg_stress_tensor</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;principal_stresses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal_stresses</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;principal_directions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal_directions</span>
    <span class="k">if</span> <span class="n">return_stats</span><span class="p">:</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_d_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg_C_d_posterior</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_m_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg_C_m_posterior</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="inversion_jackknife"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.inversion_jackknife">[docs]</a><span class="k">def</span> <span class="nf">inversion_jackknife</span><span class="p">(</span>
    <span class="n">jack_strikes</span><span class="p">,</span>
    <span class="n">jack_dips</span><span class="p">,</span>
    <span class="n">jack_rakes</span><span class="p">,</span>
    <span class="n">n_random_selections</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">n_resamplings</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">shear_update_atol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">variable_shear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">bootstrap_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine was tailored for one of my application, but it can</span>
<span class="sd">    be of interest to others. Each earthquake comes with an ensemble</span>
<span class="sd">    of focal mechanism solutions that were obtained by resampling the</span>
<span class="sd">    set of seismic stations used in the focal mechanism inversion. The</span>
<span class="sd">    resampling was done with the delete-k-jackknife method, hence the</span>
<span class="sd">    name of the routine. This routine randomly samples focal mechanisms</span>
<span class="sd">    from these ensembles and runs the stress inversion. This is a way</span>
<span class="sd">    of propagating the focal mechanism uncertainties into the stress</span>
<span class="sd">    inversion. In this routine we do not seek which nodal planes are</span>
<span class="sd">    more likely to be the fault planes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    jack_strikes: (n_earthquakes, n_jackknifes) numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    jack_dips: (n_earthquakes, n_jackknifes) numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    jack_rakes: (n_earthquakes, n_jackknifes) numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    n_random_selections: integer, default to 20</span>
<span class="sd">        Number of random selections of subsets of nodal planes on</span>
<span class="sd">        which the stress inversion is run. The final stress tensor</span>
<span class="sd">        is averaged over the n_random_selections solutions.</span>
<span class="sd">    n_resamplings: integer, default to 100</span>
<span class="sd">        Number of times the data set is resampled from the ensembles</span>
<span class="sd">        of focal mechanism solutions available for each earthquake.</span>
<span class="sd">        n_resamplings stress tensors are returned, allowing to</span>
<span class="sd">        estimate uncertainties from the distribution of solutions.</span>
<span class="sd">    bootstrap_events: boolean, default to False</span>
<span class="sd">        If True, the resampling is also done accross earthquakes,</span>
<span class="sd">        following the bootstrapping method.</span>
<span class="sd">    shear_update_atol: float, default to 1e-5</span>
<span class="sd">        Convergence criterion on the shear stress magnitude updates.</span>
<span class="sd">        Convergence is reached when the RMS difference between two</span>
<span class="sd">        estimates of shear stress magnitudes falls below that threshold.</span>
<span class="sd">    max_n_iterations: integer, default to 300</span>
<span class="sd">        The maximum number of iterations if shear stress magnitude update</span>
<span class="sd">        does not fall below `shear_update_atol`.</span>
<span class="sd">    variable_shear: boolean, default to True</span>
<span class="sd">        If True, use the iterative linear method described in</span>
<span class="sd">        Beauce et al. 2022, else use the classic linear method</span>
<span class="sd">        due to Michael 1984.</span>
<span class="sd">    Tarantola_kwargs: Dictionary, default to {}</span>
<span class="sd">        If not None, should contain key word arguments</span>
<span class="sd">        for the Tarantola and Valette inversion. An empty dictionary</span>
<span class="sd">        uses the default values in `Tarantola_Valette`. If None, uses</span>
<span class="sd">        the Moore-Penrose inverse.</span>


<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: dict {str: numpy.ndarray}</span>
<span class="sd">        - output[&quot;jack_stress_tensor&quot;]: (n_resamplings, 3, 3) numpy.ndarray</span>
<span class="sd">            The inverted stress tensor in the (north, west, up)</span>
<span class="sd">            coordinate system.</span>
<span class="sd">        - output[&quot;jack_principal_stresses&quot;]: (n_resamplings, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvalues of the stress tensor, ordered from</span>
<span class="sd">            most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        - output[&quot;jack_principal_directions&quot;]: (n_resamplings, 3, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvectors of the stress tensor, stored in a matrix</span>
<span class="sd">            as column vectors and ordered from most compressive (sigma1)</span>
<span class="sd">            to least compressive (sigma3). The direction of sigma_i for</span>
<span class="sd">            the b-th jackknife replica is given by:</span>
<span class="sd">            `jack_principal_directions[b, :, i]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute auxiliary planes</span>
    <span class="n">jack_strikes_1</span><span class="p">,</span> <span class="n">jack_dips_1</span><span class="p">,</span> <span class="n">jack_rakes_1</span> <span class="o">=</span> <span class="n">jack_strikes</span><span class="p">,</span> <span class="n">jack_dips</span><span class="p">,</span> <span class="n">jack_rakes</span>
    <span class="n">jack_strikes_2</span><span class="p">,</span> <span class="n">jack_dips_2</span><span class="p">,</span> <span class="n">jack_rakes_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">utils_stress</span><span class="o">.</span><span class="n">aux_plane</span><span class="p">)(</span>
        <span class="n">jack_strikes_1</span><span class="p">,</span> <span class="n">jack_dips_1</span><span class="p">,</span> <span class="n">jack_rakes_1</span>
    <span class="p">)</span>
    <span class="c1"># define shape variables</span>
    <span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">n_jackknife</span> <span class="o">=</span> <span class="n">jack_strikes_1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_planes_per_tp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_jackknife</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># define flat arrays</span>
    <span class="n">jack_strikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">jack_strikes_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">jack_strikes_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">jack_dips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">jack_dips_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">jack_dips_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">jack_rakes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">jack_rakes_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">jack_rakes_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="c1"># initialize the average stress tensor arrays</span>
    <span class="n">jack_avg_stress_tensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">jack_principal_stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">jack_principal_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">):</span>
        <span class="n">bootstrap_fm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jackknife</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">bootstrap_events</span><span class="p">:</span>
            <span class="n">bootstrap_ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span>
            <span class="p">)</span>
        <span class="c1"># see inversion_bootstrap for reason for commenting the extra loop</span>
        <span class="c1"># for n in range(n_random_selections):</span>
        <span class="n">nodal_planes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bootstrap_events</span><span class="p">:</span>
            <span class="n">flat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span>
                <span class="n">bootstrap_ev</span> <span class="o">*</span> <span class="n">n_planes_per_tp</span> <span class="o">+</span> <span class="n">bootstrap_fm</span> <span class="o">+</span> <span class="n">nodal_planes</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_planes_per_tp</span> <span class="o">+</span> <span class="n">bootstrap_fm</span> <span class="o">+</span> <span class="n">nodal_planes</span>
            <span class="p">)</span>
        <span class="n">selected_strikes</span> <span class="o">=</span> <span class="n">jack_strikes</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="n">selected_dips</span> <span class="o">=</span> <span class="n">jack_dips</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="n">selected_rakes</span> <span class="o">=</span> <span class="n">jack_rakes</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="c1"># invert this subset of nodal planes</span>
        <span class="k">if</span> <span class="n">variable_shear</span><span class="p">:</span>
            <span class="c1"># invert for both the stress tensor and values</span>
            <span class="c1"># of (normalized) resolved shear stress magnitude</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">iterative_linear_si</span><span class="p">(</span>
                <span class="n">selected_strikes</span><span class="p">,</span>
                <span class="n">selected_dips</span><span class="p">,</span>
                <span class="n">selected_rakes</span><span class="p">,</span>
                <span class="n">max_n_iterations</span><span class="o">=</span><span class="n">max_n_iterations</span><span class="p">,</span>
                <span class="n">shear_update_atol</span><span class="o">=</span><span class="n">shear_update_atol</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># invert only for the stress tensor, assuming</span>
            <span class="c1"># constant shear stress on all faults</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">Michael1984_inversion</span><span class="p">(</span>
                <span class="n">selected_strikes</span><span class="p">,</span>
                <span class="n">selected_dips</span><span class="p">,</span>
                <span class="n">selected_rakes</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">jack_avg_stress_tensors</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span>
        <span class="p">(</span>
            <span class="n">jack_principal_stresses</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="n">jack_principal_directions</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span>
            <span class="n">jack_avg_stress_tensors</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;jack_stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jack_avg_stress_tensors</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;jack_principal_stresses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jack_principal_stresses</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;jack_principal_directions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jack_principal_directions</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="inversion_bootstrap"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.inversion_bootstrap">[docs]</a><span class="k">def</span> <span class="nf">inversion_bootstrap</span><span class="p">(</span>
    <span class="n">strikes</span><span class="p">,</span>
    <span class="n">dips</span><span class="p">,</span>
    <span class="n">rakes</span><span class="p">,</span>
    <span class="n">n_random_selections</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">n_resamplings</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">variable_shear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">shear_update_atol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="p">{},</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts one set of focal mechanisms without seeking which nodal planes</span>
<span class="sd">    are more likely to be the fault planes. Performs bootstrap resampling</span>
<span class="sd">    of the data set to return an ensemble of solutions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    strikes: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    n_random_selections: integer, default to 5</span>
<span class="sd">        Number of random selections of subsets of nodal planes on</span>
<span class="sd">        which the stress inversion is run. The final stress tensor</span>
<span class="sd">        is averaged over the n_random_selections solutions.</span>
<span class="sd">    n_resamplings: integer, default to 100</span>
<span class="sd">        Number of times the data set is resampled following</span>
<span class="sd">        the bootstrapping method (sampling with replacement).</span>
<span class="sd">        n_resamplings stress tensors are returned, allowing to</span>
<span class="sd">        estimate uncertainties from the distribution of solutions.</span>
<span class="sd">    shear_update_atol: float, default to 1e-5</span>
<span class="sd">        Convergence criterion on the shear stress magnitude updates.</span>
<span class="sd">        Convergence is reached when the RMS difference between two</span>
<span class="sd">        estimates of shear stress magnitudes falls below that threshold.</span>
<span class="sd">    max_n_iterations: integer, default to 300</span>
<span class="sd">        The maximum number of iterations if shear stress magnitude update</span>
<span class="sd">        does not fall below `shear_update_atol`.</span>
<span class="sd">    variable_shear: boolean, default to True</span>
<span class="sd">        If True, use the iterative linear method described in</span>
<span class="sd">        Beauce et al. 2022, else use the classic linear method</span>
<span class="sd">        due to Michael 1984.</span>
<span class="sd">    Tarantola_kwargs: Dictionary, default to {}</span>
<span class="sd">        If not None, should contain key word arguments</span>
<span class="sd">        for the Tarantola and Valette inversion. An empty dictionary</span>
<span class="sd">        uses the default values in `Tarantola_Valette`. If None, uses</span>
<span class="sd">        the Moore-Penrose inverse.</span>


<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: dict {str: numpy.ndarray}</span>
<span class="sd">        - output[&quot;boot_stress_tensor&quot;]: (n_resamplings, 3, 3) numpy.ndarray</span>
<span class="sd">            The inverted stress tensor in the (north, west, up)</span>
<span class="sd">            coordinate system.</span>
<span class="sd">        - output[&quot;boot_principal_stresses&quot;]: (n_resamplings, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvalues of the stress tensor, ordered from</span>
<span class="sd">            most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        - output[&quot;boot_principal_directions&quot;]: (n_resamplings, 3, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvectors of the stress tensor, stored in a matrix</span>
<span class="sd">            as column vectors and ordered from most compressive (sigma1)</span>
<span class="sd">            to least compressive (sigma3). The direction of sigma_i for</span>
<span class="sd">            the b-th bootstrap replica is given by:</span>
<span class="sd">            `boot_principal_directions[b, :, i]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># compute auxiliary planes</span>
    <span class="n">strikes_1</span><span class="p">,</span> <span class="n">dips_1</span><span class="p">,</span> <span class="n">rakes_1</span> <span class="o">=</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span>
    <span class="n">strikes_2</span><span class="p">,</span> <span class="n">dips_2</span><span class="p">,</span> <span class="n">rakes_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">utils_stress</span><span class="o">.</span><span class="n">aux_plane</span><span class="p">,</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span><span class="p">))</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># define shape variables</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strikes_1</span><span class="p">)</span>
    <span class="n">n_planes_per_ev</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1"># initialize the average stress tensor arrays</span>
    <span class="n">boot_avg_stress_tensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">boot_principal_stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">boot_principal_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># flatten strikes/dips/rakes of planes</span>
    <span class="n">strikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">strikes_1</span><span class="p">,</span> <span class="n">strikes_2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">dips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">dips_1</span><span class="p">,</span> <span class="n">dips_2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">rakes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">rakes_1</span><span class="p">,</span> <span class="n">rakes_2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---------- Bootstrapping </span><span class="si">{</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n_resamplings</span><span class="si">}</span><span class="s2"> ----------&quot;</span><span class="p">)</span>
        <span class="n">bootstrap_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span>
        <span class="p">)</span>
        <span class="c1"># I now believe there is no point in adding this extra loop</span>
        <span class="c1"># in the bootstrapping method. Averaging only disturbs the</span>
        <span class="c1"># uncertainty estimation</span>
        <span class="c1"># for n in range(n_random_selections):</span>
        <span class="n">nodal_planes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span><span class="p">)</span>
        <span class="n">flat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">bootstrap_set</span> <span class="o">*</span> <span class="n">n_planes_per_ev</span> <span class="o">+</span> <span class="n">nodal_planes</span><span class="p">)</span>
        <span class="n">selected_strikes</span> <span class="o">=</span> <span class="n">strikes</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="n">selected_dips</span> <span class="o">=</span> <span class="n">dips</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="n">selected_rakes</span> <span class="o">=</span> <span class="n">rakes</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
        <span class="c1"># invert this subset of nodal planes</span>
        <span class="k">if</span> <span class="n">variable_shear</span><span class="p">:</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">iterative_linear_si</span><span class="p">(</span>
                <span class="n">selected_strikes</span><span class="p">,</span>
                <span class="n">selected_dips</span><span class="p">,</span>
                <span class="n">selected_rakes</span><span class="p">,</span>
                <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">Michael1984_inversion</span><span class="p">(</span>
                <span class="n">selected_strikes</span><span class="p">,</span>
                <span class="n">selected_dips</span><span class="p">,</span>
                <span class="n">selected_rakes</span><span class="p">,</span>
                <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">boot_avg_stress_tensors</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span>
        <span class="p">(</span>
            <span class="n">boot_principal_stresses</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="n">boot_principal_directions</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span>
            <span class="n">boot_avg_stress_tensors</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;boot_stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boot_avg_stress_tensors</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;boot_principal_stresses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boot_principal_stresses</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;boot_principal_directions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boot_principal_directions</span>
    <span class="k">return</span> <span class="n">output</span></div>


<span class="c1"># ---------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#   Routines for inversion with instability parameter</span>
<span class="c1">#</span>
<span class="c1"># ---------------------------------------------------</span>


<div class="viewcode-block" id="inversion_one_set_instability"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.inversion_one_set_instability">[docs]</a><span class="k">def</span> <span class="nf">inversion_one_set_instability</span><span class="p">(</span>
    <span class="n">strikes</span><span class="p">,</span>
    <span class="n">dips</span><span class="p">,</span>
    <span class="n">rakes</span><span class="p">,</span>
    <span class="n">friction_coefficient</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
    <span class="n">friction_min</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">friction_max</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
    <span class="n">friction_step</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
    <span class="n">n_stress_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">n_random_selections</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">stress_tensor_update_atol</span><span class="o">=</span><span class="mf">1.0e-4</span><span class="p">,</span>
    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">shear_update_atol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">n_averaging</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">signed_instability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">variable_shear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invert one set of focal mechanisms with the instability parameter</span>
<span class="sd">    to seek which nodal planes are more likely to be the fault planes</span>
<span class="sd">    (cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).</span>
<span class="sd">    In general, you can keep the default parameter values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    strikes: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    friction_coefficient: float or None, default to 0.6</span>
<span class="sd">        If not None, the inversion is made assuming a friction coefficient</span>
<span class="sd">        equal to `friction_coefficient`. If None, the friction coefficient</span>
<span class="sd">        is taken as the one that maximizes instability based on a first</span>
<span class="sd">        approximation of the stress tensor.</span>
<span class="sd">    friction_min: float, default to 0.1</span>
<span class="sd">        Lower bound of explored friction values.</span>
<span class="sd">    friction_max: float, default to 0.8</span>
<span class="sd">        Upper bound of explored friction values.</span>
<span class="sd">    friction_step: float, default to 0.05</span>
<span class="sd">        Step employed in the grid search of the friction value</span>
<span class="sd">        that maximizes the instability parameter.</span>
<span class="sd">    n_stress_iter: integer, default to 10</span>
<span class="sd">        Maximum number of iterations to seek for the best fault planes.</span>
<span class="sd">        See Beauce et al. 2022 for explanations.</span>
<span class="sd">    stress_tensor_update_atol: float, default to 1.e-4</span>
<span class="sd">        If the RMS difference of the stress tensors between two</span>
<span class="sd">        iterations fall below this threshold, convergence has been reached.</span>
<span class="sd">    n_random_selections: integer, default to 20</span>
<span class="sd">        Number of random selections of subsets of nodal planes on</span>
<span class="sd">        which the stress inversion is run. The final stress tensor</span>
<span class="sd">        is averaged over the n_random_selections solutions.</span>
<span class="sd">    shear_update_atol: float, default to 1e-5</span>
<span class="sd">        Convergence criterion on the shear stress magnitude updates.</span>
<span class="sd">        Convergence is reached when the RMS difference between two</span>
<span class="sd">        estimates of shear stress magnitudes falls below that threshold.</span>
<span class="sd">    max_n_iterations: integer, default to 300</span>
<span class="sd">        The maximum number of iterations if shear stress magnitude update</span>
<span class="sd">        does not fall below `shear_update_atol`.</span>
<span class="sd">    variable_shear: boolean, default to True</span>
<span class="sd">        If True, use the iterative linear method described in</span>
<span class="sd">        Beauce et al. 2022, else use the classic linear method</span>
<span class="sd">        due to Michael 1984.</span>
<span class="sd">    n_averaging: integer, default to 1</span>
<span class="sd">        The inversion can be sensitive to initial conditions. To improve</span>
<span class="sd">        reproducibility of the results it is good to repeat the inversion</span>
<span class="sd">        several times and average the results. Set `n_averaging` to ~5 if</span>
<span class="sd">        you can afford the increase in run time.</span>
<span class="sd">    signed_instability: boolean, default to False</span>
<span class="sd">        If True, the instability parameter ranges from -1 to +1. Negative</span>
<span class="sd">        values mean that the predicted and observed slip have opposite</span>
<span class="sd">        directions. If False, the instability parameter is the one</span>
<span class="sd">        defined in Vavrycuk 2013, 2014.</span>
<span class="sd">    Tarantola_kwargs: Dictionary, default to {}</span>
<span class="sd">        If not None, should contain key word arguments</span>
<span class="sd">        for the Tarantola and Valette inversion. An empty dictionary</span>
<span class="sd">        uses the default values in `Tarantola_Valette`. If None, uses</span>
<span class="sd">        the Moore-Penrose inverse.</span>
<span class="sd">    return_stats: boolean, default to True</span>
<span class="sd">        If True, the posterior data and model parameter distributions</span>
<span class="sd">        estimated from the Tarantola and Valette formula</span>
<span class="sd">        (cf. Tarantola_Valette routine).</span>
<span class="sd">    weighted: boolean, default to False</span>
<span class="sd">        This option is exploratory. If True:</span>
<span class="sd">            1) More weight is given to the fault planes that are clearly</span>
<span class="sd">               more unstable than their auxiliary counterpart in the</span>
<span class="sd">               stress field estimated at iteration t-1</span>
<span class="sd">            2) Randomly mixes the set of fault planes at iterations</span>
<span class="sd">               t-1 and t, giving larger probability to the planes</span>
<span class="sd">               belonging to the set that produced the larger instability.</span>
<span class="sd">        This option can be interesting for reaching convergence on</span>
<span class="sd">        data sets of bad quality.</span>
<span class="sd">    plot: boolean, default to False</span>
<span class="sd">        If True, plot the set of nodal planes selected at each iteration,</span>
<span class="sd">        and the weight attributed to each of these planes. Can be used</span>
<span class="sd">        with `weighted=True` to see if the inversion convergences to a</span>
<span class="sd">        well defined set of planes.</span>
<span class="sd">    verbose: integer, default to 1</span>
<span class="sd">        Level of verbosity.</span>
<span class="sd">        0: No print statements.</span>
<span class="sd">        1: Print whether the algorithm converged.</span>
<span class="sd">        2: Print the stress tensor at the end of each fault plane</span>
<span class="sd">           selection iteration.</span>


<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: dict {str: numpy.ndarray}</span>
<span class="sd">        - output[&quot;stress_tensor&quot;]: (3, 3) numpy.ndarray</span>
<span class="sd">            The inverted stress tensor in the (north, west, up)</span>
<span class="sd">            coordinate system.</span>
<span class="sd">        - output[&quot;friction_coefficient&quot;]: scalar float</span>
<span class="sd">            The best friction coefficient determined by the inversion</span>
<span class="sd">            or the input friction coefficient (see `friction_coefficient`).</span>
<span class="sd">        - output[&quot;principal_stresses&quot;]: (3,) numpy.ndarray</span>
<span class="sd">            The three eigenvalues of the stress tensor, ordered from</span>
<span class="sd">            most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        - output[&quot;principal_directions&quot;]: (3, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvectors of the stress tensor, stored in a matrix</span>
<span class="sd">            as column vectors and ordered from most compressive (sigma1)</span>
<span class="sd">            to least compressive (sigma3). The direction of sigma_i is</span>
<span class="sd">            given by: `principal_directions[:, i]`.</span>
<span class="sd">        - output[&quot;C_m_posterior&quot;]: (5, 5) numpy.ndarray, optional</span>
<span class="sd">            Posterior covariance of the model parameter distribution</span>
<span class="sd">            estimated from the Tarantola and Valette formula.</span>
<span class="sd">            Returned if `return_stats` is True.</span>
<span class="sd">        - output[&quot;C_d_posterior&quot;]: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray, optional</span>
<span class="sd">            Posterior covariance of the data distribution</span>
<span class="sd">            estimated from the Tarantola and Valette formula.</span>
<span class="sd">            Returned if `return_stats` is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">mplstereonet</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">Normalize</span>
        <span class="kn">from</span> <span class="nn">matplotlib.cm</span> <span class="kn">import</span> <span class="n">ScalarMappable</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
    <span class="c1"># compute auxiliary planes</span>
    <span class="n">strikes_1</span><span class="p">,</span> <span class="n">dips_1</span><span class="p">,</span> <span class="n">rakes_1</span> <span class="o">=</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span>
    <span class="n">strikes_2</span><span class="p">,</span> <span class="n">dips_2</span><span class="p">,</span> <span class="n">rakes_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">utils_stress</span><span class="o">.</span><span class="n">aux_plane</span><span class="p">,</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span><span class="p">))</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># define shape variable</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="n">strikes_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># define flat arrays</span>
    <span class="n">strikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">strikes_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">strikes_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">dips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dips_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dips_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">rakes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rakes_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rakes_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="c1"># initialized averaged outputs</span>
    <span class="n">final_stress_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">C_d_posterior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n_earthquakes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">C_m_posterior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">friction_coefficient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">final_friction_coefficient</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_averaging</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-------- </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n_averaging</span><span class="si">}</span><span class="s2"> ----------&quot;</span><span class="p">)</span>
        <span class="c1"># The stress inversion is sensitive to initial conditions,</span>
        <span class="c1"># which are random, especially when dealing with highly</span>
        <span class="c1"># noisy focal mechanisms. Therefore, one can repeat the inversion</span>
        <span class="c1"># n_averaging times and average the results.</span>
        <span class="c1"># -----------------------------------------</span>
        <span class="c1"># initialize the average stress tensor array by repeating the</span>
        <span class="c1"># stress inversion on n_random_selections datasets drawn by</span>
        <span class="c1"># randomly selecting either of the nodal planes as the fault planes</span>
        <span class="n">avg_stress_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_random_selections</span><span class="p">):</span>
            <span class="n">nodal_planes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span><span class="p">)</span>
            <span class="n">flat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">nodal_planes</span><span class="p">)</span>
            <span class="n">selected_strikes</span> <span class="o">=</span> <span class="n">strikes</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
            <span class="n">selected_dips</span> <span class="o">=</span> <span class="n">dips</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
            <span class="n">selected_rakes</span> <span class="o">=</span> <span class="n">rakes</span><span class="p">[</span><span class="n">flat_indexes</span><span class="p">]</span>
            <span class="c1"># invert this subset of nodal planes</span>
            <span class="k">if</span> <span class="n">variable_shear</span><span class="p">:</span>
                <span class="n">output_</span> <span class="o">=</span> <span class="n">iterative_linear_si</span><span class="p">(</span>
                    <span class="n">selected_strikes</span><span class="p">,</span>
                    <span class="n">selected_dips</span><span class="p">,</span>
                    <span class="n">selected_rakes</span><span class="p">,</span>
                    <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                    <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_</span> <span class="o">=</span> <span class="n">Michael1984_inversion</span><span class="p">(</span>
                    <span class="n">selected_strikes</span><span class="p">,</span>
                    <span class="n">selected_dips</span><span class="p">,</span>
                    <span class="n">selected_rakes</span><span class="p">,</span>
                    <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># add them to the average</span>
            <span class="n">avg_stress_tensor</span> <span class="o">+=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span>
        <span class="n">avg_stress_tensor</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_random_selections</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">principal_stresses</span><span class="p">,</span>
            <span class="n">principal_directions</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span><span class="n">avg_stress_tensor</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">R_</span><span class="p">(</span><span class="n">principal_stresses</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial shape ratio: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">friction_coefficient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="c1">#  Repeat the whole inversion for a range of friction coefficients</span>
            <span class="c1">#  and keep the inversion results and friction coefficient</span>
            <span class="c1">#  that produced the highest average fault plane instability</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="n">friction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">friction_min</span><span class="p">,</span> <span class="n">friction_max</span> <span class="o">+</span> <span class="n">friction_step</span><span class="p">,</span> <span class="n">friction_step</span>
            <span class="p">)</span>
            <span class="n">n_fric</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">friction</span><span class="p">)</span>
            <span class="n">Imax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1000.0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">mu_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">friction</span><span class="p">):</span>
                <span class="c1"># run inversion for current value of friction coefficient</span>
                <span class="n">output_j</span> <span class="o">=</span> <span class="n">_stress_inversion_instability</span><span class="p">(</span>
                    <span class="n">avg_stress_tensor</span><span class="p">,</span>
                    <span class="n">mu_j</span><span class="p">,</span>
                    <span class="n">strikes_1</span><span class="p">,</span>
                    <span class="n">dips_1</span><span class="p">,</span>
                    <span class="n">rakes_1</span><span class="p">,</span>
                    <span class="n">strikes_2</span><span class="p">,</span>
                    <span class="n">dips_2</span><span class="p">,</span>
                    <span class="n">rakes_2</span><span class="p">,</span>
                    <span class="n">n_stress_iter</span><span class="o">=</span><span class="n">n_stress_iter</span><span class="p">,</span>
                    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                    <span class="n">variable_shear</span><span class="o">=</span><span class="n">variable_shear</span><span class="p">,</span>
                    <span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">,</span>
                    <span class="n">max_n_iterations</span><span class="o">=</span><span class="n">max_n_iterations</span><span class="p">,</span>
                    <span class="n">shear_update_atol</span><span class="o">=</span><span class="n">shear_update_atol</span><span class="p">,</span>
                    <span class="n">stress_tensor_update_atol</span><span class="o">=</span><span class="n">stress_tensor_update_atol</span><span class="p">,</span>
                    <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                    <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># compute eigendecomposition of inverted stress tensor</span>
                <span class="p">(</span>
                    <span class="n">principal_stresses</span><span class="p">,</span>
                    <span class="n">principal_directions</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span>
                    <span class="n">output_j</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">R_</span><span class="p">(</span><span class="n">principal_stresses</span><span class="p">)</span>
                <span class="c1"># compute the average fault plane instability</span>
                <span class="n">I_j</span> <span class="o">=</span> <span class="n">compute_instability_parameter</span><span class="p">(</span>
                    <span class="n">principal_directions</span><span class="p">,</span>
                    <span class="n">R</span><span class="p">,</span>
                    <span class="n">mu_j</span><span class="p">,</span>
                    <span class="n">strikes_1</span><span class="p">,</span>
                    <span class="n">dips_1</span><span class="p">,</span>
                    <span class="n">rakes_1</span><span class="p">,</span>
                    <span class="n">strikes_2</span><span class="p">,</span>
                    <span class="n">dips_2</span><span class="p">,</span>
                    <span class="n">rakes_2</span><span class="p">,</span>
                    <span class="n">return_fault_planes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">I_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">I_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">I_j</span> <span class="o">&gt;</span> <span class="n">Imax</span><span class="p">:</span>
                    <span class="c1"># new best solution</span>
                    <span class="n">Imax</span> <span class="o">=</span> <span class="n">I_j</span>
                    <span class="n">output_</span> <span class="o">=</span> <span class="n">output_j</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">best_friction_coefficient</span> <span class="o">=</span> <span class="n">mu_j</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># friction coefficient was given by user</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">_stress_inversion_instability</span><span class="p">(</span>
                <span class="n">avg_stress_tensor</span><span class="p">,</span>
                <span class="n">friction_coefficient</span><span class="p">,</span>
                <span class="n">strikes_1</span><span class="p">,</span>
                <span class="n">dips_1</span><span class="p">,</span>
                <span class="n">rakes_1</span><span class="p">,</span>
                <span class="n">strikes_2</span><span class="p">,</span>
                <span class="n">dips_2</span><span class="p">,</span>
                <span class="n">rakes_2</span><span class="p">,</span>
                <span class="n">n_stress_iter</span><span class="o">=</span><span class="n">n_stress_iter</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                <span class="n">variable_shear</span><span class="o">=</span><span class="n">variable_shear</span><span class="p">,</span>
                <span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">,</span>
                <span class="n">max_n_iterations</span><span class="o">=</span><span class="n">max_n_iterations</span><span class="p">,</span>
                <span class="n">shear_update_atol</span><span class="o">=</span><span class="n">shear_update_atol</span><span class="p">,</span>
                <span class="n">stress_tensor_update_atol</span><span class="o">=</span><span class="n">stress_tensor_update_atol</span><span class="p">,</span>
                <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">final_stress_tensor</span> <span class="o">+=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span>
        <span class="n">C_d_posterior</span> <span class="o">+=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;C_d_posterior&quot;</span><span class="p">]</span>
        <span class="n">C_m_posterior</span> <span class="o">+=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;C_m_posterior&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">friction_coefficient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># friction coefficient is being inverted for</span>
            <span class="n">final_friction_coefficient</span> <span class="o">+=</span> <span class="n">best_friction_coefficient</span>
    <span class="n">final_stress_tensor</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_averaging</span><span class="p">)</span>
    <span class="n">C_d_posterior</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_averaging</span><span class="p">)</span>
    <span class="n">C_m_posterior</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_averaging</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">friction_coefficient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">friction_coefficient</span> <span class="o">=</span> <span class="n">final_friction_coefficient</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_averaging</span><span class="p">)</span>
    <span class="c1"># eigendecomposition of averaged stress tensor</span>
    <span class="p">(</span>
        <span class="n">principal_stresses</span><span class="p">,</span>
        <span class="n">principal_directions</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span><span class="n">final_stress_tensor</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">R_</span><span class="p">(</span><span class="n">principal_stresses</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final results:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stress tensor:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">final_stress_tensor</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape ratio: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_stress_tensor</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;friction_coefficient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">friction_coefficient</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;principal_stresses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal_stresses</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;principal_directions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal_directions</span>
    <span class="k">if</span> <span class="n">return_stats</span><span class="p">:</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_d_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">C_d_posterior</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_m_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">C_m_posterior</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="inversion_jackknife_instability"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.inversion_jackknife_instability">[docs]</a><span class="k">def</span> <span class="nf">inversion_jackknife_instability</span><span class="p">(</span>
    <span class="n">principal_directions</span><span class="p">,</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">jack_strikes</span><span class="p">,</span>
    <span class="n">jack_dips</span><span class="p">,</span>
    <span class="n">jack_rakes</span><span class="p">,</span>
    <span class="n">friction_coefficient</span><span class="p">,</span>
    <span class="n">n_resamplings</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">n_stress_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">stress_tensor_update_atol</span><span class="o">=</span><span class="mf">1.0e-4</span><span class="p">,</span>
    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">bootstrap_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_earthquakes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">variable_shear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">shear_update_atol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">signed_instability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine was tailored for one of my application, but it can</span>
<span class="sd">    be of interest to others. Each earthquake comes with an ensemble</span>
<span class="sd">    of focal mechanism solutions that were obtained by resampling the</span>
<span class="sd">    set of seismic stations used in the focal mechanism inversion. The</span>
<span class="sd">    resampling was done with the delete-k-jackknife method, hence the</span>
<span class="sd">    name of the routine. This routine randomly samples focal mechanisms</span>
<span class="sd">    from these ensembles and runs the stress inversion. This is a way</span>
<span class="sd">    of propagating the focal mechanism uncertainties into the stress</span>
<span class="sd">    inversion. Use the instability parameter to seek which nodal planes</span>
<span class="sd">    are more likely to be the fault planes (cf. B. Lund and R. Slunga 1999,</span>
<span class="sd">    V. Vavrycuk 2013,2014).</span>

<span class="sd">    Use a previously determined stress tensor (e.g. the output of</span>
<span class="sd">    `inversion_one_set_instability`) described by its principal stress</span>
<span class="sd">    directions and shape ratio as the prior model in the Tarantola</span>
<span class="sd">    and Valette formula. In general, you can keep the default parameter</span>
<span class="sd">    values, except for n_resamplings which depends on the time you can</span>
<span class="sd">    afford spending.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    principal_directions: (3, 3) numpy.ndarray, float</span>
<span class="sd">        The three eigenvectors of the reference stress tensor, stored in</span>
<span class="sd">        a matrix as column vectors and ordered from</span>
<span class="sd">        most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        The direction of sigma_i is given by: `principal_directions[:, i]`.</span>
<span class="sd">    R: scalar float</span>
<span class="sd">        Shape ratio of the reference stress tensor.</span>
<span class="sd">    friction_coefficient: scalar float</span>
<span class="sd">        Friction value used in the instability parameter. This can be</span>
<span class="sd">        the value output by `inversion_one_set_instability`.</span>
<span class="sd">    jack_strikes: (n_earthquakes, n_jackknifes) numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    jack_dips: (n_earthquakes, n_jackknifes) numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    jack_rakes: (n_earthquakes, n_jackknifes) numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    n_stress_iter: integer, default to 10</span>
<span class="sd">        Maximum number of iterations to seek for the best fault planes.</span>
<span class="sd">        See Beauce et al. 2022 for explanations.</span>
<span class="sd">    stress_tensor_update_atol: float, default to 1.e-4</span>
<span class="sd">        If the RMS difference of the stress tensors between two</span>
<span class="sd">        iterations fall below this threshold, convergence has been reached.</span>
<span class="sd">    shear_update_atol: float, default to 1e-5</span>
<span class="sd">        Convergence criterion on the shear stress magnitude updates.</span>
<span class="sd">        Convergence is reached when the RMS difference between two</span>
<span class="sd">        estimates of shear stress magnitudes falls below that threshold.</span>
<span class="sd">    signed_instability: boolean, default to False</span>
<span class="sd">        If True, the instability parameter ranges from -1 to +1. Negative</span>
<span class="sd">        values mean that the predicted and observed slip have opposite</span>
<span class="sd">        directions. If False, the instability parameter is the one</span>
<span class="sd">        defined in Vavrycuk 2013, 2014.</span>
<span class="sd">    max_n_iterations: integer, default to 300</span>
<span class="sd">        The maximum number of iterations if shear stress magnitude update</span>
<span class="sd">        does not fall below `shear_update_atol`.</span>
<span class="sd">    variable_shear: boolean, default to True</span>
<span class="sd">        If True, use the iterative linear method described in</span>
<span class="sd">        Beauce et al. 2022, else use the classic linear method</span>
<span class="sd">        due to Michael 1984.</span>
<span class="sd">    Tarantola_kwargs: Dictionary, default to {}</span>
<span class="sd">        If not None, should contain key word arguments</span>
<span class="sd">        for the Tarantola and Valette inversion. An empty dictionary</span>
<span class="sd">        uses the default values in `Tarantola_Valette`. If None, uses</span>
<span class="sd">        the Moore-Penrose inverse.</span>
<span class="sd">    bootstrap_events: boolean, default to False</span>
<span class="sd">        If True, the resampling is also done accross earthquakes,</span>
<span class="sd">        following the bootstrapping method.</span>
<span class="sd">    weighted: boolean, default to False</span>
<span class="sd">        This option is exploratory. If True:</span>
<span class="sd">            1) More weight is given to the fault planes that are clearly</span>
<span class="sd">               more unstable than their auxiliary counterpart in the</span>
<span class="sd">               stress field estimated at iteration t-1</span>
<span class="sd">            2) Randomly mixes the set of fault planes at iterations</span>
<span class="sd">               t-1 and t, giving larger probability to the planes</span>
<span class="sd">               belonging to the set that produced the larger instability.</span>
<span class="sd">        This option can be interesting for reaching convergence on</span>
<span class="sd">        data sets of bad quality.</span>
<span class="sd">    n_threads: scalar int, optional</span>
<span class="sd">        Default to `n_threads=1`. If different from 1, the task is parallelized</span>
<span class="sd">        across `n_threads` threads. If `n_threads` is `0`, `None` or `&quot;all&quot;`,</span>
<span class="sd">        use all available CPUs.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: dict {str: numpy.ndarray}</span>
<span class="sd">        - output[&quot;jack_stress_tensor&quot;]: (n_resamplings, 3, 3) numpy.ndarray</span>
<span class="sd">            The inverted stress tensor in the (north, west, up)</span>
<span class="sd">            coordinate system.</span>
<span class="sd">        - output[&quot;jack_principal_stresses&quot;]: (n_resamplings, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvalues of the stress tensor, ordered from</span>
<span class="sd">            most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        - output[&quot;jack_principal_directions&quot;]: (n_resamplings, 3, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvectors of the stress tensor, stored in a matrix</span>
<span class="sd">            as column vectors and ordered from most compressive (sigma1)</span>
<span class="sd">            to least compressive (sigma3). The direction of sigma_i for</span>
<span class="sd">            the b-th jackknife replica is given by:</span>
<span class="sd">            `jack_principal_directions[b, :, i]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute auxiliary planes</span>
    <span class="n">jack_strikes_1</span><span class="p">,</span> <span class="n">jack_dips_1</span><span class="p">,</span> <span class="n">jack_rakes_1</span> <span class="o">=</span> <span class="n">jack_strikes</span><span class="p">,</span> <span class="n">jack_dips</span><span class="p">,</span> <span class="n">jack_rakes</span>
    <span class="n">jack_strikes_2</span><span class="p">,</span> <span class="n">jack_dips_2</span><span class="p">,</span> <span class="n">jack_rakes_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">utils_stress</span><span class="o">.</span><span class="n">aux_plane</span><span class="p">)(</span>
        <span class="n">jack_strikes_1</span><span class="p">,</span> <span class="n">jack_dips_1</span><span class="p">,</span> <span class="n">jack_rakes_1</span>
    <span class="p">)</span>
    <span class="c1"># make a copy of Tarantola_kwargs, on which this function will work</span>
    <span class="n">Tarantola_kwargs_</span> <span class="o">=</span> <span class="n">Tarantola_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># build reduced stress tensor from principal directions and shape ratio</span>
    <span class="n">stress_tensor_main</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">reduced_stress_tensor</span><span class="p">(</span><span class="n">principal_directions</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="n">sigma_main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># define shape variables</span>
    <span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">n_jackknife</span> <span class="o">=</span> <span class="n">jack_strikes_1</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># initialize the average stress tensor arrays</span>
    <span class="n">jack_stress_tensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">jack_principal_stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">jack_principal_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">jack_strikes_1</span><span class="p">,</span> <span class="n">jack_dips_1</span><span class="p">,</span> <span class="n">jack_rakes_1</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">jack_strikes_1</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
        <span class="n">jack_dips_1</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
        <span class="n">jack_rakes_1</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="n">jack_strikes_2</span><span class="p">,</span> <span class="n">jack_dips_2</span><span class="p">,</span> <span class="n">jack_rakes_2</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">jack_strikes_2</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
        <span class="n">jack_dips_2</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
        <span class="n">jack_rakes_2</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="c1"># n_jackknife = None if bootstrap_events else n_jackknife</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="n">n_earthquakes</span> <span class="k">if</span> <span class="n">bootstrap_events</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">_bootstrap_solution_p</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">_bootstrap_solution</span><span class="p">,</span>
        <span class="n">strikes_1</span><span class="o">=</span><span class="n">jack_strikes_1</span><span class="p">,</span>
        <span class="n">dips_1</span><span class="o">=</span><span class="n">jack_dips_1</span><span class="p">,</span>
        <span class="n">rakes_1</span><span class="o">=</span><span class="n">jack_rakes_1</span><span class="p">,</span>
        <span class="n">strikes_2</span><span class="o">=</span><span class="n">jack_strikes_2</span><span class="p">,</span>
        <span class="n">dips_2</span><span class="o">=</span><span class="n">jack_dips_2</span><span class="p">,</span>
        <span class="n">rakes_2</span><span class="o">=</span><span class="n">jack_rakes_2</span><span class="p">,</span>
        <span class="n">stress_tensor_main</span><span class="o">=</span><span class="n">stress_tensor_main</span><span class="p">,</span>
        <span class="n">friction_coefficient</span><span class="o">=</span><span class="n">friction_coefficient</span><span class="p">,</span>
        <span class="n">stress_tensor_update_atol</span><span class="o">=</span><span class="n">stress_tensor_update_atol</span><span class="p">,</span>
        <span class="n">n_stress_iter</span><span class="o">=</span><span class="n">n_stress_iter</span><span class="p">,</span>
        <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
        <span class="n">variable_shear</span><span class="o">=</span><span class="n">variable_shear</span><span class="p">,</span>
        <span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">,</span>
        <span class="n">max_n_iterations</span><span class="o">=</span><span class="n">max_n_iterations</span><span class="p">,</span>
        <span class="n">shear_update_atol</span><span class="o">=</span><span class="n">shear_update_atol</span><span class="p">,</span>
        <span class="n">n_jackknife</span><span class="o">=</span><span class="n">n_jackknife</span><span class="p">,</span>
        <span class="n">n_earthquakes</span><span class="o">=</span><span class="n">n_earthquakes</span><span class="p">,</span>
        <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;parallel is deprecated. Use n_threads instead.&quot;</span><span class="p">)</span>
        <span class="n">n_threads</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
    <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">concurrent.futures</span>
        <span class="k">if</span> <span class="n">n_threads</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
            <span class="c1"># n_threads = None means use all CPUs</span>
            <span class="n">n_threads</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_bootstrap_solution_p</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">)))</span>
        <span class="n">jack_stress_tensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">results</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">)])</span>
        <span class="n">jack_principal_stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">jack_principal_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">)]</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---------- Bootstrapping </span><span class="si">{</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n_resamplings</span><span class="si">}</span><span class="s2"> ----------&quot;</span><span class="p">)</span>
            <span class="p">(</span>
                <span class="n">jack_stress_tensors</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                <span class="n">jack_principal_stresses</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                <span class="n">jack_principal_directions</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">_bootstrap_solution_p</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;jack_stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jack_stress_tensors</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;jack_principal_stresses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jack_principal_stresses</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;jack_principal_directions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jack_principal_directions</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="inversion_bootstrap_instability"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.inversion_bootstrap_instability">[docs]</a><span class="k">def</span> <span class="nf">inversion_bootstrap_instability</span><span class="p">(</span>
    <span class="n">principal_directions</span><span class="p">,</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">strikes</span><span class="p">,</span>
    <span class="n">dips</span><span class="p">,</span>
    <span class="n">rakes</span><span class="p">,</span>
    <span class="n">friction_coefficient</span><span class="p">,</span>
    <span class="n">n_resamplings</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">n_stress_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">stress_tensor_update_atol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">variable_shear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">shear_update_atol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">signed_instability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invert one set of focal mechanisms with the instability parameter</span>
<span class="sd">    to seek which nodal planes are more likely to be the fault planes</span>
<span class="sd">    (cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).</span>
<span class="sd">    Performs bootstrap resampling of the data set to return an</span>
<span class="sd">    ensemble of solutions.</span>

<span class="sd">    Use a previously determined stress tensor (e.g. the output of</span>
<span class="sd">    `inversion_one_set_instability`) described by its principal stress</span>
<span class="sd">    directions and shape ratio as the prior model in the Tarantola</span>
<span class="sd">    and Valette formula. In general, you can keep the default parameter</span>
<span class="sd">    values, except for n_resamplings which depends on the time you can</span>
<span class="sd">    afford spending.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    principal_directions: (3, 3) numpy.ndarray, float</span>
<span class="sd">        The three eigenvectors of the reference stress tensor, stored in</span>
<span class="sd">        a matrix as column vectors and ordered from</span>
<span class="sd">        most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        The direction of sigma_i is given by: `principal_directions[:, i]`.</span>
<span class="sd">    R: float</span>
<span class="sd">        Shape ratio of the reference stress tensor.</span>
<span class="sd">    friction_coefficient: float</span>
<span class="sd">        Value of the friction coefficient used in the instability parameter.</span>
<span class="sd">        This can be the value output by `inversion_one_set_instability`.</span>
<span class="sd">    strikes: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    n_stress_iter: integer, default to 10</span>
<span class="sd">        Maximum number of iterations to seek for the best fault planes.</span>
<span class="sd">        See Beauce et al. 2022 for explanations.</span>
<span class="sd">    stress_tensor_update_atol: float, default to 1.e-4</span>
<span class="sd">        If the RMS difference of the stress tensors between two</span>
<span class="sd">        iterations fall below this threshold, convergence has been reached.</span>
<span class="sd">    shear_update_atol: float, default to 1e-5</span>
<span class="sd">        Convergence criterion on the shear stress magnitude updates.</span>
<span class="sd">        Convergence is reached when the RMS difference between two</span>
<span class="sd">        estimates of shear stress magnitudes falls below that threshold.</span>
<span class="sd">    signed_instability: boolean, default to False</span>
<span class="sd">        If True, the instability parameter ranges from -1 to +1. Negative</span>
<span class="sd">        values mean that the predicted and observed slip have opposite</span>
<span class="sd">        directions. If False, the instability parameter is the one</span>
<span class="sd">        defined in Vavrycuk 2013, 2014.</span>
<span class="sd">    max_n_iterations: integer, default to 300</span>
<span class="sd">        The maximum number of iterations if shear stress magnitude update</span>
<span class="sd">        does not fall below `shear_update_atol`.</span>
<span class="sd">    variable_shear: boolean, default to True</span>
<span class="sd">        If True, use the iterative linear method described in</span>
<span class="sd">        Beauce et al. 2022, else use the classic linear method</span>
<span class="sd">        due to Michael 1984.</span>
<span class="sd">    Tarantola_kwargs: Dictionary, default to {}</span>
<span class="sd">        If not None, should contain key word arguments</span>
<span class="sd">        for the Tarantola and Valette inversion. An empty dictionary</span>
<span class="sd">        uses the default values in `Tarantola_Valette`. If None, uses</span>
<span class="sd">        the Moore-Penrose inverse.</span>
<span class="sd">    weighted: boolean, default to False</span>
<span class="sd">        This option is exploratory. If True,</span>
<span class="sd">            1) More weight is given to the fault planes that are clearly</span>
<span class="sd">               more unstable than their auxiliary counterpart in the</span>
<span class="sd">               stress field estimated at iteration t-1</span>
<span class="sd">            2) Randomly mixes the set of fault planes at iterations</span>
<span class="sd">               t-1 and t, giving larger probability to the planes</span>
<span class="sd">               belonging to the set that produced the larger instability.</span>
<span class="sd">        This option can be interesting for reaching convergence on</span>
<span class="sd">        data sets of bad quality.</span>
<span class="sd">    n_threads: scalar int, optional</span>
<span class="sd">        Default to `n_threads=1`. If different from 1, the task is parallelized</span>
<span class="sd">        across `n_threads` threads. If `n_threads` is `0`, `None` or `&quot;all&quot;`,</span>
<span class="sd">        use all available CPUs.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: dict {str: numpy.ndarray}</span>
<span class="sd">        - output[&quot;boot_stress_tensor&quot;]: (n_resamplings, 3, 3) numpy.ndarray</span>
<span class="sd">            The inverted stress tensor in the (north, west, up)</span>
<span class="sd">            coordinate system.</span>
<span class="sd">        - output[&quot;boot_principal_stresses&quot;]: (n_resamplings, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvalues of the stress tensor, ordered from</span>
<span class="sd">            most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        - output[&quot;boot_principal_directions&quot;]: (n_resamplings, 3, 3) numpy.ndarray</span>
<span class="sd">            The three eigenvectors of the stress tensor, stored in a matrix</span>
<span class="sd">            as column vectors and ordered from most compressive (sigma1)</span>
<span class="sd">            to least compressive (sigma3). The direction of sigma_i for</span>
<span class="sd">            the b-th bootstrap replica is given by:</span>
<span class="sd">            `boot_principal_directions[b, :, i]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute auxiliary planes</span>
    <span class="n">strikes_1</span><span class="p">,</span> <span class="n">dips_1</span><span class="p">,</span> <span class="n">rakes_1</span> <span class="o">=</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span>
    <span class="n">strikes_2</span><span class="p">,</span> <span class="n">dips_2</span><span class="p">,</span> <span class="n">rakes_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">utils_stress</span><span class="o">.</span><span class="n">aux_plane</span><span class="p">,</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span><span class="p">))</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># build reduced stress tensor from principal directions and shape ratio</span>
    <span class="n">stress_tensor_main</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">reduced_stress_tensor</span><span class="p">(</span><span class="n">principal_directions</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="n">sigma_main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">stress_tensor_main</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Tarantola_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Tarantola_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;m_prior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_main</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># define shape variables</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strikes_1</span><span class="p">)</span>
    <span class="c1"># initialize the average stress tensor arrays</span>
    <span class="n">boot_stress_tensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">boot_principal_stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">boot_principal_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resamplings</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">_bootstrap_solution_p</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">_bootstrap_solution</span><span class="p">,</span>
        <span class="n">strikes_1</span><span class="o">=</span><span class="n">strikes_1</span><span class="p">,</span>
        <span class="n">dips_1</span><span class="o">=</span><span class="n">dips_1</span><span class="p">,</span>
        <span class="n">rakes_1</span><span class="o">=</span><span class="n">rakes_1</span><span class="p">,</span>
        <span class="n">strikes_2</span><span class="o">=</span><span class="n">strikes_2</span><span class="p">,</span>
        <span class="n">dips_2</span><span class="o">=</span><span class="n">dips_2</span><span class="p">,</span>
        <span class="n">rakes_2</span><span class="o">=</span><span class="n">rakes_2</span><span class="p">,</span>
        <span class="n">stress_tensor_main</span><span class="o">=</span><span class="n">stress_tensor_main</span><span class="p">,</span>
        <span class="n">friction_coefficient</span><span class="o">=</span><span class="n">friction_coefficient</span><span class="p">,</span>
        <span class="n">stress_tensor_update_atol</span><span class="o">=</span><span class="n">stress_tensor_update_atol</span><span class="p">,</span>
        <span class="n">n_stress_iter</span><span class="o">=</span><span class="n">n_stress_iter</span><span class="p">,</span>
        <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
        <span class="n">variable_shear</span><span class="o">=</span><span class="n">variable_shear</span><span class="p">,</span>
        <span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">,</span>
        <span class="n">max_n_iterations</span><span class="o">=</span><span class="n">max_n_iterations</span><span class="p">,</span>
        <span class="n">shear_update_atol</span><span class="o">=</span><span class="n">shear_update_atol</span><span class="p">,</span>
        <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;parallel is deprecated. Use n_threads instead.&quot;</span><span class="p">)</span>
        <span class="n">n_threads</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
    <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">concurrent.futures</span>
        <span class="k">if</span> <span class="n">n_threads</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
            <span class="c1"># n_threads = None means use all CPUs</span>
            <span class="n">n_threads</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_bootstrap_solution_p</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">)))</span>
        <span class="n">boot_stress_tensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">results</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">)])</span>
        <span class="n">boot_principal_stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">boot_principal_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">)]</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_resamplings</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---------- Bootstrapping </span><span class="si">{</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n_resamplings</span><span class="si">}</span><span class="s2"> ----------&quot;</span><span class="p">)</span>
            <span class="p">(</span>
                <span class="n">boot_stress_tensors</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                <span class="n">boot_principal_stresses</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                <span class="n">boot_principal_directions</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">_bootstrap_solution_p</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;boot_stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boot_stress_tensors</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;boot_principal_stresses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boot_principal_stresses</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;boot_principal_directions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boot_principal_directions</span>
    <span class="k">return</span> <span class="n">output</span></div>


<span class="k">def</span> <span class="nf">_bootstrap_solution</span><span class="p">(</span>
    <span class="n">_</span><span class="p">,</span>
    <span class="n">strikes_1</span><span class="p">,</span>
    <span class="n">dips_1</span><span class="p">,</span>
    <span class="n">rakes_1</span><span class="p">,</span>
    <span class="n">strikes_2</span><span class="p">,</span>
    <span class="n">dips_2</span><span class="p">,</span>
    <span class="n">rakes_2</span><span class="p">,</span>
    <span class="n">stress_tensor_main</span><span class="p">,</span>
    <span class="n">friction_coefficient</span><span class="p">,</span>
    <span class="n">stress_tensor_update_atol</span><span class="p">,</span>
    <span class="n">n_stress_iter</span><span class="p">,</span>
    <span class="n">Tarantola_kwargs</span><span class="p">,</span>
    <span class="n">variable_shear</span><span class="p">,</span>
    <span class="n">weighted</span><span class="p">,</span>
    <span class="n">max_n_iterations</span><span class="p">,</span>
    <span class="n">shear_update_atol</span><span class="p">,</span>
    <span class="n">n_jackknife</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_earthquakes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">signed_instability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used to parallelize resampling.</span>

<span class="sd">    Should not be used directly. If `n_jackknife` is provided, this function</span>
<span class="sd">    assumes that strikes, dips, and rakes are given in the &quot;jackknife&quot; format,</span>
<span class="sd">    where blocks of `n_jackknifes` contiguous samples are for `n_jackknifes`</span>
<span class="sd">    possible solutions of the *same* focal mechanism. Resampling is then</span>
<span class="sd">    performed only among the jackknife solutions, and each earthquake still</span>
<span class="sd">    appears one time, as in the original data set. Therefore, this resampling</span>
<span class="sd">    method only propagates the uncertainties in the focal mechanisms, and not</span>
<span class="sd">    the uncertainties related to spatial sampling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n_jackknife</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_earthquakes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bootstrap_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strikes_1</span><span class="p">)),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">strikes_1</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">n_earthquakes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># default jackknife mode:</span>
        <span class="c1"># strikes_1/dips_1/etc... come with contiguous blocks</span>
        <span class="c1"># of n_jackknife focal mechanisms that are different</span>
        <span class="c1"># possible solutions of the same earthquake, and we</span>
        <span class="c1"># only sample from these without sampling with replacement</span>
        <span class="c1"># among earthquakes</span>
        <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strikes_1</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_jackknife</span>
        <span class="n">bootstrap_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_jackknife</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">n_jackknife</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># n_earthquakes is specified, bootstrap on jackknife solutions</span>
        <span class="c1"># AND on events</span>
        <span class="n">bootstrap_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">n_jackknife</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jackknife</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_earthquakes</span><span class="p">)</span>
    <span class="n">strikes_1_b</span><span class="p">,</span> <span class="n">dips_1_b</span><span class="p">,</span> <span class="n">rakes_1_b</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">strikes_1</span><span class="p">[</span><span class="n">bootstrap_set</span><span class="p">],</span>
        <span class="n">dips_1</span><span class="p">[</span><span class="n">bootstrap_set</span><span class="p">],</span>
        <span class="n">rakes_1</span><span class="p">[</span><span class="n">bootstrap_set</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">strikes_2_b</span><span class="p">,</span> <span class="n">dips_2_b</span><span class="p">,</span> <span class="n">rakes_2_b</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">strikes_2</span><span class="p">[</span><span class="n">bootstrap_set</span><span class="p">],</span>
        <span class="n">dips_2</span><span class="p">[</span><span class="n">bootstrap_set</span><span class="p">],</span>
        <span class="n">rakes_2</span><span class="p">[</span><span class="n">bootstrap_set</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">output_</span> <span class="o">=</span> <span class="n">_stress_inversion_instability</span><span class="p">(</span>
        <span class="n">stress_tensor_main</span><span class="p">,</span>
        <span class="n">friction_coefficient</span><span class="p">,</span>
        <span class="n">strikes_1_b</span><span class="p">,</span>
        <span class="n">dips_1_b</span><span class="p">,</span>
        <span class="n">rakes_1_b</span><span class="p">,</span>
        <span class="n">strikes_2_b</span><span class="p">,</span>
        <span class="n">dips_2_b</span><span class="p">,</span>
        <span class="n">rakes_2_b</span><span class="p">,</span>
        <span class="n">n_stress_iter</span><span class="o">=</span><span class="n">n_stress_iter</span><span class="p">,</span>
        <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
        <span class="n">variable_shear</span><span class="o">=</span><span class="n">variable_shear</span><span class="p">,</span>
        <span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">,</span>
        <span class="n">max_n_iterations</span><span class="o">=</span><span class="n">max_n_iterations</span><span class="p">,</span>
        <span class="n">shear_update_atol</span><span class="o">=</span><span class="n">shear_update_atol</span><span class="p">,</span>
        <span class="n">stress_tensor_update_atol</span><span class="o">=</span><span class="n">stress_tensor_update_atol</span><span class="p">,</span>
        <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">],)</span> <span class="o">+</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span>
        <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_stress_inversion_instability</span><span class="p">(</span>
    <span class="n">stress_tensor0</span><span class="p">,</span>
    <span class="n">friction_coefficient</span><span class="p">,</span>
    <span class="n">strikes_1</span><span class="p">,</span>
    <span class="n">dips_1</span><span class="p">,</span>
    <span class="n">rakes_1</span><span class="p">,</span>
    <span class="n">strikes_2</span><span class="p">,</span>
    <span class="n">dips_2</span><span class="p">,</span>
    <span class="n">rakes_2</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core wrapper function to run the iterative linear stress inversion</span>
<span class="sd">    whether shear stress is assumed to be constant (i.e. equivalent to</span>
<span class="sd">    the method described in Vavrycuk 2013, 2014) or not (the method described</span>
<span class="sd">    in Beauce et al. 2022). This function should be not called directly by</span>
<span class="sd">    the user.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Tarantola_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Tarantola_kwargs&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">n_stress_iter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_stress_iter&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">weighted</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;weighted&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">variable_shear</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variable_shear&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">max_n_iterations</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_n_iterations&quot;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">shear_update_atol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;shear_update_atol&quot;</span><span class="p">,</span> <span class="mf">1.0e-7</span><span class="p">)</span>
    <span class="n">signed_instability</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;signed_instability&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">stress_tensor_update_atol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stress_tensor_update_atol&quot;</span><span class="p">,</span> <span class="mf">1.0e-4</span><span class="p">)</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">criterion_on_noconvergence</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;criterion_on_noconvergence&quot;</span><span class="p">,</span> <span class="s2">&quot;residuals&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Tarantola_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Tarantola_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># make copy to not overwrite the input dictionary</span>
        <span class="n">Tarantola_kwargs</span> <span class="o">=</span> <span class="n">Tarantola_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># ------------------------------</span>
    <span class="c1">#   Start instability criterion</span>
    <span class="c1"># ------------------------------</span>
    <span class="c1"># initialize variables</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strikes_1</span><span class="p">)</span>
    <span class="n">stress_tensor</span> <span class="o">=</span> <span class="n">stress_tensor0</span>
    <span class="n">stress_diff</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">total_instability</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">total_differential_instability</span> <span class="o">=</span> <span class="o">-</span><span class="mf">100.0</span>
    <span class="n">instability</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">residuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">best_residuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">fault_strikes</span><span class="p">,</span> <span class="n">fault_dips</span><span class="p">,</span> <span class="n">fault_rakes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
    <span class="c1"># C_m_post = np.zeros((5, 5), dtype=np.float32)</span>
    <span class="c1"># C_d_post = np.zeros((3 * n_earthquakes, 3 * n_earthquakes), dtype=np.float32)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># start the nodal plane selection loop</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_stress_iter</span><span class="p">):</span>
        <span class="c1"># get stress state of previous iteration to determine the</span>
        <span class="c1"># set of fault planes that maximize instability</span>
        <span class="p">(</span>
            <span class="n">principal_stresses</span><span class="p">,</span>
            <span class="n">principal_directions</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span><span class="n">stress_tensor0</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">R_</span><span class="p">(</span><span class="n">principal_stresses</span><span class="p">)</span>
        <span class="c1"># ------------</span>
        <span class="c1"># copy variables from previous iteration</span>
        <span class="n">stress_tensor0</span> <span class="o">=</span> <span class="n">stress_tensor</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">total_instability0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_instability</span><span class="p">)</span>
        <span class="n">total_differential_instability0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_differential_instability</span><span class="p">)</span>
        <span class="n">instability0</span> <span class="o">=</span> <span class="n">instability</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stress_diff0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">stress_diff</span><span class="p">)</span>
        <span class="n">residuals0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
        <span class="n">fault_strikes0</span><span class="p">,</span> <span class="n">fault_dips0</span><span class="p">,</span> <span class="n">fault_rakes0</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">fault_strikes</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">fault_dips</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">fault_rakes</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="c1"># -----------</span>
        <span class="p">(</span>
            <span class="n">instability</span><span class="p">,</span>
            <span class="n">fault_strikes</span><span class="p">,</span>
            <span class="n">fault_dips</span><span class="p">,</span>
            <span class="n">fault_rakes</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">compute_instability_parameter</span><span class="p">(</span>
            <span class="n">principal_directions</span><span class="p">,</span>
            <span class="n">R</span><span class="p">,</span>
            <span class="n">friction_coefficient</span><span class="p">,</span>
            <span class="n">strikes_1</span><span class="p">,</span>
            <span class="n">dips_1</span><span class="p">,</span>
            <span class="n">rakes_1</span><span class="p">,</span>
            <span class="n">strikes_2</span><span class="p">,</span>
            <span class="n">dips_2</span><span class="p">,</span>
            <span class="n">rakes_2</span><span class="p">,</span>
            <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
            <span class="n">return_fault_planes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">total_instability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">instability</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
            <span class="c1"># ----------------------------------</span>
            <span class="c1">#    This feature is experimental.</span>
            <span class="c1"># ----------------------------------</span>
            <span class="n">total_differential_instability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">instability</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">instability</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="c1"># decide to keep or not previous fault planes probabilisticly based</span>
            <span class="c1"># on the instability values</span>
            <span class="c1"># sigmoid probability:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">total_differential_instability0</span> <span class="o">/</span> <span class="n">total_differential_instability</span> <span class="o">-</span> <span class="mf">1.0</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">))</span>
            <span class="c1"># print(&#39;Probability: {:.3f} (before: {:.2f}, now: {:.2f})&#39;.format(p0, total_differential_instability0, total_differential_instability))</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span>
            <span class="n">fault_strikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">fault_strikes0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p0</span> <span class="k">else</span> <span class="n">fault_strikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">fault_dips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">fault_dips0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p0</span> <span class="k">else</span> <span class="n">fault_dips</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">fault_rakes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">fault_rakes0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p0</span> <span class="k">else</span> <span class="n">fault_rakes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">instability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">instability0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p0</span> <span class="k">else</span> <span class="n">instability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># give more weights to focal mechanisms where the most unstable</span>
            <span class="c1"># nodal plane is well defined, i.e. has an instability parameter</span>
            <span class="c1"># clearly larger than the other plane</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">instability</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">instability</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="c1"># normalize the weights such that 1/max(weights) = 0.1 (which is</span>
            <span class="c1"># the standard deviation I would give to a good slip measurement)</span>
            <span class="n">weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">weights</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># p = (weights / np.sum(weights))[::3]</span>
        <span class="k">if</span> <span class="s2">&quot;C_d&quot;</span> <span class="ow">in</span> <span class="n">Tarantola_kwargs</span><span class="p">:</span>
            <span class="c1"># update existing covariance matrix</span>
            <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;C_d&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;C_d&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;C_d&quot;</span> <span class="ow">in</span> <span class="n">Tarantola_kwargs</span> <span class="ow">and</span> <span class="n">weighted</span><span class="p">:</span>
            <span class="c1"># keep previous weights in memory</span>
            <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;C_d&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;C_d&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="n">weights</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;C_d&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;C_d_inv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;C_d&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">variable_shear</span><span class="p">:</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">iterative_linear_si</span><span class="p">(</span>
                <span class="n">fault_strikes</span><span class="p">,</span>
                <span class="n">fault_dips</span><span class="p">,</span>
                <span class="n">fault_rakes</span><span class="p">,</span>
                <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
                <span class="n">max_n_iterations</span><span class="o">=</span><span class="n">max_n_iterations</span><span class="p">,</span>
                <span class="n">shear_update_atol</span><span class="o">=</span><span class="n">shear_update_atol</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_</span> <span class="o">=</span> <span class="n">Michael1984_inversion</span><span class="p">(</span>
                <span class="n">fault_strikes</span><span class="p">,</span>
                <span class="n">fault_dips</span><span class="p">,</span>
                <span class="n">fault_rakes</span><span class="p">,</span>
                <span class="n">return_eigen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">Tarantola_kwargs</span><span class="o">=</span><span class="n">Tarantola_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">stress_tensor</span> <span class="o">=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span>
        <span class="n">stress_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">stress_tensor0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">criterion_on_noconvergence</span> <span class="o">==</span> <span class="s2">&quot;residuals&quot;</span><span class="p">:</span>
            <span class="c1"># ------------------------------------</span>
            <span class="c1"># Compute residuals in case the instability loop doesn&#39;t converge</span>
            <span class="c1"># ------------------------------------</span>
            <span class="c1"># normal and slip vectors</span>
            <span class="n">n_</span><span class="p">,</span> <span class="n">d_</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">normal_slip_vectors</span><span class="p">(</span>
                <span class="n">fault_strikes</span><span class="p">,</span> <span class="n">fault_dips</span><span class="p">,</span> <span class="n">fault_rakes</span>
            <span class="p">)</span>
            <span class="n">shear_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">output_</span><span class="p">[</span><span class="s2">&quot;predicted_shear_stress&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">variable_shear</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;predicted_shear_stress&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">shear_mag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_</span><span class="o">.</span><span class="n">T</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;predicted_shear_stress&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">shear_mag</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_</span><span class="o">.</span><span class="n">T</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">residuals</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Tarantola_kwargs</span><span class="p">[</span><span class="s2">&quot;C_d_inv&quot;</span><span class="p">]</span> <span class="o">@</span> <span class="n">res</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">residuals</span> <span class="o">&lt;</span> <span class="n">best_residuals</span><span class="p">:</span>
                <span class="c1"># One possibility: update prior model at this stage</span>
                <span class="c1"># Tarantola_kwargs[&quot;m_prior&quot;] = np.array(</span>
                <span class="c1">#    [</span>
                <span class="c1">#        stress_tensor[0, 0],</span>
                <span class="c1">#        stress_tensor[0, 1],</span>
                <span class="c1">#        stress_tensor[0, 2],</span>
                <span class="c1">#        stress_tensor[1, 1],</span>
                <span class="c1">#        stress_tensor[1, 2],</span>
                <span class="c1">#    ]</span>
                <span class="c1"># ).reshape(-1, 1)</span>
                <span class="c1"># store best results</span>
                <span class="n">best_residuals</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
                <span class="n">best_stress_tensor</span> <span class="o">=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">best_C_m_post</span> <span class="o">=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;C_m_posterior&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">best_C_d_post</span> <span class="o">=</span> <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;C_d_posterior&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;iteration_</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;stereonet&quot;</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;R=</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
            <span class="n">markers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">az</span><span class="p">,</span> <span class="n">pl</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">get_bearing_plunge</span><span class="p">(</span>
                    <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;principal_directions[:, k]&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">line</span><span class="p">(</span>
                    <span class="n">pl</span><span class="p">,</span>
                    <span class="n">az</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">markers</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                    <span class="n">markeredgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;stereonet&quot;</span><span class="p">)</span>
            <span class="n">cNorm</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">scalar_map</span> <span class="o">=</span> <span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;cividis&quot;</span><span class="p">)</span>
            <span class="c1"># ax2.plane(fault_strikes, fault_dips, color=scalar_map.to_rgba(p), lw=2.0)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fault_strikes</span><span class="p">)):</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">plane</span><span class="p">(</span>
                    <span class="n">fault_strikes</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">fault_dips</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">scalar_map</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span>
                    <span class="n">lw</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">axes_class</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalar_map</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Weight&quot;</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Stress tensor difference at iteration </span><span class="si">{:d}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">stress_diff</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># print(stress_tensor)</span>
            <span class="p">(</span>
                <span class="n">principal_stresses</span><span class="p">,</span>
                <span class="n">principal_directions</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span><span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">])</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">R_</span><span class="p">(</span><span class="n">principal_stresses</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;R=</span><span class="si">{:.2f}</span><span class="s2">, friction=</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">friction_coefficient</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Total instability: </span><span class="si">{:.2f}</span><span class="s2">/Total differential instability: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">total_instability</span><span class="p">,</span> <span class="n">total_differential_instability</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Average angle: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">utils_stress</span><span class="o">.</span><span class="n">mean_angular_residual</span><span class="p">(</span>
                        <span class="n">output_</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">],</span> <span class="n">fault_strikes</span><span class="p">,</span> <span class="n">fault_dips</span><span class="p">,</span> <span class="n">fault_rakes</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Squared residuals: </span><span class="si">{:.2e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">residuals</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">stress_diff</span> <span class="o">&lt;</span> <span class="n">stress_tensor_update_atol</span><span class="p">:</span>
            <span class="c1"># stop stress instability loop</span>
            <span class="k">break</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">stress_diff</span> <span class="o">&gt;=</span> <span class="n">stress_tensor_update_atol</span><span class="p">:</span>
        <span class="c1"># did not convergence, get results from best stress tensor</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_stress_tensor</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_m_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_C_m_post</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;C_d_posterior&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_C_d_post</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">principal_stresses</span><span class="p">,</span>
                <span class="n">principal_directions</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">stress_tensor_eigendecomposition</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;stress_tensor&quot;</span><span class="p">])</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">R_</span><span class="p">(</span><span class="n">principal_stresses</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Did not converge, return best (R=</span><span class="si">{:.2f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># output is the result of the last iteration</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">output_</span>
    <span class="k">return</span> <span class="n">output</span>


<span class="c1"># ---------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#          Routines for instability criterion</span>
<span class="c1">#</span>
<span class="c1"># ---------------------------------------------------</span>


<div class="viewcode-block" id="find_optimal_friction"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.find_optimal_friction">[docs]</a><span class="k">def</span> <span class="nf">find_optimal_friction</span><span class="p">(</span>
    <span class="n">strikes_1</span><span class="p">,</span>
    <span class="n">dips_1</span><span class="p">,</span>
    <span class="n">rakes_1</span><span class="p">,</span>
    <span class="n">strikes_2</span><span class="p">,</span>
    <span class="n">dips_2</span><span class="p">,</span>
    <span class="n">rakes_2</span><span class="p">,</span>
    <span class="n">principal_directions</span><span class="p">,</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">friction_min</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">friction_max</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
    <span class="n">friction_step</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
    <span class="n">signed_instability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the friction that maximizes the instability parameter I</span>
<span class="sd">    based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    strikes_1: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips_1: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes_1: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    strikes_2: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 2, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips_2: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 2, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes_2: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 2, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    principal_directions: (3, 3) numpy.ndarray, float</span>
<span class="sd">        The three eigenvectors of the reference stress tensor, stored in</span>
<span class="sd">        a matrix as column vectors and ordered from</span>
<span class="sd">        most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        The direction of sigma_i is given by: `principal_directions[:, i]`.</span>
<span class="sd">    R: float</span>
<span class="sd">        Shape ratio of the reference stress tensor.</span>
<span class="sd">    friction_min: float, default to 0.1</span>
<span class="sd">        Lower bound of explored friction values.</span>
<span class="sd">    friction_max: float, default to 0.8</span>
<span class="sd">        Upper bound of explored friction values.</span>
<span class="sd">    friction_step: float, default to 0.05</span>
<span class="sd">        Step employed in the grid search of the friction value</span>
<span class="sd">        that maximizes the instability parameter.</span>
<span class="sd">    signed_instability: boolean, default to False</span>
<span class="sd">        If True, the instability parameter ranges from -1 to +1. Negative</span>
<span class="sd">        values mean that the predicted and observed slip have opposite</span>
<span class="sd">        directions. If False, the instability parameter is the one</span>
<span class="sd">        defined in Vavrycuk 2013, 2014.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    optimal_friction: float</span>
<span class="sd">        The friction value that maximizes the mean instability parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">friction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">friction_min</span><span class="p">,</span> <span class="n">friction_max</span> <span class="o">+</span> <span class="n">friction_step</span><span class="p">,</span> <span class="n">friction_step</span><span class="p">)</span>
    <span class="n">n_fric</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">friction</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_fric</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fric</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">friction</span><span class="p">):</span>
        <span class="n">I_</span> <span class="o">=</span> <span class="n">compute_instability_parameter</span><span class="p">(</span>
            <span class="n">principal_directions</span><span class="p">,</span>
            <span class="n">R</span><span class="p">,</span>
            <span class="n">fric</span><span class="p">,</span>
            <span class="n">strikes_1</span><span class="p">,</span>
            <span class="n">dips_1</span><span class="p">,</span>
            <span class="n">rakes_1</span><span class="p">,</span>
            <span class="n">strikes_2</span><span class="p">,</span>
            <span class="n">dips_2</span><span class="p">,</span>
            <span class="n">rakes_2</span><span class="p">,</span>
            <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">I_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">optimal_friction</span> <span class="o">=</span> <span class="n">friction</span><span class="p">[</span><span class="n">I</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">optimal_friction</span></div>


<div class="viewcode-block" id="find_optimal_friction_one_set"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.find_optimal_friction_one_set">[docs]</a><span class="k">def</span> <span class="nf">find_optimal_friction_one_set</span><span class="p">(</span>
    <span class="n">strikes_1</span><span class="p">,</span>
    <span class="n">dips_1</span><span class="p">,</span>
    <span class="n">rakes_1</span><span class="p">,</span>
    <span class="n">principal_directions</span><span class="p">,</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">friction_min</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">friction_max</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
    <span class="n">friction_step</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
    <span class="n">signed_instability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the friction that maximizes the instability parameter I</span>
<span class="sd">    based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    strikes_1: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips_1: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes_1: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    principal_directions: (3, 3) numpy.ndarray, float</span>
<span class="sd">        The three eigenvectors of the reference stress tensor, stored in</span>
<span class="sd">        a matrix as column vectors and ordered from</span>
<span class="sd">        most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        The direction of sigma_i is given by: `principal_directions[:, i]`.</span>
<span class="sd">    R: float</span>
<span class="sd">        Shape ratio of the reference stress tensor.</span>
<span class="sd">    friction_min: float, default to 0.1</span>
<span class="sd">        Lower bound of explored friction values.</span>
<span class="sd">    friction_max: float, default to 0.8</span>
<span class="sd">        Upper bound of explored friction values.</span>
<span class="sd">    friction_step: float, default to 0.05</span>
<span class="sd">        Step employed in the grid search of the friction value</span>
<span class="sd">        that maximizes the instability parameter.</span>
<span class="sd">    signed_instability: boolean, default to False</span>
<span class="sd">        If True, the instability parameter ranges from -1 to +1. Negative</span>
<span class="sd">        values mean that the predicted and observed slip have opposite</span>
<span class="sd">        directions. If False, the instability parameter is the one</span>
<span class="sd">        defined in Vavrycuk 2013, 2014.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    optimal_friction: float</span>
<span class="sd">        The friction value that maximizes the mean instability parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># fake nodal planes #2</span>
    <span class="n">strikes_2</span><span class="p">,</span> <span class="n">dips_2</span><span class="p">,</span> <span class="n">rakes_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strikes_1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
    <span class="n">friction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">friction_min</span><span class="p">,</span> <span class="n">friction_max</span> <span class="o">+</span> <span class="n">friction_step</span><span class="p">,</span> <span class="n">friction_step</span><span class="p">)</span>
    <span class="n">n_fric</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">friction</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_fric</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fric</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">friction</span><span class="p">):</span>
        <span class="n">I_</span> <span class="o">=</span> <span class="n">compute_instability_parameter</span><span class="p">(</span>
            <span class="n">principal_directions</span><span class="p">,</span>
            <span class="n">R</span><span class="p">,</span>
            <span class="n">fric</span><span class="p">,</span>
            <span class="n">strikes_1</span><span class="p">,</span>
            <span class="n">dips_1</span><span class="p">,</span>
            <span class="n">rakes_1</span><span class="p">,</span>
            <span class="n">strikes_2</span><span class="p">,</span>
            <span class="n">dips_2</span><span class="p">,</span>
            <span class="n">rakes_2</span><span class="p">,</span>
            <span class="n">signed_instability</span><span class="o">=</span><span class="n">signed_instability</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># only look at instability on nodal planes #1</span>
        <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">I_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">optimal_friction</span> <span class="o">=</span> <span class="n">friction</span><span class="p">[</span><span class="n">I</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">optimal_friction</span></div>


<div class="viewcode-block" id="compute_instability_parameter"><a class="viewcode-back" href="../../api_automodule.html#ILSI.ilsi.compute_instability_parameter">[docs]</a><span class="k">def</span> <span class="nf">compute_instability_parameter</span><span class="p">(</span>
    <span class="n">principal_directions</span><span class="p">,</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">friction</span><span class="p">,</span>
    <span class="n">strike_1</span><span class="p">,</span>
    <span class="n">dip_1</span><span class="p">,</span>
    <span class="n">rake_1</span><span class="p">,</span>
    <span class="n">strike_2</span><span class="p">,</span>
    <span class="n">dip_2</span><span class="p">,</span>
    <span class="n">rake_2</span><span class="p">,</span>
    <span class="n">return_fault_planes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">signed_instability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the instability parameter as introduced by Lund and Slunga 1999,</span>
<span class="sd">    re-used by Vavrycuk 2013-2014 and modified by Beauce 2022.</span>
<span class="sd">    For a given stress field characterized by the principal stress</span>
<span class="sd">    directions and shape ratio R=(sig1-sig2)/(sig1-sig3), and for</span>
<span class="sd">    a given rock friction, this routine computes an instability</span>
<span class="sd">    parameter based on the Mohr-Coulomb failure criterion to determine</span>
<span class="sd">    which of the two nodal planes of a focal mechanism solution</span>
<span class="sd">    is more likely to be the fault plane.</span>
<span class="sd">    Beauce 2022 includes the sign of the dot product between</span>
<span class="sd">    the shear stress and the slip vector on the fault. This instability</span>
<span class="sd">    ranges from -1 to +1, instead of from 0 to +1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    principal_directions: (3, 3) numpy.ndarray, float</span>
<span class="sd">        The three eigenvectors of the reference stress tensor, stored in</span>
<span class="sd">        a matrix as column vectors and ordered from</span>
<span class="sd">        most compressive (sigma1) to least compressive (sigma3).</span>
<span class="sd">        The direction of sigma_i is given by: principal_directions[:, i]</span>
<span class="sd">    R: float</span>
<span class="sd">        Shape ratio of the reference stress tensor.</span>
<span class="sd">    strikes_1: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 1, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips_1: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 1, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes_1: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 1, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    strikes_2: list or numpy.ndarray, float</span>
<span class="sd">        The strike of nodal planes 2, angle between north and</span>
<span class="sd">        the fault&#39;s horizontal (0-360).</span>
<span class="sd">    dips_2: list or numpy.ndarray, float</span>
<span class="sd">        The dip of nodal planes 2, angle between the horizontal</span>
<span class="sd">        plane and the fault plane (0-90).</span>
<span class="sd">    rakes_2: list or numpy.ndarray, float</span>
<span class="sd">        The rake of nodal planes 2, angle between the fault&#39;s horizontal</span>
<span class="sd">        and the slip direction of the hanging wall w.r.t. the</span>
<span class="sd">        foot wall (0-360 or -180-180).</span>
<span class="sd">    return_fault_planes: boolean, default to False</span>
<span class="sd">        If True, return the strikes, dips, rakes of the selected</span>
<span class="sd">        fault planes.</span>
<span class="sd">    signed_instability: boolean, default to False</span>
<span class="sd">        If True, the instability parameter ranges from -1 to +1. Negative</span>
<span class="sd">        values mean that the predicted and observed slip have opposite</span>
<span class="sd">        directions. If False, the instability parameter is the one</span>
<span class="sd">        defined in Vavrycuk 2013, 2014.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    instability_parameter: (n_earthquakes, 2) numpy.ndarray</span>
<span class="sd">        The instability parameter as defined in Beauce 2022 for the two</span>
<span class="sd">        nodal planes of each focal mechanism datum.</span>
<span class="sd">    strikes: list or numpy.ndarray, float, optional</span>
<span class="sd">        Strikes of the fault planes with largest instability.</span>
<span class="sd">        Only provided if `return_fault_planes=True`.</span>
<span class="sd">    dips: list or numpy.ndarray, float, optional</span>
<span class="sd">        Dips of the fault planes with largest instability.</span>
<span class="sd">        Only provided if `return_fault_planes=True`.</span>
<span class="sd">    rakes: list or numpy.ndarray, float, optional</span>
<span class="sd">        Rakes of the fault planes with largest instability.</span>
<span class="sd">        Only provided if `return_fault_planes=True`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the calculation is done in the eigenbasis, therefore</span>
    <span class="c1"># we need to project the normal vectors onto the eigenbasis</span>
    <span class="n">n_earthquakes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strike_1</span><span class="p">)</span>
    <span class="n">n_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">n_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">d_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">d_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># compute the normals of the two nodal planes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">):</span>
        <span class="n">n_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">normal_slip_vectors</span><span class="p">(</span>
            <span class="n">strike_1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dip_1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rake_1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;inward&quot;</span>
        <span class="p">)</span>
        <span class="n">n_2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d_2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">utils_stress</span><span class="o">.</span><span class="n">normal_slip_vectors</span><span class="p">(</span>
            <span class="n">strike_2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dip_2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rake_2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;inward&quot;</span>
        <span class="p">)</span>
    <span class="c1"># project the normals onto the eigenbasis</span>
    <span class="n">n_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n_1</span><span class="p">,</span> <span class="n">principal_directions</span><span class="p">)</span>
    <span class="n">n_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n_2</span><span class="p">,</span> <span class="n">principal_directions</span><span class="p">)</span>
    <span class="n">d_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d_1</span><span class="p">,</span> <span class="n">principal_directions</span><span class="p">)</span>
    <span class="n">d_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d_2</span><span class="p">,</span> <span class="n">principal_directions</span><span class="p">)</span>
    <span class="c1"># when parameterazing the reduced stress tensor as:</span>
    <span class="c1"># sigma_1 = -1, sigma_2 = 2R-1 and sigma_3 = +1,</span>
    <span class="c1"># (CONVENTION: TENSION IS POSITIVE)</span>
    <span class="c1"># the critical shear and normal stresses are:</span>
    <span class="n">sig1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">sig2</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">R</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="n">sig3</span> <span class="o">=</span> <span class="o">+</span><span class="mf">1.0</span>
    <span class="n">tau_c</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">friction</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">sig_c</span> <span class="o">=</span> <span class="n">friction</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">friction</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># print(sig1, sig2, sig3, tau_c, sig_c)</span>
    <span class="c1"># and the shear and normal stresses on each fault are:</span>
    <span class="n">normal_1</span> <span class="o">=</span> <span class="n">sig1</span> <span class="o">*</span> <span class="n">n_1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sig2</span> <span class="o">*</span> <span class="n">n_1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sig3</span> <span class="o">*</span> <span class="n">n_1</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">shear_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">sig1</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">+</span> <span class="n">sig2</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">+</span> <span class="n">sig3</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_1</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">-</span> <span class="n">normal_1</span><span class="o">**</span><span class="mi">2</span>
    <span class="p">)</span>

    <span class="n">normal_2</span> <span class="o">=</span> <span class="n">sig1</span> <span class="o">*</span> <span class="n">n_2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sig2</span> <span class="o">*</span> <span class="n">n_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sig3</span> <span class="o">*</span> <span class="n">n_2</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">shear_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">sig1</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">+</span> <span class="n">sig2</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">+</span> <span class="n">sig3</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_2</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">-</span> <span class="n">normal_2</span><span class="o">**</span><span class="mi">2</span>
    <span class="p">)</span>
    <span class="c1"># combine all of them in the definition of the instability parameter I</span>
    <span class="n">Ic</span> <span class="o">=</span> <span class="n">tau_c</span> <span class="o">-</span> <span class="n">friction</span> <span class="o">*</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">sig_c</span><span class="p">)</span>
    <span class="n">I_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">shear_1</span> <span class="o">-</span> <span class="n">friction</span> <span class="o">*</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">normal_1</span><span class="p">))</span> <span class="o">/</span> <span class="n">Ic</span>
    <span class="n">I_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">shear_2</span> <span class="o">-</span> <span class="n">friction</span> <span class="o">*</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">normal_2</span><span class="p">))</span> <span class="o">/</span> <span class="n">Ic</span>
    <span class="c1"># my addition: add the sign of the shear-slip dot product</span>
    <span class="c1"># stress_tensor = np.dot(principal_directions, np.dot(np.diag([sig1, sig2, sig3]), principal_directions.T))</span>
    <span class="n">stress_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">sig1</span><span class="p">,</span> <span class="n">sig2</span><span class="p">,</span> <span class="n">sig3</span><span class="p">])</span>
    <span class="n">traction_1_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stress_tensor</span><span class="p">,</span> <span class="n">n_1</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">traction_2_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stress_tensor</span><span class="p">,</span> <span class="n">n_2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">normal_1_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">traction_1_vec</span> <span class="o">*</span> <span class="n">n_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_1</span>
    <span class="n">normal_2_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">traction_2_vec</span> <span class="o">*</span> <span class="n">n_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_2</span>
    <span class="n">shear_1_vec</span> <span class="o">=</span> <span class="n">traction_1_vec</span> <span class="o">-</span> <span class="n">normal_1_vec</span>
    <span class="n">shear_2_vec</span> <span class="o">=</span> <span class="n">traction_2_vec</span> <span class="o">-</span> <span class="n">normal_2_vec</span>
    <span class="n">sign_dot_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">shear_1_vec</span> <span class="o">*</span> <span class="n">d_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">sign_dot_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">shear_2_vec</span> <span class="o">*</span> <span class="n">d_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># print(sign_dot_1)</span>
    <span class="k">if</span> <span class="n">signed_instability</span><span class="p">:</span>
        <span class="c1"># multiplying the instability parameter by the sign of the</span>
        <span class="c1"># dot product between shear direction and slip direction is</span>
        <span class="c1"># the difference with the instability parameter defined in Vavrycuk 2013</span>
        <span class="n">I_1</span> <span class="o">*=</span> <span class="n">sign_dot_1</span>
        <span class="n">I_2</span> <span class="o">*=</span> <span class="n">sign_dot_2</span>

    <span class="k">if</span> <span class="n">return_fault_planes</span><span class="p">:</span>
        <span class="n">strikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">dips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">rakes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_earthquakes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">mask_1</span> <span class="o">=</span> <span class="n">I_1</span> <span class="o">&gt;=</span> <span class="n">I_2</span>
        <span class="n">strikes</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">strike_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span>
        <span class="n">dips</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dip_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span>
        <span class="n">rakes</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rake_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span>
        <span class="n">mask_2</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask_1</span>
        <span class="n">strikes</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">strike_2</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span>
        <span class="n">dips</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dip_2</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span>
        <span class="n">rakes</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rake_2</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">)),</span> <span class="n">strikes</span><span class="p">,</span> <span class="n">dips</span><span class="p">,</span> <span class="n">rakes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">))</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Eric Beauc.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>