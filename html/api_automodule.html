<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API &mdash; ILSI 1.1.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> ILSI
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="updates.html">Updates</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ILSI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api_automodule.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="module-ILSI.ilsi">
<span id="api"></span><h1>API<a class="headerlink" href="#module-ILSI.ilsi" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.Michael1984_inversion">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">Michael1984_inversion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tarantola_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_eigen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#Michael1984_inversion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.Michael1984_inversion" title="Permalink to this definition"></a></dt>
<dd><p>Linear inversion described in Michael 1984.</p>
<dl class="simple">
<dt>This method assumes:</dt><dd><ul class="simple">
<li><p>The tectonic stress field is uniform.</p></li>
<li><p>Wallace-Bott hypothesis: The slip vector points in the same
direction as shear stress on the fault.</p></li>
<li><p>The resolved shear stress magnitude is constant on
all faults.</p></li>
</ul>
</dd>
</dl>
<p>The parameters we invert for are the directions of the three
principal stresses and the shape ratio. Because this inversion does not
aim at infering the absolute stress values, we only consider the
deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot
determine the norm of the stress tensor, therefore sum sigma**2 = 1.
Each iteration of this inversion scheme is a linear inversion.
N.B.: This routine is written assuming outward footwall normals and slip
vectors of the hanging wall w.r.t. the footwall. Therefore, the stress
tensor sign convention is compression negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strikes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>Tarantola_kwargs</strong> (<em>Dictionary</em><em>, </em><em>default to {}</em>) – If not None, should contain key word arguments
for the Tarantola and Valette inversion. An empty dictionary
uses the default values in <cite>Tarantola_Valette</cite>. If None, uses
the Moore-Penrose inverse.</p></li>
<li><p><strong>return_eigen</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, returns the eigendecomposition of the inverted
stress tensor in addition to returning the stress tensor.</p></li>
<li><p><strong>return_stats</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, the posterior data and model parameter distributions
estimated from the Tarantola and Valette formula
(cf. Tarantola_Valette routine).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>output</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>output[“stress_tensor”]: (3, 3) numpy.ndarray</dt><dd><p>The inverted stress tensor in the (north, west, up)
coordinate system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“principal_stresses”]: (3,) numpy.ndarray, optional</dt><dd><p>The three eigenvalues of the stress tensor, ordered from
most compressive (sigma1) to least compressive (sigma3).
Returned if <cite>return_eigen</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“predicted_shear_stress”]: (n_earthquakes, 3) numpy.ndarray</dt><dd><p>The shear tractions resolved on the fault planes described by <cite>strikes</cite>,
<cite>dips</cite> and <cite>rakes</cite> computed with the inverted stress tensor.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“principal_directions”]: (3, 3) numpy.ndarray, optional</dt><dd><p>The three eigenvectors of the stress tensor, stored in a matrix
as column vectors and ordered from most compressive (sigma1)
to least compressive (sigma3). The direction of sigma_i is
given by: <cite>principal_directions[:, i]</cite>.
Returned if <cite>return_eigen</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“C_m_posterior”]: (5, 5) numpy.ndarray, optional</dt><dd><p>Posterior covariance of the model parameter distribution
estimated from the Tarantola and Valette formula.
Returned if <cite>return_stats</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“C_d_posterior”]: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray, optional</dt><dd><p>Posterior covariance of the data distribution
estimated from the Tarantola and Valette formula.
Returned if <cite>return_stats</cite> is True.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict {str: numpy.ndarray}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.Tarantola_Valette">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">Tarantola_Valette</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C_d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C_d_inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C_m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C_m_inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_prior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inversion_space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'model_space'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#Tarantola_Valette"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.Tarantola_Valette" title="Permalink to this definition"></a></dt>
<dd><p>Returns Tarantola’s and Valette’s least square solution for
a given linear operator <cite>G</cite> and observation vector <cite>data</cite>. If the
covariance matrices of the observations and of the model
parameters are not known, we assume them to be identity. The
inversion can be performed either in the data space or in
the model space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>(</em><em>n</em><em>, </em><em>m</em><em>) </em><em>numpy.ndarray</em>) – The linear operator projecting elements of the model
space m onto the data space: d = G.m
n is the dimension of the data space,
m is the dimension of the model space.</p></li>
<li><p><strong>data</strong> (<em>(</em><em>3k</em><em>,</em><em>) or </em><em>(</em><em>3k</em><em>, </em><em>1</em><em>) or </em><em>(</em><em>k</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – Vector of observations. k is the number of focal mechanisms. <cite>data</cite>
is reshaped to (n=3k, 1) before the inversion.</p></li>
<li><p><strong>C_d</strong> (<em>(</em><em>n</em><em>, </em><em>n</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>default to None</em>) – Covariance matrix of the observations. It quantifies
the errors in the observations and propagates them
in the inversion to give more weight to the observations
with low errors. If None, then <cite>C_d</cite> is filled with zeros
(assume no error in data).</p></li>
<li><p><strong>C_m</strong> (<em>(</em><em>m</em><em>, </em><em>m</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>default to None</em>) – Covariance matrix of the model parameters. It quantifies
the errors in the model parameters and propagates them
in the inversion to determine the range of acceptable
model parameters for a given set of observations.
If None, then <cite>C_m</cite> is identity.</p></li>
<li><p><strong>m_prior</strong> (<em>(</em><em>m</em><em>,</em><em>) or </em><em>(</em><em>m</em><em>, </em><em>1</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>default to None</em>) – If one already has a rough estimate of what the model
parameters are, then m_prior should be filled with this estimate.
If None, <cite>m_prior</cite> is set to zero.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>m_inv</strong> (<em>(m, 1) numpy.ndarray</em>) – The inverted model parameters.</p></li>
<li><p><strong>C_m_posterior</strong> (<em>(5, 5) numpy.ndarray</em>) – Posterior covariance of the model parameter distribution.</p></li>
<li><p><strong>C_d_posterior</strong> (<em>(3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray</em>) – Posterior covariance of the data distribution.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.compute_instability_parameter">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">compute_instability_parameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">principal_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strike_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dip_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rake_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strike_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dip_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rake_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_fault_planes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed_instability</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#compute_instability_parameter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.compute_instability_parameter" title="Permalink to this definition"></a></dt>
<dd><p>Compute the instability parameter as introduced by Lund and Slunga 1999,
re-used by Vavrycuk 2013-2014 and modified by Beauce 2022.
For a given stress field characterized by the principal stress
directions and shape ratio R=(sig1-sig2)/(sig1-sig3), and for
a given rock friction, this routine computes an instability
parameter based on the Mohr-Coulomb failure criterion to determine
which of the two nodal planes of a focal mechanism solution
is more likely to be the fault plane.
Beauce 2022 includes the sign of the dot product between
the shear stress and the slip vector on the fault. This instability
ranges from -1 to +1, instead of from 0 to +1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>principal_directions</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: principal_directions[:, i]</p></li>
<li><p><strong>R</strong> (<em>float</em>) – Shape ratio of the reference stress tensor.</p></li>
<li><p><strong>strikes_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>strikes_2</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 2, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips_2</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 2, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes_2</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 2, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>return_fault_planes</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, return the strikes, dips, rakes of the selected
fault planes.</p></li>
<li><p><strong>signed_instability</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>instability_parameter</strong> (<em>(n_earthquakes, 2) numpy.ndarray</em>) – The instability parameter as defined in Beauce 2022 for the two
nodal planes of each focal mechanism datum.</p></li>
<li><p><strong>strikes</strong> (<em>list or numpy.ndarray, float, optional</em>) – Strikes of the fault planes with largest instability.
Only provided if <cite>return_fault_planes=True</cite>.</p></li>
<li><p><strong>dips</strong> (<em>list or numpy.ndarray, float, optional</em>) – Dips of the fault planes with largest instability.
Only provided if <cite>return_fault_planes=True</cite>.</p></li>
<li><p><strong>rakes</strong> (<em>list or numpy.ndarray, float, optional</em>) – Rakes of the fault planes with largest instability.
Only provided if <cite>return_fault_planes=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.find_optimal_friction">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">find_optimal_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strikes_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strikes_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">principal_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed_instability</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#find_optimal_friction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.find_optimal_friction" title="Permalink to this definition"></a></dt>
<dd><p>Find the friction that maximizes the instability parameter I
based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strikes_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>strikes_2</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 2, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips_2</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 2, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes_2</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 2, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>principal_directions</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <cite>principal_directions[:, i]</cite>.</p></li>
<li><p><strong>R</strong> (<em>float</em>) – Shape ratio of the reference stress tensor.</p></li>
<li><p><strong>friction_min</strong> (<em>float</em><em>, </em><em>default to 0.1</em>) – Lower bound of explored friction values.</p></li>
<li><p><strong>friction_max</strong> (<em>float</em><em>, </em><em>default to 0.8</em>) – Upper bound of explored friction values.</p></li>
<li><p><strong>friction_step</strong> (<em>float</em><em>, </em><em>default to 0.05</em>) – Step employed in the grid search of the friction value
that maximizes the instability parameter.</p></li>
<li><p><strong>signed_instability</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>optimal_friction</strong> – The friction value that maximizes the mean instability parameter.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.find_optimal_friction_one_set">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">find_optimal_friction_one_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strikes_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">principal_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed_instability</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#find_optimal_friction_one_set"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.find_optimal_friction_one_set" title="Permalink to this definition"></a></dt>
<dd><p>Find the friction that maximizes the instability parameter I
based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strikes_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes_1</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>principal_directions</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <cite>principal_directions[:, i]</cite>.</p></li>
<li><p><strong>R</strong> (<em>float</em>) – Shape ratio of the reference stress tensor.</p></li>
<li><p><strong>friction_min</strong> (<em>float</em><em>, </em><em>default to 0.1</em>) – Lower bound of explored friction values.</p></li>
<li><p><strong>friction_max</strong> (<em>float</em><em>, </em><em>default to 0.8</em>) – Upper bound of explored friction values.</p></li>
<li><p><strong>friction_step</strong> (<em>float</em><em>, </em><em>default to 0.05</em>) – Step employed in the grid search of the friction value
that maximizes the instability parameter.</p></li>
<li><p><strong>signed_instability</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>optimal_friction</strong> – The friction value that maximizes the mean instability parameter.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.forward_model">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">forward_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#forward_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.forward_model" title="Permalink to this definition"></a></dt>
<dd><p>Build the forward modeling matrix <code class="docutils literal notranslate"><span class="pre">G</span></code> given a collection
of fault normals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>(</em><em>n_earthquakes</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – The i-th row <a href="#id1"><span class="problematic" id="id2">n_</span></a> are the components of the i-th
fault normal in the (north, west, south) coordinate
system.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – The forward modeling matrix giving the slip (shear stress)
directions on the faults characterized by <cite>n_</cite>, given the 5
elements of the deviatoric stress tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3 x n_earthquakes, 5) numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.inversion_bootstrap">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">inversion_bootstrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_random_selections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_resamplings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tarantola_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#inversion_bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.inversion_bootstrap" title="Permalink to this definition"></a></dt>
<dd><p>Inverts one set of focal mechanisms without seeking which nodal planes
are more likely to be the fault planes. Performs bootstrap resampling
of the data set to return an ensemble of solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strikes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>n_random_selections</strong> (<em>integer</em><em>, </em><em>default to 5</em>) – Number of random selections of subsets of nodal planes on
which the stress inversion is run. The final stress tensor
is averaged over the n_random_selections solutions.</p></li>
<li><p><strong>n_resamplings</strong> (<em>integer</em><em>, </em><em>default to 100</em>) – Number of times the data set is resampled following
the bootstrapping method (sampling with replacement).
n_resamplings stress tensors are returned, allowing to
estimate uncertainties from the distribution of solutions.</p></li>
<li><p><strong>shear_update_atol</strong> (<em>float</em><em>, </em><em>default to 1e-5</em>) – Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</p></li>
<li><p><strong>max_n_iterations</strong> (<em>integer</em><em>, </em><em>default to 300</em>) – The maximum number of iterations if shear stress magnitude update
does not fall below <cite>shear_update_atol</cite>.</p></li>
<li><p><strong>variable_shear</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, use the iterative linear method described in
Beauce et al. 2022, else use the classic linear method
due to Michael 1984.</p></li>
<li><p><strong>Tarantola_kwargs</strong> (<em>Dictionary</em><em>, </em><em>default to {}</em>) – If not None, should contain key word arguments
for the Tarantola and Valette inversion. An empty dictionary
uses the default values in <cite>Tarantola_Valette</cite>. If None, uses
the Moore-Penrose inverse.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>output</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>output[“boot_stress_tensor”]: (n_resamplings, 3, 3) numpy.ndarray</dt><dd><p>The inverted stress tensor in the (north, west, up)
coordinate system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“boot_principal_stresses”]: (n_resamplings, 3) numpy.ndarray</dt><dd><p>The three eigenvalues of the stress tensor, ordered from
most compressive (sigma1) to least compressive (sigma3).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“boot_principal_directions”]: (n_resamplings, 3, 3) numpy.ndarray</dt><dd><p>The three eigenvectors of the stress tensor, stored in a matrix
as column vectors and ordered from most compressive (sigma1)
to least compressive (sigma3). The direction of sigma_i for
the b-th bootstrap replica is given by:
<cite>boot_principal_directions[b, :, i]</cite>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict {str: numpy.ndarray}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.inversion_bootstrap_instability">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">inversion_bootstrap_instability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">principal_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_coefficient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_resamplings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_stress_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stress_tensor_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tarantola_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed_instability</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#inversion_bootstrap_instability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.inversion_bootstrap_instability" title="Permalink to this definition"></a></dt>
<dd><p>Invert one set of focal mechanisms with the instability parameter
to seek which nodal planes are more likely to be the fault planes
(cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).
Performs bootstrap resampling of the data set to return an
ensemble of solutions.</p>
<p>Use a previously determined stress tensor (e.g. the output of
<cite>inversion_one_set_instability</cite>) described by its principal stress
directions and shape ratio as the prior model in the Tarantola
and Valette formula. In general, you can keep the default parameter
values, except for n_resamplings which depends on the time you can
afford spending.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>principal_directions</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <cite>principal_directions[:, i]</cite>.</p></li>
<li><p><strong>R</strong> (<em>float</em>) – Shape ratio of the reference stress tensor.</p></li>
<li><p><strong>friction_coefficient</strong> (<em>float</em>) – Value of the friction coefficient used in the instability parameter.
This can be the value output by <cite>inversion_one_set_instability</cite>.</p></li>
<li><p><strong>strikes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>n_stress_iter</strong> (<em>integer</em><em>, </em><em>default to 10</em>) – Maximum number of iterations to seek for the best fault planes.
See Beauce et al. 2022 for explanations.</p></li>
<li><p><strong>stress_tensor_update_atol</strong> (<em>float</em><em>, </em><em>default to 1.e-4</em>) – If the RMS difference of the stress tensors between two
iterations fall below this threshold, convergence has been reached.</p></li>
<li><p><strong>shear_update_atol</strong> (<em>float</em><em>, </em><em>default to 1e-5</em>) – Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</p></li>
<li><p><strong>signed_instability</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</p></li>
<li><p><strong>max_n_iterations</strong> (<em>integer</em><em>, </em><em>default to 300</em>) – The maximum number of iterations if shear stress magnitude update
does not fall below <cite>shear_update_atol</cite>.</p></li>
<li><p><strong>variable_shear</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, use the iterative linear method described in
Beauce et al. 2022, else use the classic linear method
due to Michael 1984.</p></li>
<li><p><strong>Tarantola_kwargs</strong> (<em>Dictionary</em><em>, </em><em>default to {}</em>) – If not None, should contain key word arguments
for the Tarantola and Valette inversion. An empty dictionary
uses the default values in <cite>Tarantola_Valette</cite>. If None, uses
the Moore-Penrose inverse.</p></li>
<li><p><strong>weighted</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – <dl class="simple">
<dt>This option is exploratory. If True,</dt><dd><ol class="arabic simple">
<li><p>More weight is given to the fault planes that are clearly
more unstable than their auxiliary counterpart in the
stress field estimated at iteration t-1</p></li>
<li><p>Randomly mixes the set of fault planes at iterations
t-1 and t, giving larger probability to the planes
belonging to the set that produced the larger instability.</p></li>
</ol>
</dd>
</dl>
<p>This option can be interesting for reaching convergence on
data sets of bad quality.</p>
</p></li>
<li><p><strong>n_threads</strong> (<em>scalar int</em><em>, </em><em>optional</em>) – Default to <cite>n_threads=1</cite>. If different from 1, the task is parallelized
across <cite>n_threads</cite> threads. If <cite>n_threads</cite> is <cite>0</cite>, <cite>None</cite> or <cite>“all”</cite>,
use all available CPUs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>output</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>output[“boot_stress_tensor”]: (n_resamplings, 3, 3) numpy.ndarray</dt><dd><p>The inverted stress tensor in the (north, west, up)
coordinate system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“boot_principal_stresses”]: (n_resamplings, 3) numpy.ndarray</dt><dd><p>The three eigenvalues of the stress tensor, ordered from
most compressive (sigma1) to least compressive (sigma3).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“boot_principal_directions”]: (n_resamplings, 3, 3) numpy.ndarray</dt><dd><p>The three eigenvectors of the stress tensor, stored in a matrix
as column vectors and ordered from most compressive (sigma1)
to least compressive (sigma3). The direction of sigma_i for
the b-th bootstrap replica is given by:
<cite>boot_principal_directions[b, :, i]</cite>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict {str: numpy.ndarray}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.inversion_jackknife">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">inversion_jackknife</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">jack_strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_random_selections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_resamplings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tarantola_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_events</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#inversion_jackknife"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.inversion_jackknife" title="Permalink to this definition"></a></dt>
<dd><p>This routine was tailored for one of my application, but it can
be of interest to others. Each earthquake comes with an ensemble
of focal mechanism solutions that were obtained by resampling the
set of seismic stations used in the focal mechanism inversion. The
resampling was done with the delete-k-jackknife method, hence the
name of the routine. This routine randomly samples focal mechanisms
from these ensembles and runs the stress inversion. This is a way
of propagating the focal mechanism uncertainties into the stress
inversion. In this routine we do not seek which nodal planes are
more likely to be the fault planes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>jack_strikes</strong> (<em>(</em><em>n_earthquakes</em><em>, </em><em>n_jackknifes</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>jack_dips</strong> (<em>(</em><em>n_earthquakes</em><em>, </em><em>n_jackknifes</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>jack_rakes</strong> (<em>(</em><em>n_earthquakes</em><em>, </em><em>n_jackknifes</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>n_random_selections</strong> (<em>integer</em><em>, </em><em>default to 20</em>) – Number of random selections of subsets of nodal planes on
which the stress inversion is run. The final stress tensor
is averaged over the n_random_selections solutions.</p></li>
<li><p><strong>n_resamplings</strong> (<em>integer</em><em>, </em><em>default to 100</em>) – Number of times the data set is resampled from the ensembles
of focal mechanism solutions available for each earthquake.
n_resamplings stress tensors are returned, allowing to
estimate uncertainties from the distribution of solutions.</p></li>
<li><p><strong>bootstrap_events</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, the resampling is also done accross earthquakes,
following the bootstrapping method.</p></li>
<li><p><strong>shear_update_atol</strong> (<em>float</em><em>, </em><em>default to 1e-5</em>) – Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</p></li>
<li><p><strong>max_n_iterations</strong> (<em>integer</em><em>, </em><em>default to 300</em>) – The maximum number of iterations if shear stress magnitude update
does not fall below <cite>shear_update_atol</cite>.</p></li>
<li><p><strong>variable_shear</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, use the iterative linear method described in
Beauce et al. 2022, else use the classic linear method
due to Michael 1984.</p></li>
<li><p><strong>Tarantola_kwargs</strong> (<em>Dictionary</em><em>, </em><em>default to {}</em>) – If not None, should contain key word arguments
for the Tarantola and Valette inversion. An empty dictionary
uses the default values in <cite>Tarantola_Valette</cite>. If None, uses
the Moore-Penrose inverse.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>output</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>output[“jack_stress_tensor”]: (n_resamplings, 3, 3) numpy.ndarray</dt><dd><p>The inverted stress tensor in the (north, west, up)
coordinate system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“jack_principal_stresses”]: (n_resamplings, 3) numpy.ndarray</dt><dd><p>The three eigenvalues of the stress tensor, ordered from
most compressive (sigma1) to least compressive (sigma3).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“jack_principal_directions”]: (n_resamplings, 3, 3) numpy.ndarray</dt><dd><p>The three eigenvectors of the stress tensor, stored in a matrix
as column vectors and ordered from most compressive (sigma1)
to least compressive (sigma3). The direction of sigma_i for
the b-th jackknife replica is given by:
<cite>jack_principal_directions[b, :, i]</cite>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict {str: numpy.ndarray}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.inversion_jackknife_instability">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">inversion_jackknife_instability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">principal_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_coefficient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_resamplings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_stress_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stress_tensor_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tarantola_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_events</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_earthquakes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed_instability</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#inversion_jackknife_instability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.inversion_jackknife_instability" title="Permalink to this definition"></a></dt>
<dd><p>This routine was tailored for one of my application, but it can
be of interest to others. Each earthquake comes with an ensemble
of focal mechanism solutions that were obtained by resampling the
set of seismic stations used in the focal mechanism inversion. The
resampling was done with the delete-k-jackknife method, hence the
name of the routine. This routine randomly samples focal mechanisms
from these ensembles and runs the stress inversion. This is a way
of propagating the focal mechanism uncertainties into the stress
inversion. Use the instability parameter to seek which nodal planes
are more likely to be the fault planes (cf. B. Lund and R. Slunga 1999,
V. Vavrycuk 2013,2014).</p>
<p>Use a previously determined stress tensor (e.g. the output of
<cite>inversion_one_set_instability</cite>) described by its principal stress
directions and shape ratio as the prior model in the Tarantola
and Valette formula. In general, you can keep the default parameter
values, except for n_resamplings which depends on the time you can
afford spending.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>principal_directions</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <cite>principal_directions[:, i]</cite>.</p></li>
<li><p><strong>R</strong> (<em>scalar float</em>) – Shape ratio of the reference stress tensor.</p></li>
<li><p><strong>friction_coefficient</strong> (<em>scalar float</em>) – Friction value used in the instability parameter. This can be
the value output by <cite>inversion_one_set_instability</cite>.</p></li>
<li><p><strong>jack_strikes</strong> (<em>(</em><em>n_earthquakes</em><em>, </em><em>n_jackknifes</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>jack_dips</strong> (<em>(</em><em>n_earthquakes</em><em>, </em><em>n_jackknifes</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>jack_rakes</strong> (<em>(</em><em>n_earthquakes</em><em>, </em><em>n_jackknifes</em><em>) </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>n_stress_iter</strong> (<em>integer</em><em>, </em><em>default to 10</em>) – Maximum number of iterations to seek for the best fault planes.
See Beauce et al. 2022 for explanations.</p></li>
<li><p><strong>stress_tensor_update_atol</strong> (<em>float</em><em>, </em><em>default to 1.e-4</em>) – If the RMS difference of the stress tensors between two
iterations fall below this threshold, convergence has been reached.</p></li>
<li><p><strong>shear_update_atol</strong> (<em>float</em><em>, </em><em>default to 1e-5</em>) – Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</p></li>
<li><p><strong>signed_instability</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</p></li>
<li><p><strong>max_n_iterations</strong> (<em>integer</em><em>, </em><em>default to 300</em>) – The maximum number of iterations if shear stress magnitude update
does not fall below <cite>shear_update_atol</cite>.</p></li>
<li><p><strong>variable_shear</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, use the iterative linear method described in
Beauce et al. 2022, else use the classic linear method
due to Michael 1984.</p></li>
<li><p><strong>Tarantola_kwargs</strong> (<em>Dictionary</em><em>, </em><em>default to {}</em>) – If not None, should contain key word arguments
for the Tarantola and Valette inversion. An empty dictionary
uses the default values in <cite>Tarantola_Valette</cite>. If None, uses
the Moore-Penrose inverse.</p></li>
<li><p><strong>bootstrap_events</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, the resampling is also done accross earthquakes,
following the bootstrapping method.</p></li>
<li><p><strong>weighted</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – <dl class="simple">
<dt>This option is exploratory. If True:</dt><dd><ol class="arabic simple">
<li><p>More weight is given to the fault planes that are clearly
more unstable than their auxiliary counterpart in the
stress field estimated at iteration t-1</p></li>
<li><p>Randomly mixes the set of fault planes at iterations
t-1 and t, giving larger probability to the planes
belonging to the set that produced the larger instability.</p></li>
</ol>
</dd>
</dl>
<p>This option can be interesting for reaching convergence on
data sets of bad quality.</p>
</p></li>
<li><p><strong>n_threads</strong> (<em>scalar int</em><em>, </em><em>optional</em>) – Default to <cite>n_threads=1</cite>. If different from 1, the task is parallelized
across <cite>n_threads</cite> threads. If <cite>n_threads</cite> is <cite>0</cite>, <cite>None</cite> or <cite>“all”</cite>,
use all available CPUs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>output</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>output[“jack_stress_tensor”]: (n_resamplings, 3, 3) numpy.ndarray</dt><dd><p>The inverted stress tensor in the (north, west, up)
coordinate system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“jack_principal_stresses”]: (n_resamplings, 3) numpy.ndarray</dt><dd><p>The three eigenvalues of the stress tensor, ordered from
most compressive (sigma1) to least compressive (sigma3).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“jack_principal_directions”]: (n_resamplings, 3, 3) numpy.ndarray</dt><dd><p>The three eigenvectors of the stress tensor, stored in a matrix
as column vectors and ordered from most compressive (sigma1)
to least compressive (sigma3). The direction of sigma_i for
the b-th jackknife replica is given by:
<cite>jack_principal_directions[b, :, i]</cite>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict {str: numpy.ndarray}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.inversion_one_set">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">inversion_one_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_random_selections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tarantola_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_eigen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#inversion_one_set"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.inversion_one_set" title="Permalink to this definition"></a></dt>
<dd><p>Invert one set of focal mechanisms without seeking which nodal planes
are more likely to be the fault planes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strikes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>n_random_selections</strong> (<em>integer</em><em>, </em><em>default to 20</em>) – Number of random selections of subsets of nodal planes on
which the stress inversion is run. The final stress tensor
is averaged over the n_random_selections solutions.</p></li>
<li><p><strong>shear_update_atol</strong> (<em>float</em><em>, </em><em>default to 1e-5</em>) – Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</p></li>
<li><p><strong>max_n_iterations</strong> (<em>integer</em><em>, </em><em>default to 300</em>) – The maximum number of iterations if shear stress magnitude update
does not fall below <cite>shear_update_atol</cite>.</p></li>
<li><p><strong>variable_shear</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, use the iterative linear method described in
Beauce et al. 2022, else use the classic linear method
due to Michael 1984.</p></li>
<li><p><strong>Tarantola_kwargs</strong> (<em>Dictionary</em><em>, </em><em>default to {}</em>) – If not None, should contain key word arguments
for the Tarantola and Valette inversion. An empty dictionary
uses the default values in <cite>Tarantola_Valette</cite>. If None, uses
the Moore-Penrose inverse.</p></li>
<li><p><strong>return_stats</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, the posterior data and model parameter distributions
estimated from the Tarantola and Valette formula
(cf. Tarantola_Valette routine).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>output</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>output[“stress_tensor”]: (3, 3) numpy.ndarray</dt><dd><p>The inverted stress tensor in the (north, west, up)
coordinate system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“principal_stresses”]: (3,) numpy.ndarray, optional</dt><dd><p>The three eigenvalues of the stress tensor, ordered from
most compressive (sigma1) to least compressive (sigma3).
Returned if <cite>return_eigen</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“principal_directions”]: (3, 3) numpy.ndarray, optional</dt><dd><p>The three eigenvectors of the stress tensor, stored in a matrix
as column vectors and ordered from most compressive (sigma1)
to least compressive (sigma3). The direction of sigma_i is
given by: <cite>principal_directions[:, i]</cite>.
Returned if <cite>return_eigen</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“C_m_posterior”]: (5, 5) numpy.ndarray, optional</dt><dd><p>Posterior covariance of the model parameter distribution
estimated from the Tarantola and Valette formula.
Returned if <cite>return_stats</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“C_d_posterior”]: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray, optional</dt><dd><p>Posterior covariance of the data distribution
estimated from the Tarantola and Valette formula.
Returned if <cite>return_stats</cite> is True.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict {str: numpy.ndarray}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.inversion_one_set_instability">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">inversion_one_set_instability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_coefficient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_stress_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_random_selections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stress_tensor_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tarantola_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_averaging</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed_instability</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#inversion_one_set_instability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.inversion_one_set_instability" title="Permalink to this definition"></a></dt>
<dd><p>Invert one set of focal mechanisms with the instability parameter
to seek which nodal planes are more likely to be the fault planes
(cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).
In general, you can keep the default parameter values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strikes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>friction_coefficient</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>default to 0.6</em>) – If not None, the inversion is made assuming a friction coefficient
equal to <cite>friction_coefficient</cite>. If None, the friction coefficient
is taken as the one that maximizes instability based on a first
approximation of the stress tensor.</p></li>
<li><p><strong>friction_min</strong> (<em>float</em><em>, </em><em>default to 0.1</em>) – Lower bound of explored friction values.</p></li>
<li><p><strong>friction_max</strong> (<em>float</em><em>, </em><em>default to 0.8</em>) – Upper bound of explored friction values.</p></li>
<li><p><strong>friction_step</strong> (<em>float</em><em>, </em><em>default to 0.05</em>) – Step employed in the grid search of the friction value
that maximizes the instability parameter.</p></li>
<li><p><strong>n_stress_iter</strong> (<em>integer</em><em>, </em><em>default to 10</em>) – Maximum number of iterations to seek for the best fault planes.
See Beauce et al. 2022 for explanations.</p></li>
<li><p><strong>stress_tensor_update_atol</strong> (<em>float</em><em>, </em><em>default to 1.e-4</em>) – If the RMS difference of the stress tensors between two
iterations fall below this threshold, convergence has been reached.</p></li>
<li><p><strong>n_random_selections</strong> (<em>integer</em><em>, </em><em>default to 20</em>) – Number of random selections of subsets of nodal planes on
which the stress inversion is run. The final stress tensor
is averaged over the n_random_selections solutions.</p></li>
<li><p><strong>shear_update_atol</strong> (<em>float</em><em>, </em><em>default to 1e-5</em>) – Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</p></li>
<li><p><strong>max_n_iterations</strong> (<em>integer</em><em>, </em><em>default to 300</em>) – The maximum number of iterations if shear stress magnitude update
does not fall below <cite>shear_update_atol</cite>.</p></li>
<li><p><strong>variable_shear</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, use the iterative linear method described in
Beauce et al. 2022, else use the classic linear method
due to Michael 1984.</p></li>
<li><p><strong>n_averaging</strong> (<em>integer</em><em>, </em><em>default to 1</em>) – The inversion can be sensitive to initial conditions. To improve
reproducibility of the results it is good to repeat the inversion
several times and average the results. Set <cite>n_averaging</cite> to ~5 if
you can afford the increase in run time.</p></li>
<li><p><strong>signed_instability</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</p></li>
<li><p><strong>Tarantola_kwargs</strong> (<em>Dictionary</em><em>, </em><em>default to {}</em>) – If not None, should contain key word arguments
for the Tarantola and Valette inversion. An empty dictionary
uses the default values in <cite>Tarantola_Valette</cite>. If None, uses
the Moore-Penrose inverse.</p></li>
<li><p><strong>return_stats</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, the posterior data and model parameter distributions
estimated from the Tarantola and Valette formula
(cf. Tarantola_Valette routine).</p></li>
<li><p><strong>weighted</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – <dl class="simple">
<dt>This option is exploratory. If True:</dt><dd><ol class="arabic simple">
<li><p>More weight is given to the fault planes that are clearly
more unstable than their auxiliary counterpart in the
stress field estimated at iteration t-1</p></li>
<li><p>Randomly mixes the set of fault planes at iterations
t-1 and t, giving larger probability to the planes
belonging to the set that produced the larger instability.</p></li>
</ol>
</dd>
</dl>
<p>This option can be interesting for reaching convergence on
data sets of bad quality.</p>
</p></li>
<li><p><strong>plot</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, plot the set of nodal planes selected at each iteration,
and the weight attributed to each of these planes. Can be used
with <cite>weighted=True</cite> to see if the inversion convergences to a
well defined set of planes.</p></li>
<li><p><strong>verbose</strong> (<em>integer</em><em>, </em><em>default to 1</em>) – <p>Level of verbosity.
0: No print statements.
1: Print whether the algorithm converged.
2: Print the stress tensor at the end of each fault plane</p>
<blockquote>
<div><p>selection iteration.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>output</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>output[“stress_tensor”]: (3, 3) numpy.ndarray</dt><dd><p>The inverted stress tensor in the (north, west, up)
coordinate system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“friction_coefficient”]: scalar float</dt><dd><p>The best friction coefficient determined by the inversion
or the input friction coefficient (see <cite>friction_coefficient</cite>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“principal_stresses”]: (3,) numpy.ndarray</dt><dd><p>The three eigenvalues of the stress tensor, ordered from
most compressive (sigma1) to least compressive (sigma3).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“principal_directions”]: (3, 3) numpy.ndarray</dt><dd><p>The three eigenvectors of the stress tensor, stored in a matrix
as column vectors and ordered from most compressive (sigma1)
to least compressive (sigma3). The direction of sigma_i is
given by: <cite>principal_directions[:, i]</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“C_m_posterior”]: (5, 5) numpy.ndarray, optional</dt><dd><p>Posterior covariance of the model parameter distribution
estimated from the Tarantola and Valette formula.
Returned if <cite>return_stats</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“C_d_posterior”]: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray, optional</dt><dd><p>Posterior covariance of the data distribution
estimated from the Tarantola and Valette formula.
Returned if <cite>return_stats</cite> is True.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict {str: numpy.ndarray}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.ilsi.iterative_linear_si">
<span class="sig-prename descclassname"><span class="pre">ILSI.ilsi.</span></span><span class="sig-name descname"><span class="pre">iterative_linear_si</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear_update_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tarantola_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_eigen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/ilsi.html#iterative_linear_si"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.ilsi.iterative_linear_si" title="Permalink to this definition"></a></dt>
<dd><p>Iterative stress inversion described in Beauce et al. 2022.</p>
<dl class="simple">
<dt>This method assumes:</dt><dd><ul class="simple">
<li><p>The tectonic stress field is uniform.</p></li>
<li><p>Wallace-Bott hypothesis: The slip vector points in the same
direction as shear stress on the fault.</p></li>
</ul>
</dd>
</dl>
<p>The parameters we invert for are the directions of the three
principal stresses and the shape ratio. Because this inversion does not
aim at infering the absolute stress values, we only consider the
deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot
determine the norm of the stress tensor, therefore sum sigma**2 = 1.
Each iteration of this inversion scheme is a linear inversion.
N.B.: This routine is written assuming outward footwall normals and slip
vectors of the hanging wall w.r.t. the footwall. Therefore, the stress
tensor sign convention is compression negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strikes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The strike of nodal planes 1, angle between north and
the fault’s horizontal (0-360).</p></li>
<li><p><strong>dips</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</p></li>
<li><p><strong>rakes</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – The rake of nodal planes 1, angle between the fault’s horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</p></li>
<li><p><strong>shear_update_atol</strong> (<em>float</em><em>, </em><em>default to 1e-5</em>) – Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</p></li>
<li><p><strong>max_n_iterations</strong> (<em>integer</em><em>, </em><em>default to 300</em>) – The maximum number of iterations if shear stress magnitude update
does not fall below <cite>shear_update_atol</cite>.</p></li>
<li><p><strong>Tarantola_kwargs</strong> (<em>Dictionary</em><em>, </em><em>default to {}:</em>) – If not None, should contain key word arguments
for the Tarantola and Valette inversion. An empty dictionary
uses the default values in <cite>Tarantola_Valette</cite>. If None, uses
the Moore-Penrose inverse.</p></li>
<li><p><strong>return_eigen</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, returns the eigendecomposition of the inverted
stress tensor in addition to returning the stress tensor.</p></li>
<li><p><strong>return_stats</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, the posterior data and model parameter distributions
estimated from the Tarantola and Valette formula
(cf. Tarantola_Valette routine).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>output</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>output[“stress_tensor”]: (3, 3) numpy.ndarray</dt><dd><p>The inverted stress tensor in the (north, west, up)
coordinate system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“principal_stresses”]: (3,) numpy.ndarray, optional</dt><dd><p>The three eigenvalues of the stress tensor, ordered from
most compressive (sigma1) to least compressive (sigma3).
Returned if <cite>return_eigen</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“principal_directions”]: (3, 3) numpy.ndarray, optional</dt><dd><p>The three eigenvectors of the stress tensor, stored in a matrix
as column vectors and ordered from most compressive (sigma1)
to least compressive (sigma3). The direction of sigma_i is
given by: <cite>principal_directions[:, i]</cite>.
Returned if <cite>return_eigen</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“C_m_posterior”]: (5, 5) numpy.ndarray, optional</dt><dd><p>Posterior covariance of the model parameter distribution
estimated from the Tarantola and Valette formula.
Returned if <cite>return_stats</cite> is True.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output[“C_d_posterior”]: (3 x n_earthquakes, 3 x n_earthquakes) numpy.ndarray, optional</dt><dd><p>Posterior covariance of the data distribution
estimated from the Tarantola and Valette formula.
Returned if <cite>return_stats</cite> is True.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict {str: numpy.ndarray}</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-ILSI.utils_stress"></span><dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.A_phi_">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">A_phi_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">principal_stresses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">principal_directions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#A_phi_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.A_phi_" title="Permalink to this definition"></a></dt>
<dd><p>Compute A_phi as defined by Simpson 1997.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>principal_stresses</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>numpy.ndarray</em>) – The three eigenvalues of the stress tensor, ordered
from most compressive (sigma1) to least compressive (sigma3).</p></li>
<li><p><strong>principal_directions</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – The three eigenvectors of the stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <cite>principal_directions[:, i]</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>A_phi</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>scalar, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.R_">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">R_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">principal_stresses</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#R_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.R_" title="Permalink to this definition"></a></dt>
<dd><p>Computes the shape ratio R=(sig1-sig2)/(sig1-sig3).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pinricpal_stresses</strong> (<em>numpy.ndarray</em><em> or </em><em>list</em>) – Contains the three eigenvalues of the stress tensor
ordered such that:
<cite>principal_stresses[0]</cite> &lt; <cite>principal_stresses[1]</cite> &lt; <cite>principal_stresses[2]</cite>
with <cite>principal_stresses[0]</cite> being the most compressional stress.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>shape_ratio</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>scalar float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.angular_residual">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">angular_residual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stress_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#angular_residual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.angular_residual" title="Permalink to this definition"></a></dt>
<dd><p>Compute the angle between the direction of the resolved shear
stress predicted by the stress tensor and the direction of
slip given by the strike/dip/rake data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stress_tensor</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – The Cauchy stress tensor.</p></li>
<li><p><strong>strikes</strong> (<em>(</em><em>n_earthquakes</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em>) – Fault strikes.</p></li>
<li><p><strong>dips</strong> (<em>(</em><em>n_earthquakes</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em>) – Fault dips.</p></li>
<li><p><strong>rakes</strong> (<em>(</em><em>n_earthquakes</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em>) – Fault rakes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>angles</strong> – Angles between shear stress and slip.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n_earthquakes) numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.aux_plane">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">aux_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#aux_plane"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.aux_plane" title="Permalink to this definition"></a></dt>
<dd><p>Get Strike and dip of second plane.</p>
<p>Adapted from MATLAB script
<a class="reference external" href="http://www.ceri.memphis.edu/people/olboyd/Software/Software.html">bb.m</a>
written by Andy Michael, Chen Ji and Oliver Boyd.</p>
<p>Taken from &lt;<a class="reference external" href="https://docs.obspy.org/_modules/obspy/imaging/beachball.html#aux_plane">https://docs.obspy.org/_modules/obspy/imaging/beachball.html#aux_plane</a>&gt;.
See Obspy project at &lt;<a class="reference external" href="https://github.com/obspy/obspy">https://github.com/obspy/obspy</a>&gt;.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.check_right_handedness">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">check_right_handedness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#check_right_handedness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.check_right_handedness" title="Permalink to this definition"></a></dt>
<dd><p>Make sure the matrix of column vectors forms
a right-handed basis. This is particularly important
when re-ordering the principal stress directions
based on their eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>basis</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – Matrix with column vectors that form the basis of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rh_basis</strong> – Matrix with column vectors that form the right-handed
version of the input basis. One of the unit vectors
might have been reversed in the process.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3, 3) numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.compute_traction">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">compute_traction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stress_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#compute_traction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.compute_traction" title="Permalink to this definition"></a></dt>
<dd><p>Compute traction and its normal and shear components on a given plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stress_tensor</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – Cauchy stress tensor.</p></li>
<li><p><strong>normal</strong> (<em>(</em><em>n_earthquakes</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – Matrix of n_earthquakes row vectors of fault normals.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>traction</strong> (<em>(n_earthquakes, 3) numpy.ndarray</em>) – Tractions on the surfaces defined by normal.</p></li>
<li><p><strong>normal_traction</strong> (<em>(n_earthquakes, 3) numpy.ndarray</em>) – Normal component of the tractions.</p></li>
<li><p><strong>shear_traction</strong> (<em>(n_earthquakes, 3) numpy.ndarray</em>) – Tangential component of the tractions.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.errors_in_data">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">errors_in_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dip</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rake</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_strikes_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_dips_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_rakes_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_strikes_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_dips_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jack_rakes_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#errors_in_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.errors_in_data" title="Permalink to this definition"></a></dt>
<dd><p>This routines was tailored for my applications.
Use the multiple solutions obtained during the jackknife resampling
of the focal mechanism inversion to compute the deviation of these
multiple solutions from the best solution. A low deviation means a
good quality focal mechanism. Because there are two possible slip vectors
for each focal mechanism solution, we systematically look among the
jackknife solutions 1 and 2 for the closest slip vector to the target
vector, defined by (strike, dip, rake).
We recommend to run this function for (strike, dip, rake)_1 and
(strike, dip, rake)_2 of the best focal mechanism solution, and
average the outputs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.get_CI_levels">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">get_CI_levels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">azimuths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plunges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">confidence_intervals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[95.0,</span> <span class="pre">90.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_sig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#get_CI_levels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.get_CI_levels" title="Permalink to this definition"></a></dt>
<dd><p>Computes the 2d histogram in the stereographic space
of a collection lines described by their azimuth and plunge.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>azimuths</strong> (<em>(</em><em>n_lines</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – Azimuths of the lines.</p></li>
<li><p><strong>plunges</strong> (<em>(</em><em>n_lines</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – Plunges (angle from horizontal) of the lines.</p></li>
<li><p><strong>nbins</strong> (<em>integer</em><em>, </em><em>default to 200</em>) – Number of bins, in both axes, used to discretized
the 2d space.</p></li>
<li><p><strong>smoothing_sig</strong> (<em>float</em><em>, </em><em>default to 1</em>) – If greater than 0, smooth the 2d distribution
with a gaussian kernel. This is useful to derive
smooth confidence intervals.</p></li>
<li><p><strong>plot</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, plot the 2d histogram.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>count</strong> (<em>(nbins, nbins) numpy.ndarray, integer, optional</em>) – 2D histogram of the lines dsecribed by azimuths and plunges.
Only provided if <cite>return_count</cite> is True.</p></li>
<li><p><strong>lons_g</strong> (<em>(nbins, nbins) numpy.ndarray, float, optional</em>) – 2D grid of the longitudinal coordinate of each bin.
Only provided if <cite>return_count</cite> is True.</p></li>
<li><p><strong>lats_g</strong> (<em>(nbins, nbins) numpy.ndarray, float, optional</em>) – 2D grid f the latitudinal coordinate of each bin.
Only provided if <cite>return_count</cite> is True.</p></li>
<li><p><strong>confidence_intervals</strong> (<em>(nbins, nbins) numpy.ndarray, float</em>) – 2D distribution of the mass.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.get_CI_levels_joint">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">get_CI_levels_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">azimuths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plunges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">confidence_intervals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[90.0,</span> <span class="pre">95.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_sig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#get_CI_levels_joint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.get_CI_levels_joint" title="Permalink to this definition"></a></dt>
<dd><p>Computes the 2d histogram in the stereographic space
of a collection lines described by their azimuth and plunge.
This is an EXPERIMENTAL function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>azimuths</strong> (<em>(</em><em>n_lines</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – Azimuths of the lines.</p></li>
<li><p><strong>plunges</strong> (<em>(</em><em>n_lines</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – Plunges (angle from horizontal) of the lines.</p></li>
<li><p><strong>nbins</strong> (<em>integer</em><em>, </em><em>default to 200</em>) – Number of bins, in both axes, used to discretized
the 2d space.</p></li>
<li><p><strong>smoothing_sig</strong> (<em>float</em><em>, </em><em>default to 1</em>) – If greater than 0, smooth the 2d distribution
with a gaussian kernel. This is useful to derive
smooth confidence intervals.</p></li>
<li><p><strong>plot</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, plot the 2d histogram.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>count</strong> (<em>(nbins, nbins) numpy.ndarray, integer, optional</em>) – 2D histogram of the lines dsecribed by azimuths and plunges.
Only provided if <cite>return_count</cite> is True.</p></li>
<li><p><strong>lons_g</strong> (<em>(nbins, nbins) numpy.ndarray, float, optional</em>) – 2D grid of the longitudinal coordinate of each bin.
Only provided if <cite>return_count</cite> is True.</p></li>
<li><p><strong>lats_g</strong> (<em>(nbins, nbins) numpy.ndarray, float, optional</em>) – 2D grid f the latitudinal coordinate of each bin.
Only provided if <cite>return_count</cite> is True.</p></li>
<li><p><strong>confidence_intervals</strong> (<em>(nbins, nbins) numpy.ndarray, float</em>) – 2D distribution of the mass.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.get_bearing_plunge">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">get_bearing_plunge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemisphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lower'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#get_bearing_plunge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.get_bearing_plunge" title="Permalink to this definition"></a></dt>
<dd><p>The vectors are in the coordinate system (x1, x2, x3):
x1: north
x2: west
x3: upward</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – Vector for which we want the bearing (azimuth) and plunge.</p></li>
<li><p><strong>degrees</strong> (<em>boolean</em><em>, </em><em>default to True</em>) – If True, returns bearing and plunge in degrees.
In radians otherwise.</p></li>
<li><p><strong>hemisphere</strong> (<em>string</em><em>, </em><em>default to 'lower'</em>) – Consider the intersection of the line defined by u
with the lower hemisphere if <cite>hemisphere</cite> is ‘lower’, or
with the upper hemisphere if <cite>hemisphere</cite> is ‘upper’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>bearing</strong> (<em>float</em>) – Angle between the north and the line.</p></li>
<li><p><strong>plunge</strong> (<em>float</em>) – Angle between the horizontal plane and the line.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.hist2d">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">hist2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">azimuths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plunges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_sig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#hist2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.hist2d" title="Permalink to this definition"></a></dt>
<dd><p>Computes the 2d histogram in the stereographic space
of a collection lines described by their azimuth and plunge.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>azimuths</strong> (<em>(</em><em>n_lines</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – Azimuths of the lines.</p></li>
<li><p><strong>plunges</strong> (<em>(</em><em>n_lines</em><em>) </em><em>list</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>float</em>) – Plunges (angle from horizontal) of the lines.</p></li>
<li><p><strong>nbins</strong> (<em>integer</em><em>, </em><em>default to 200</em>) – Number of bins, in both axes, used to discretized
the 2d space.</p></li>
<li><p><strong>smoothing_sih</strong> (<em>float</em><em>, </em><em>default to 0</em>) – If greater than 0, smooth the 2d distribution
with a gaussian kernel. This is useful to derive
smooth confidence intervals.</p></li>
<li><p><strong>plot</strong> (<em>boolean</em><em>, </em><em>default to False</em>) – If True, plot the 2d histogram.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.joint_CDF">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">joint_CDF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#joint_CDF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.joint_CDF" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.kagan_angle">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">kagan_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#kagan_angle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.kagan_angle" title="Permalink to this definition"></a></dt>
<dd><p>Compute the minimum rotation about <em>some</em> axis required
to match the two tensors. This angle is a measure of their
difference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor1</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – First tensor, e.g. moment or stress tensor.</p></li>
<li><p><strong>tensor2</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – Second tensor, e.g. moment of stress tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rotation_angle</strong> – Smallest angle, in degrees, required to superimpose
the two tensors.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>scalar float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.mean_angular_residual">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">mean_angular_residual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stress_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#mean_angular_residual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.mean_angular_residual" title="Permalink to this definition"></a></dt>
<dd><p>Mean of the absolute value of the angles returned by
angular_residual. See angular_residual for more info.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.mean_kagan_angle">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">mean_kagan_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strikes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dips</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rakes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strike0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dip0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rake0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#mean_kagan_angle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.mean_kagan_angle" title="Permalink to this definition"></a></dt>
<dd><p>Computes the mean kagan angle as a measure of dispersion.</p>
<p>The mean kagan angle within a population of focal mechanisms
described by strikes/dips/rakes. If strike0, dip0, and rake0
are specified, then the mean kagan angle is computed not from
all pairs of focal mechanisms, but only between all focal mechanisms
and the reference focal mechanism described by strike0/dip0/rake0.
The mean kagan angle can be interpreted as a measure of dispersion
within the population.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strikes</strong> (<em>numpy.ndarray</em><em> or </em><em>list</em><em>, </em><em>float</em>) – Strikes of the moment tensors.</p></li>
<li><p><strong>dips</strong> (<em>numpy.ndarray</em><em> or </em><em>list</em><em>, </em><em>float</em>) – Dips of the moment tensors.</p></li>
<li><p><strong>rakes</strong> (<em>numpy.ndarray</em><em> or </em><em>list</em><em>, </em><em>float</em>) – Rakes of the moment tensors.</p></li>
<li><p><strong>strike0</strong> (<em>scalar</em><em>, </em><em>float</em><em>, </em><em>default to None</em>) – Strike of the reference moment tensor.</p></li>
<li><p><strong>dip0</strong> (<em>scalar</em><em>, </em><em>float</em><em>, </em><em>default to None</em>) – Dip of the reference moment tensor.</p></li>
<li><p><strong>rake0</strong> (<em>scalar</em><em>, </em><em>float</em><em>, </em><em>default to None</em>) – Rake of the reference moment tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mean_angle</strong> – Mean kagan angle between the moment tensors given as input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>scalar, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.normal_slip_vectors">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">normal_slip_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dip</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rake</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inward'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#normal_slip_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.normal_slip_vectors" title="Permalink to this definition"></a></dt>
<dd><p>Determine the normal and the slip vectors of the
focal mechanism defined by (strike, dip, rake).
From Stein and Wysession 2002.</p>
<p>N.B.: This is the normal of the FOOT WALL and the slip
of the HANGING WALL w.r.t the foot wall. It means that the
normal is an inward-pointing normal for the hanging wall,
and an outward pointing-normal for the foot wall.</p>
<p>The vectors are in the coordinate system (x1, x2, x3):
x1: north
x2: west
x3: upward</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strike</strong> (<em>float</em>) – Strike of the fault.</p></li>
<li><p><strong>dip</strong> (<em>float</em>) – Dip of the fault.</p></li>
<li><p><strong>rake</strong> (<em>float</em>) – Rake of the fault.</p></li>
<li><p><strong>direction</strong> (<em>string</em><em>, </em><em>default to 'inward'</em>) – If ‘inward’, returns the inward normal of the HANGING wall,
which is the formula given in Stein and Wysession. Equivalently,
this is the outward normal of the foot wall.
If ‘outward’, returns the outward normal of the HANGING wall,
or, equivalently, the inward normal of the hanging wall.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>n</strong> (<em>(3) numpy.ndarray</em>) – The fault normal.</p></li>
<li><p><strong>d</strong> (<em>(3) numpy.ndarray</em>) – The slip vector given as the direction of motion
of the hanging wall w.r.t. the foot wall.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.p_t_b_axes">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">p_t_b_axes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#p_t_b_axes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.p_t_b_axes" title="Permalink to this definition"></a></dt>
<dd><p>Determine the P (most compressive), T (least compressive)
and B (intermediate, or neutral axis) axes
from the normal and the slip vectors, following
Stein and Wysession 2002, Section 4.5.2.
(P, T, B) forms an orthogonal basis.</p>
<p>The vectors are in the coordinate system (x1, x2, x3):
x1: north
x2: west
x3: upward</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.principal_faults">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">principal_faults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stress_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">friction_coefficient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#principal_faults"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.principal_faults" title="Permalink to this definition"></a></dt>
<dd><p>Compute the orientation of the most unstable fault planes given
a stress tensor and a coefficient of friction. These faults are
called the principal faults.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stress_tensor</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – Cauchy stress tensor.</p></li>
<li><p><strong>friction_coefficient</strong> (<em>scalar float</em>) – Coefficient of friction used for the Mohr-Coulomb
failure criterion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>n1</strong> (<em>(3, 1) numpy.ndarray</em>) – Normal of the first principal faults.</p></li>
<li><p><strong>n2</strong> (<em>(3, 1) numpy.ndarray</em>) – Normal of the second principal faults. The two
faults form a pair of conjugate faults.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.quaternion">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">quaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#quaternion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.quaternion" title="Permalink to this definition"></a></dt>
<dd><p>Formula of quaternion of rotation matrix with <cite>t</cite> (least compressive),
<cite>p</cite> (most compressive), <cite>b</cite> (neutral) components expressed in the
(north, east, down) frame of reference.
<cite>t</cite>, <cite>p</cite>, <cite>b</cite> can equivalently be the sigma_3, sigma_1, sigma_2 components.
Make sure (<cite>t</cite>, <cite>p</cite>, <cite>b</cite>) form a right-handed basis.
This routine was copied from the _tpb2q routine of the Pyrocko Python
project (see at <a class="reference external" href="https://pyrocko.org/docs/current/_modules/pyrocko/moment_tensor.html#kagan_angle">https://pyrocko.org/docs/current/_modules/pyrocko/moment_tensor.html#kagan_angle</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>numpy.ndarray</em><em> or </em><em>list</em>) – </p></li>
<li><p><strong>p</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>numpy.ndarray</em><em> or </em><em>list</em>) – </p></li>
<li><p><strong>b</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>numpy.ndarray</em><em> or </em><em>list</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>quaternion</strong> – The quaternion that represents the rotation represented by
the matrix (t, p, b), where t, p, b are column vectors.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(4,) numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.random_rotation">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">random_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">360.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#random_rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.random_rotation" title="Permalink to this definition"></a></dt>
<dd><p>Generate a random rotation matrix.</p>
<dl class="simple">
<dt>Generate a random rotation matrix by:</dt><dd><ol class="arabic simple">
<li><p>Generate a random unit vector in 3D.</p></li>
<li><p>Generate a random rotation angle between 0 and max_angle (degrees)</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_angle</strong> (<em>scalar float</em><em>, </em><em>default to 360</em>) – Upper bound of the uniform distribution from which the rotation
angle is randomly drawn.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>R</strong> – Rotation matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3, 3) numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.reduced_stress_tensor">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">reduced_stress_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">principal_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#reduced_stress_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.reduced_stress_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Computes a normalized stress tensor where the most
and least compressive principal stresses are set to
-1 and +1, respectively, and the intermediate stress
is determined by the shape ratio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>principal_directions</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray.</em>) – The three eigenvectors of the stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <cite>principal_directions[:, i]</cite>.</p></li>
<li><p><strong>R</strong> (<em>float</em>) – The shape ratio (sig1 - sig2)/(sig1 - sig3).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>stress_tensor</strong> – The stress tensor built from the principal directions
and the shape ratio.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3, 3) numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.rotation">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.rotation" title="Permalink to this definition"></a></dt>
<dd><p>Compute the rotation matrix about axis with angle <cite>angle</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> – Axis about which the rotation is computed.</p></li>
<li><p><strong>angle</strong> (<em>scalar</em><em>, </em><em>float</em>) – Angle, in degrees, of the rotation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>R</strong> – Rotation matrix of angle <cite>angle</cite> degrees about <cite>axis</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3, 3) numpy.ndarray, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.round_cos">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">round_cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#round_cos"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.round_cos" title="Permalink to this definition"></a></dt>
<dd><p>Clip x so that it fits with the [-1,1] interval.</p>
<p>If x is slightly outside the [-1,1] because of numerical
imprecision, x is rounded, and can then be safely passed
to arccos or arcsin. If x is truly outside of [-1,1], x
is returned unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>scalar</em><em>, </em><em>float</em>) – Float variable that represents a cos or sin that
is supposed to be within the [-1,1] interval.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x_r</strong> – A rounded version of x, if necessary.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>scalar, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.shear_slip_angle_difference">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">shear_slip_angle_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stress_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dip</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rake</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#shear_slip_angle_difference"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.shear_slip_angle_difference" title="Permalink to this definition"></a></dt>
<dd><p>Return the angle difference between the slip vector
from the focal mechanism solution and the shear traction
on the fault determined from the inverted stress tensor.
Given that the stress inversion is made under the Wallace-Bott
assumption, shear stress on the fault is parallel to slip, then
this angle difference is a measure of misfit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stress_tensor</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray</em>) – The Cauchy stress tensor.</p></li>
<li><p><strong>strike</strong> (<em>float</em>) – Strike of the fault.</p></li>
<li><p><strong>dip</strong> (<em>float</em>) – Dip of the fault.</p></li>
<li><p><strong>rake</strong> (<em>float</em>) – Rake of the fault.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>angle</strong> – The angle between shear stress and slip, in degrees.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.stress_tensor_eigendecomposition">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">stress_tensor_eigendecomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stress_tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#stress_tensor_eigendecomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.stress_tensor_eigendecomposition" title="Permalink to this definition"></a></dt>
<dd><p>Compute the eigendecomposition of stress tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>stress_tensor</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>numpy.ndarray.</em>) – The stress tensor for which to solve the
eigenvalue problem.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>principal_stresses</strong> (<em>(3,) numpy.ndarray.</em>) – The three eigenvalues of the stress tensor, ordered
from most compressive (sigma1) to least compressive (sigma3).</p></li>
<li><p><strong>principal_directions</strong> (<em>(3, 3) numpy.ndarray.</em>) – The three eigenvectors of the stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <cite>principal_directions[:, i]</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.strike_dip_rake">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">strike_dip_rake</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#strike_dip_rake"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.strike_dip_rake" title="Permalink to this definition"></a></dt>
<dd><p>Invert the relationships between strike/dip/rake
and normal (n) and slip (d) vectors found in Stein.
n and d are required to be given as the default format
returned by normal_slip_vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – The outward pointing normal of the FOOT wall.</p></li>
<li><p><strong>d</strong> – The slip direction of the hanging wall w.r.t.
the foot wall.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>strike</strong> (<em>float</em>) – Strike of the fault, in degress.</p></li>
<li><p><strong>dip</strong> (<em>float</em>) – Dip of the fault, in degrees.</p></li>
<li><p><strong>rake</strong> (<em>float</em>) – Rake of the fault, in degrees.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ILSI.utils_stress.strike_dip_rake_to_mt">
<span class="sig-prename descclassname"><span class="pre">ILSI.utils_stress.</span></span><span class="sig-name descname"><span class="pre">strike_dip_rake_to_mt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dip</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rake</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ILSI/utils_stress.html#strike_dip_rake_to_mt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ILSI.utils_stress.strike_dip_rake_to_mt" title="Permalink to this definition"></a></dt>
<dd><p>Compute the <em>normalized</em> moment tensor described by strike/dip/rake.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strike</strong> (<em>scalar</em><em>, </em><em>float</em>) – Strike of the input focal mechanism.</p></li>
<li><p><strong>dip</strong> (<em>scalar</em><em>, </em><em>float</em>) – Dip of the input focal mechanism.</p></li>
<li><p><strong>rake</strong> (<em>scalar</em><em>, </em><em>float</em>) – Rake of the input focal mechanism.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mt</strong> – Normalized moment tensor. Its columns are the
(p, b, t) axes. Note: we return (p, b, t) to be
consistent with our stress tensor convention (sig1, sig2, sig3).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3, 3) numpy.ndarray, float</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Eric Beaucé.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>