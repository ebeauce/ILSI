<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>ILSI.ilsi API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ILSI.ilsi</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys

import numpy as np
from numpy.linalg import LinAlgError

from . import utils_stress
        
from functools import partial

#from time import time as give_time

def forward_model(n_):
    &#34;&#34;&#34;
    Build the forward modeling matrix ``G`` given a collection
    of fault normals.

    Parameters
    ------------
    n_: (n_earthquakes, 3) array
        The i-th row n_ are the components of the i-th
        fault normal in the (north, west, south) coordinate
        system.

    Returns
    ---------
    G: (3 x n_earthquakes, 5) array
        The forward modeling matrix giving the slip (shear stress)
        directions on the faults characterized by `n_`, given the 5
        elements of the deviatoric stress tensor.
    &#34;&#34;&#34;
    n_earthquakes = n_.shape[0]
    G = np.zeros((n_earthquakes*3, 5), dtype=np.float32)
    for i in range(n_earthquakes):
        ii = i*3
        n1, n2, n3 = n_[i, :]
        G[ii+0, 0] = n1 + n1*n3**2 - n1**3
        G[ii+0, 1] = n2 - 2.*n2*n1**2
        G[ii+0, 2] = n3 - 2.*n3*n1**2
        G[ii+0, 3] = n1*n3**2 - n1*n2**2
        G[ii+0, 4] = -2.*n1*n2*n3
        G[ii+1, 0] = n2*n3**2 - n2*n1**2
        G[ii+1, 1] = n1 - 2.*n1*n2**2
        G[ii+1, 2] = -2.*n1*n2*n3
        G[ii+1, 3] = n2 + n2*n3**2 - n2**3
        G[ii+1, 4] = n3 - 2.*n3*n2**2
        G[ii+2, 0] = n3**3 - n3 - n3*n1**2
        G[ii+2, 1] = -2.*n1*n2*n3
        G[ii+2, 2] = n1 - 2.*n1*n3**2
        G[ii+2, 3] = n3**3 - n3 - n3*n2**2
        G[ii+2, 4] = n2 - 2.*n2*n3**2
    return G

def Tarantola_Valette(G, data, C_d=None, C_d_inv=None,
                      C_m=None, C_m_inv=None, m_prior=None,
                      inversion_space=&#39;model_space&#39;):
    &#34;&#34;&#34;
    Returns Tarantola&#39;s and Valette&#39;s least square solution for
    a given linear operator `G` and observation vector `data`. If the
    covariance matrices of the observations and of the model
    parameters are not known, we assume them to be identity. The
    inversion can be performed either in the data space or in
    the model space.

    Parameters
    -----------
    G: (n, m) numpy array
        The linear operator projecting elements of the model
        space m onto the data space: d = G.m
        n is the dimension of the data space,
        m is the dimension of the model space.
    data: (n,) or (n, 1) numpy array
        Vector of observations.
    C_d: (n, n) numpy array, default to None
        Covariance matrix of the observations. It quantifies
        the errors in the observations and propagates them
        in the inversion to give more weight to the observations
        with low errors. If None, then `C_d` is identity.
    C_m: (m, m) numpy array, default to None
        Covariance matrix of the model parameters. It quantifies
        the errors in the model parameters and propagates them
        in the inversion to determine the range of acceptable
        model parameters for a given set of observations.
        If None, then `C_m` is identity.
    m_prior: (m,) or (m, 1) numpy array, default to None
        If one already has a rough estimate of what the model
        parameters are, then m_prior should be filled with this estimate.
        If None, `m_prior` is set to zero.

    Returns
    ---------
    m_inv: (m, 1) numpy array
        The inverted model parameters.
    C_m_posterior: (5, 5) array
        Posterior covariance of the model parameter distribution.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array
        Posterior covariance of the data distribution.
    &#34;&#34;&#34;
    #t_start = give_time()
    dim_D = G.shape[0]
    dim_M = G.shape[1]
    # pre-compute transposed G
    #Gt = G.T
    if C_d is None:
        C_d = np.identity(dim_D, dtype=np.float32)
        C_d_inv = np.identity(dim_D, dtype=np.float32)
    elif C_d_inv is None and inversion_space == &#39;model_space&#39;:
        try:
            C_d_inv = np.linalg.inv(C_d)
        except LinAlgError:
            print(&#39;Cannot invert data covariance matrix:&#39;)
            print(C_d)
            sys.exit()
    if C_m is None:
        C_m = np.identity(dim_M, dtype=np.float32)
        C_m_inv = np.zeros_like(C_m)
    elif C_m_inv is None and inversion_space == &#39;model_space&#39;:
        try:
            C_m_inv = np.linalg.inv(C_m)
        except LinAlgError:
            print(&#39;Cannot invert model covariance matrix:&#39;)
            print(C_m)
            sys.exit()
    if m_prior is None:
        m_prior = np.zeros((dim_M, 1), dtype=np.float32)
    # make sure data is a column vector
    data = data.reshape(-1, 1)
    if inversion_space == &#39;data_space&#39;:
        # perform the inversion in the data space
        # pre-compute recurrent terms:
        Cm_Gt = C_m.dot(G.T)
        inv = np.linalg.inv(G.dot(Cm_Gt) + C_d)
        Cm_Gt_inv = Cm_Gt.dot(inv)
        m_inv = m_prior\
                + np.dot(Cm_Gt_inv, data - np.dot(G, m_prior))
        C_m_posterior = C_m - (Cm_Gt_inv.dot(G)).dot(C_m)
    elif inversion_space == &#39;model_space&#39;:
        # perform the inversion in the model space
        # pre-compute recurrent terms
        Gt_Cdinv = G.T.dot(C_d_inv)
        try:
            inv = np.linalg.inv(Gt_Cdinv.dot(G) + C_m_inv)
        except LinAlgError:
            print(&#39;Forward modelling matrix:&#39;, G)
            print(&#39;Inverse data cov matrix:&#39;, C_d_inv)
            print(&#39;Inverse model cov matrix:&#39;, C_m_inv)
            print(np.dot(Gt_Cdinv, G))
            sys.exit()
        if inv[1,1] &lt; 0.:
            print(G.T@G, C_d_inv, C_m_inv)
        m_inv = m_prior\
                + (inv.dot(Gt_Cdinv)).dot(data - G.dot(m_prior))
        #m_inv = inv@G.T@data
        C_m_posterior = inv.copy()
    else:
        print(&#39;inversion_spce should either be &#34;model_space&#34; &#39;
              &#39;or &#34;data_space&#34;&#39;)
        return
    C_d_posterior = (G.dot(C_m_posterior)).dot(G.T)
    #t_end = give_time()
    #print(&#39;{:.3f}sec on Tarantola&#39;.format(t_end-t_start))
    return m_inv, C_m_posterior, C_d_posterior


def iterative_linear_si(strikes, dips, rakes,
                        max_n_iterations=300,
                        shear_update_atol=1.e-5,
                        Tarantola_kwargs=None,
                        return_eigen=True,
                        return_stats=False):
    &#34;&#34;&#34;
    Iterative stress inversion described in Beauce et al. 2021.  

    This method assumes:  
        - The tectonic stress field is uniform.  
        - Wallace-Bott hypothesis: The slip vector points in the same
          direction as shear stress on the fault.  
    The parameters we invert for are the directions of the three
    principal stresses and the shape ratio. Because this inversion does not
    aim at infering the absolute stress values, we only consider the 
    deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot 
    determine the norm of the stress tensor, therefore sum sigma**2 = 1.
    Each iteration of this inversion scheme is a linear inversion.
    N.B.: This routine is written assuming outward footwall normals and slip
    vectors of the hanging wall w.r.t. the footwall. Therefore, the stress
    tensor sign convention is compression negative.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    Tarantola_kwargs: Dictionary, default to None:
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    return_eigen: boolean, default to True
        If True, returns the eigendecomposition of the inverted
        stress tensor in addition to returning the stress tensor.
    return_stats: boolean, default to True
        If True, the posterior data and model parameter distributions
        estimated from the Tarantola and Valette formula
        (cf. Tarantola_Valette routine).

    Returns
    --------
    full_stress_tensor: (3, 3) numpy array
        The inverted stress tensor.
    principal_stresses: (3,) numpy array, optional
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
        Only provided if `return_eigen` is True.
    principal_directions: (3, 3) numpy array, optional
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
        Only provided if `return_eigen` is True.
    C_m_posterior: (5, 5) array, optional
        Posterior covariance of the model parameter distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array, optional
        Posterior covariance of the data distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    &#34;&#34;&#34;
    #t_start = give_time()
    # First, convert the strike/dip/rake into slip and normal vectors.
    n_earthquakes = len(strikes)
    n_ = np.zeros((n_earthquakes, 3), dtype=np.float32) # normal vectors
    d_ = np.zeros((n_earthquakes, 3), dtype=np.float32) # slip vectors
    for i in range(n_earthquakes):
        n_[i, :], d_[i, :] = utils_stress.normal_slip_vectors(
                                    strikes[i], dips[i], rakes[i], direction=&#39;inward&#39;)
    # Next, define the matrix that relates the stress tensor
    # to the observed slip vectors, given the fault geometries
    # characterized by the normal vectors.
    # For each earthquake, an (3 x 5) matrix relates the 5 independent
    # stress tensor components to the 3 slip vector components.
    G = forward_model(n_)
    if Tarantola_kwargs is not None:
        # -----------------------------------------
        # copy Tarantola_kwargs because all modifications are made in-place
        Tarantola_kwargs = Tarantola_kwargs.copy()
    else:
        Tarantola_kwargs = {}
    # initialize shear magnitudes
    if &#39;m_prior&#39; in Tarantola_kwargs:
        shear = np.sqrt(np.sum((G@Tarantola_kwargs[&#39;m_prior&#39;].astype(&#39;float32&#39;)).
            reshape(n_earthquakes, 3)**2, axis=-1))
    else:
        shear = np.ones(n_earthquakes, dtype=np.float32)
    for j in range(max_n_iterations):
        sigma, C_m_posterior, C_d_posterior = Tarantola_Valette(
                G, d_*shear[:, np.newaxis], **Tarantola_kwargs)
        sigma = sigma.squeeze()
        # normalize the stress tensor to make sure the units of
        # shear does not explode or vanish (it can behave like a
        # geometrical series), this normalization gives the reduced
        # stress tensor (up to a multiplicative constant)
        full_stress_tensor = np.array([[sigma[0], sigma[1], sigma[2]],
                                       [sigma[1], sigma[3], sigma[4]],
                                       [sigma[2], sigma[4], -sigma[0]-sigma[3]]])
        norm = np.sqrt(np.sum(full_stress_tensor**2))
        norm = 1 if norm == 0. else norm
        sigma /= norm
        Tarantola_kwargs[&#39;m_prior&#39;] = sigma.reshape(5, 1).copy()
        # Note: From Tarantola&#39;s book: in an iterative non-linear
        # inversion, he does not input the posterior distribution from
        # previous iteration to the next iteration. Doing so leads to
        # vanishing or exploding covariance matrices!
        # -----------------------------
        # compute shear magnitudes
        shear0 = shear.copy()
        shear = np.sqrt(np.sum((G@sigma).reshape(n_earthquakes, 3)**2, axis=-1))
        shear_update = np.sqrt(np.mean((shear-shear0)**2))
        #print(&#39;Shear stress update: {:.3e}&#39;.format(shear_update))
        if (shear_update &lt; shear_update_atol):
            # convergence has been reached, according to the
            # user-prescribed criterion
            #print(&#39;Stop at iteration {:d}! (shear update: {:.3e})&#39;.format(j, shear_update))
            break
    sigma = sigma.squeeze()
    # build full stress tensor
    full_stress_tensor = np.array([[sigma[0], sigma[1], sigma[2]],
                                   [sigma[1], sigma[3], sigma[4]],
                                   [sigma[2], sigma[4], -sigma[0]-sigma[3]]])
    norm = np.sqrt(np.sum(full_stress_tensor**2))
    norm = 1 if norm == 0. else norm
    full_stress_tensor /= norm
    output = full_stress_tensor,
    if return_eigen:
        # solve the eigenvalue problem
        principal_stresses, principal_directions = \
                utils_stress.stress_tensor_eigendecomposition(full_stress_tensor)
        output = output + (shear, principal_stresses, principal_directions,)
    if return_stats:
        output = output + (C_m_posterior, C_d_posterior,)
    #t_end = give_time()
    #print(&#39;iterative_linear_si finished in {:.2f}sec&#39;.format(t_end-t_start))
    if len(output) == 1:
        return output[0]
    else:
        return output

def Michael1984_inversion(strikes, dips, rakes,
                          Tarantola_kwargs=None,
                          return_eigen=True,
                          return_stats=False):
    &#34;&#34;&#34;
    Linear inversion described in Michael 1984.  

    This method assumes:  
        - The tectonic stress field is uniform.  
        - Wallace-Bott hypothesis: The slip vector points in the same
          direction as shear stress on the fault.  
        - The resolved shear stress magnitude is constant on
          all faults.  
    The parameters we invert for are the directions of the three
    principal stresses and the shape ratio. Because this inversion does not
    aim at infering the absolute stress values, we only consider the 
    deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot 
    determine the norm of the stress tensor, therefore sum sigma**2 = 1.
    Each iteration of this inversion scheme is a linear inversion.
    N.B.: This routine is written assuming outward footwall normals and slip
    vectors of the hanging wall w.r.t. the footwall. Therefore, the stress
    tensor sign convention is compression negative.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    return_eigen: boolean, default to True
        If True, returns the eigendecomposition of the inverted
        stress tensor in addition to returning the stress tensor.
    return_stats: boolean, default to True
        If True, the posterior data and model parameter distributions
        estimated from the Tarantola and Valette formula
        (cf. Tarantola_Valette routine).

    Returns
    --------
    full_stress_tensor: (3, 3) numpy array
        The inverted stress tensor.
    principal_stresses: (3,) numpy array, optional
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
        Only provided if `return_eigen` is True.
    principal_directions: (3, 3) numpy array, optional
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`. 
        Only provided if `return_eigen` is True.
    C_m_posterior: (5, 5) array, optional
        Posterior covariance of the model parameter distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array, optional
        Posterior covariance of the data distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    &#34;&#34;&#34;
    # First, convert the strike/dip/rake into slip and normal vectors.
    n_earthquakes = len(strikes)
    n_ = np.zeros((n_earthquakes, 3), dtype=np.float32) # normal vectors
    d_ = np.zeros((n_earthquakes, 3), dtype=np.float32) # slip vectors
    for i in range(n_earthquakes):
        n_[i, :], d_[i, :] = utils_stress.normal_slip_vectors(
                                    strikes[i], dips[i], rakes[i], direction=&#39;inward&#39;)
    # Next, define the matrix that relates the stress tensor
    # to the observed slip vectors, given the fault geometries
    # characterized by the normal vectors.
    # For each earthquake, an (3 x 5) matrix relates the 5 independent
    # stress tensor components to the 3 slip vector components.
    G = forward_model(n_)
    if Tarantola_kwargs is not None:
        sigma, C_m_posterior, C_d_posterior = Tarantola_Valette(\
                G, d_, **Tarantola_kwargs)
        sigma = sigma.squeeze()
    else:
        # We choose any inversion method to invert G:
        G_pinv = np.linalg.pinv(G)
        # Given how we defined G, the stress tensor components
        # we get are in this order:
        # sigma_11, sigma_12, sigma_13, sigma_22, sigma_23
        sigma = np.dot(G_pinv, d_.reshape(-1, 1)).squeeze()
        # fake C_m and C_d
        C_m_posterior = np.ones((5, 5), dtype=np.float32)
        C_d_posterior = np.diag(np.ones(3*n_earthquakes, dtype=np.float32))
    full_stress_tensor = np.array([[sigma[0], sigma[1], sigma[2]],
                                   [sigma[1], sigma[3], sigma[4]],
                                   [sigma[2], sigma[4], -sigma[0]-sigma[3]]])
    norm = np.sqrt(np.sum(full_stress_tensor**2))
    norm = 1 if norm == 0. else norm
    full_stress_tensor /= norm
    output = full_stress_tensor,
    if return_eigen:
        # solve the eigenvalue problem
        principal_stresses, principal_directions = \
                utils_stress.stress_tensor_eigendecomposition(full_stress_tensor)
        output = output + (principal_stresses, principal_directions,)
    if return_stats:
        output = output + (C_m_posterior, C_d_posterior,)
    if len(output) == 1:
        return output[0]
    else:
        return output

# ---------------------------------------------------
#
#   Routines for inversion without instability parameter
#
# ---------------------------------------------------


def inversion_one_set(strikes, dips, rakes,
                      n_random_selections=20,
                      max_n_iterations=300,
                      shear_update_atol=1.e-5,
                      variable_shear=True,
                      Tarantola_kwargs=None,
                      return_stats=False):
    &#34;&#34;&#34;
    Invert one set of focal mechanisms without seeking which nodal planes
    are more likely to be the fault planes.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_random_selections: integer, default to 20
        Number of random selections of subsets of nodal planes on
        which the stress inversion is run. The final stress tensor
        is averaged over the n_random_selections solutions.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    return_stats: boolean, default to True
        If True, the posterior data and model parameter distributions
        estimated from the Tarantola and Valette formula
        (cf. Tarantola_Valette routine).

    Returns
    --------
    full_stress_tensor: (3, 3) numpy array
        The inverted stress tensor.
    principal_stresses: (3,) numpy array
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    principal_directions: (3, 3) numpy array
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: principal_directions[:, i] 
    C_m_posterior: (5, 5) array, optional
        Posterior covariance of the model parameter distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array, optional
        Posterior covariance of the data distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    &#34;&#34;&#34;
    # compute auxiliary planes
    strikes_1, dips_1, rakes_1 = strikes, dips, rakes
    strikes_2, dips_2, rakes_2 = \
            np.asarray(list(map(utils_stress.aux_plane, strikes, dips, rakes))).T
    # define shape variable
    n_earthquakes = len(strikes)
    # define flat arrays
    strikes = np.hstack((strikes_1.reshape(-1, 1), strikes_2.reshape(-1, 1))).flatten()
    dips = np.hstack((dips_1.reshape(-1, 1), dips_2.reshape(-1, 1))).flatten()
    rakes = np.hstack((rakes_1.reshape(-1, 1), rakes_2.reshape(-1, 1))).flatten()
    # initialize the average stress tensor array
    avg_stress_tensor = np.zeros((3, 3), dtype=np.float32)
    # initialize posterior covariance matrices
    avg_C_m_posterior = np.zeros((5, 5), dtype=np.float32)
    avg_C_d_posterior = np.zeros((3*n_earthquakes, 3*n_earthquakes), dtype=np.float32)
    # randomly select subsets of nodal planes and invert for the stress tensor
    for n in range(n_random_selections):
        nodal_planes = np.random.randint(0, 2, size=n_earthquakes)
        flat_indexes = np.int32(np.arange(n_earthquakes)*2+nodal_planes)
        selected_strikes = strikes[flat_indexes]
        selected_dips = dips[flat_indexes]
        selected_rakes = rakes[flat_indexes]
        # invert this subset of nodal planes
        if variable_shear:
            # invert for both the stress tensor and values
            # of (normalized) resolved shear stress magnitude
            stress_tensor, C_m_post, C_d_post = \
                    iterative_linear_si(
                            selected_strikes, selected_dips, selected_rakes,
                            max_n_iterations=max_n_iterations,
                            shear_update_atol=shear_update_atol,
                            Tarantola_kwargs=Tarantola_kwargs,
                            return_eigen=False, return_stats=True)
        else:
            # invert only for the stress tensor, assuming
            # constant shear stress on all faults
            stress_tensor, C_m_post, C_d_post = \
                    Michael1984_inversion(
                            selected_strikes, selected_dips, selected_rakes,
                            Tarantola_kwargs=Tarantola_kwargs,
                            return_eigen=False, return_stats=True)
        # add them to the average
        avg_stress_tensor += stress_tensor
        avg_C_m_posterior += C_m_post
        avg_C_d_posterior += C_d_post
    avg_stress_tensor /= float(n_random_selections)
    avg_C_m_posterior /= float(n_random_selections)
    avg_C_d_posterior /= float(n_random_selections)
    principal_stresses, principal_directions = \
            utils_stress.stress_tensor_eigendecomposition(avg_stress_tensor)
    output = (avg_stress_tensor, principal_stresses, principal_directions,)
    if return_stats:
        output = output + (avg_C_m_posterior, avg_C_d_posterior,)
    return output

def inversion_jackknife(jack_strikes, jack_dips, jack_rakes,
                        n_random_selections=1,
                        n_resamplings=100,
                        max_n_iterations=300,
                        shear_update_atol=1.e-5,
                        variable_shear=True,
                        Tarantola_kwargs=None,
                        bootstrap_events=False):
    &#34;&#34;&#34;
    This routine was tailored for one of my application, but it can
    be of interest to others. Each earthquake comes with an ensemble
    of focal mechanism solutions that were obtained by resampling the
    set of seismic stations used in the focal mechanism inversion. The
    resampling was done with the delete-k-jackknife method, hence the
    name of the routine. This routine randomly samples focal mechanisms
    from these ensembles and runs the stress inversion. This is a way
    of propagating the focal mechanism uncertainties into the stress
    inversion. In this routine we do not seek which nodal planes are
    more likely to be the fault planes.

    Parameters
    -----------
    jack_strikes: (n_earthquakes, n_jackknifes) array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    jack_dips: (n_earthquakes, n_jackknifes) array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    jack_rakes: (n_earthquakes, n_jackknifes) array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_random_selections: integer, default to 20
        Number of random selections of subsets of nodal planes on
        which the stress inversion is run. The final stress tensor
        is averaged over the n_random_selections solutions.
    n_resamplings: integer, default to 100
        Number of times the data set is resampled from the ensembles
        of focal mechanism solutions available for each earthquake.
        n_resamplings stress tensors are returned, allowing to 
        estimate uncertainties from the distribution of solutions.
    bootstrap_events: boolean, default to False
        If True, the resampling is also done accross earthquakes,
        following the bootstrapping method.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.

    Returns
    --------
    jack_avg_stress_tensors: (n_resamplings, 3, 3) numpy array
        The inverted stress tensors.
    jack_principal_stresses: (n_resamplings, 3) numpy array
        The three eigenvalues of the stress tensors, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    jack_principal_directions: (n_resamplings, 3, 3) numpy array
        The three eigenvectors of the stress tensors, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i for the b-th resampled data set
        is given by: `principal_directions[b, :, i]`. 
    &#34;&#34;&#34;
    # compute auxiliary planes
    jack_strikes_1, jack_dips_1, jack_rakes_1 = jack_strikes, jack_dips, jack_rakes
    jack_strikes_2, jack_dips_2, jack_rakes_2 = \
            np.vectorize(utils_stress.aux_plane)(jack_strikes_1, jack_dips_1, jack_rakes_1)
    # define shape variables
    n_earthquakes, n_jackknife = jack_strikes_1.shape
    n_planes_per_tp = int(n_jackknife*2)
    # define flat arrays
    jack_strikes = np.hstack((jack_strikes_1[..., np.newaxis], jack_strikes_2[..., np.newaxis])).flatten()
    jack_dips = np.hstack((jack_dips_1[..., np.newaxis], jack_dips_2[..., np.newaxis])).flatten()
    jack_rakes = np.hstack((jack_rakes_1[..., np.newaxis], jack_rakes_2[..., np.newaxis])).flatten()
    # initialize the average stress tensor arrays
    jack_avg_stress_tensors = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    jack_principal_stresses = np.zeros((n_resamplings, 3), dtype=np.float32)
    jack_principal_directions = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    for b in range(n_resamplings):
        bootstrap_fm = np.random.randint(0, n_jackknife, size=n_earthquakes)*2
        if bootstrap_events:
            bootstrap_ev = np.random.choice(np.arange(n_earthquakes), size=n_earthquakes)
        # see inversion_bootstrap for reason for commenting the extra loop
        #for n in range(n_random_selections):
        nodal_planes = np.random.randint(0, 2, size=n_earthquakes)
        if bootstrap_events:
            flat_indexes = np.int32(bootstrap_ev*n_planes_per_tp\
                                  + bootstrap_fm + nodal_planes)
        else:
            flat_indexes = np.int32(np.arange(n_earthquakes)*n_planes_per_tp\
                                  + bootstrap_fm + nodal_planes)
        selected_strikes = jack_strikes[flat_indexes]
        selected_dips = jack_dips[flat_indexes]
        selected_rakes = jack_rakes[flat_indexes]
        # invert this subset of nodal planes
        if variable_shear:
            # invert for both the stress tensor and values
            # of (normalized) resolved shear stress magnitude
            stress_tensor = \
                    iterative_linear_si(
                            selected_strikes, selected_dips, selected_rakes,
                            max_n_iterations=max_n_iterations,
                            shear_update_atol=shear_update_atol,
                            Tarantola_kwargs=Tarantola_kwargs,
                            return_eigen=False, return_stats=False)
        else:
            # invert only for the stress tensor, assuming
            # constant shear stress on all faults
            stress_tensor = \
                    Michael1984_inversion(
                            selected_strikes, selected_dips, selected_rakes,
                            Tarantola_kwargs=Tarantola_kwargs,
                            return_eigen=False, return_stats=False)
        ## add them to the average
        #jack_avg_stress_tensors[b, ...] += stress_tensor
        #jack_avg_stress_tensors[b, ...] /= float(n_random_selections)
        jack_avg_stress_tensors[b, ...] = stress_tensor
        jack_principal_stresses[b, ...], jack_principal_directions[b, ...] = \
                utils_stress.stress_tensor_eigendecomposition(jack_avg_stress_tensors[b, ...])
    return jack_avg_stress_tensors, jack_principal_stresses, jack_principal_directions

def inversion_bootstrap(strikes, dips, rakes,
                        n_random_selections=1,
                        n_resamplings=100,
                        variable_shear=True,
                        max_n_iterations=300,
                        shear_update_atol=1.e-5,
                        Tarantola_kwargs=None):
    &#34;&#34;&#34;
    Inverts one set of focal mechanisms without seeking which nodal planes
    are more likely to be the fault planes. Performs bootstrap resampling
    of the data set to return an ensemble of solutions.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_random_selections: integer, default to 5
        Number of random selections of subsets of nodal planes on
        which the stress inversion is run. The final stress tensor
        is averaged over the n_random_selections solutions.
    n_resamplings: integer, default to 100
        Number of times the data set is resampled following
        the bootstrapping method (sampling with replacement).
        n_resamplings stress tensors are returned, allowing to 
        estimate uncertainties from the distribution of solutions.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.

    Returns
    --------
    boot_avg_stress_tensors: (n_resamplings, 3, 3) numpy array
        The inverted stress tensors.
    boot_principal_stresses: (n_resamplings, 3) numpy array
        The three eigenvalues of the stress tensors, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    boot_principal_directions: (n_resamplings, 3, 3) numpy array
        The three eigenvectors of the stress tensors, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i for the b-th resampled data set
        is given by: `principal_directions[b, :, i]`.
    &#34;&#34;&#34;

    # compute auxiliary planes
    strikes_1, dips_1, rakes_1 = strikes, dips, rakes
    strikes_2, dips_2, rakes_2 = \
            np.asarray(list(map(utils_stress.aux_plane, strikes, dips, rakes))).T
    # define shape variables
    n_earthquakes = len(strikes_1)
    n_planes_per_ev = 2
    # initialize the average stress tensor arrays
    boot_avg_stress_tensors = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    boot_principal_stresses = np.zeros((n_resamplings, 3), dtype=np.float32)
    boot_principal_directions = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    # flatten strikes/dips/rakes of planes
    strikes = np.stack((strikes_1, strikes_2), axis=1).flatten()
    dips = np.stack((dips_1, dips_2), axis=1).flatten()
    rakes = np.stack((rakes_1, rakes_2), axis=1).flatten()
    for b in range(n_resamplings):
        if b%100 == 0:
            print(f&#39;---------- Bootstrapping {b+1}/{n_resamplings} ----------&#39;)
        bootstrap_set = np.random.choice(
                np.arange(n_earthquakes), replace=True, size=n_earthquakes)
        # I now believe there is no point in adding this extra loop
        # in the bootstrapping method. Averaging only disturbs the 
        # uncertainty estimation
        #for n in range(n_random_selections):
        nodal_planes = np.random.randint(0, 2, size=n_earthquakes)
        flat_indexes = np.int32(bootstrap_set*n_planes_per_ev\
                              + nodal_planes)
        selected_strikes = strikes[flat_indexes]
        selected_dips = dips[flat_indexes]
        selected_rakes = rakes[flat_indexes]
        # invert this subset of nodal planes
        if variable_shear:
            stress_tensor = \
                    iterative_linear_si(selected_strikes,
                                        selected_dips,
                                        selected_rakes,
                                        return_eigen=False,
                                        Tarantola_kwargs=Tarantola_kwargs)
        else:
            stress_tensor = \
                    Michael1984_inversion(selected_strikes,
                                          selected_dips,
                                          selected_rakes,
                                          return_eigen=False,
                                          Tarantola_kwargs=Tarantola_kwargs)
        # uncomment if extra loop (and indent)
        ## add them to the average
        #boot_avg_stress_tensors[b, ...] += stress_tensor
        #boot_avg_stress_tensors[b, ...] /= float(n_random_selections)
        boot_avg_stress_tensors[b, ...] = stress_tensor
        boot_principal_stresses[b, ...], boot_principal_directions[b, ...] = \
                utils_stress.stress_tensor_eigendecomposition(boot_avg_stress_tensors[b, ...])
    return boot_avg_stress_tensors, boot_principal_stresses, boot_principal_directions


# ---------------------------------------------------
#
#   Routines for inversion with instability parameter
#
# ---------------------------------------------------


def inversion_one_set_instability(strikes, dips, rakes,
                                  friction_min=0.1, friction_max=0.8,
                                  friction_step=0.05, n_stress_iter=10,
                                  n_random_selections=20,
                                  stress_tensor_update_atol=1.e-4,
                                  Tarantola_kwargs=None,
                                  max_n_iterations=300,
                                  shear_update_atol=1.e-5,
                                  n_averaging=1,
                                  signed_instability=True,
                                  verbose=True,
                                  variable_shear=True,
                                  return_stats=False,
                                  weighted=False,
                                  plot=False):
    &#34;&#34;&#34;
    Invert one set of focal mechanisms with the instability parameter
    to seek which nodal planes are more likely to be the fault planes
    (cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).
    In general, you can keep the default parameter values.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    friction_min: float, default to 0.1
        Lower bound of explored friction values.
    friction_max: float, default to 0.8
        Upper bound of explored friction values.
    friction_step: float, default to 0.05
        Step employed in the grid search of the friction value
        that maximizes the instability parameter.
    n_stress_iter: integer, default to 10
        Maximum number of iterations to seek for the best fault planes.
        See Beauce et al. 2021 for explanations.
    stress_tensor_update_atol: float, default to 1.e-4
        If the RMS difference of the stress tensors between two
        iterations fall below this threshold, convergence has been reached.
    n_random_selections: integer, default to 20
        Number of random selections of subsets of nodal planes on
        which the stress inversion is run. The final stress tensor
        is averaged over the n_random_selections solutions.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    n_averaging: integer, default to 1
        The inversion can be sensitive to initial conditions. To improve
        reproducibility of the results it is good to repeat the inversion
        several times and average the results. Set `n_averaging` to ~5 if
        you can afford the increase in run time.
    signed_instability: boolean, default to True
        If True, the instability parameter ranges from -1 to +1. Negative
        values mean that the predicted and observed slip have opposite
        directions. If False, the instability parameter is the one
        defined in Vavrycuk 2013, 2014.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    return_stats: boolean, default to True
        If True, the posterior data and model parameter distributions
        estimated from the Tarantola and Valette formula
        (cf. Tarantola_Valette routine).
    weighted: boolean, default to False
        This option is exploratory. If True:
            1) More weight is given to the fault planes that are clearly
               more unstable than their auxiliary counterpart in the
               stress field estimated at iteration t-1
            2) Randomly mixes the set of fault planes at iterations
               t-1 and t, giving larger probability to the planes
               belonging to the set that produced the larger instability.
        This option can be interesting for reaching convergence on
        data sets of bad quality.
    plot: boolean, default to False
        If True, plot the set of nodal planes selected at each iteration,
        and the weight attributed to each of these planes. Can be used
        with `weighted=True` to see if the inversion convergences to a
        well defined set of planes.
    verbose: integer, default to 1
        Level of verbosity.  
        0: No print statements.  
        1: Print whether the algorithm converged.  
        2: Print the stress tensor at the end of each fault plane
           selection iteration.


    Returns
    --------
    full_stress_tensor: (3, 3) numpy array
        The inverted stress tensor.
    optimal_friction: float
        The friction value that maximizes the instability parameter
        found during the grid search.
    principal_stresses: (3,) numpy array
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    principal_directions: (3, 3) numpy array
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
    C_m_posterior: (5, 5) array, optional
        Posterior covariance of the model parameter distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array, optional
        Posterior covariance of the data distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    &#34;&#34;&#34;
    if plot:
        import mplstereonet
        import matplotlib.pyplot as plt
        from matplotlib.colors import Normalize
        from matplotlib.cm import ScalarMappable
        from mpl_toolkits.axes_grid1 import make_axes_locatable
    # compute auxiliary planes
    strikes_1, dips_1, rakes_1 = strikes, dips, rakes
    strikes_2, dips_2, rakes_2 = \
            np.asarray(list(map(utils_stress.aux_plane, strikes, dips, rakes))).T
    # define shape variable
    n_earthquakes = strikes_1.shape[0]
    # define flat arrays
    strikes = np.hstack((strikes_1.reshape(-1, 1), strikes_2.reshape(-1, 1))).flatten()
    dips = np.hstack((dips_1.reshape(-1, 1), dips_2.reshape(-1, 1))).flatten()
    rakes = np.hstack((rakes_1.reshape(-1, 1), rakes_2.reshape(-1, 1))).flatten()
    final_stress_tensor = np.zeros((3, 3), dtype=np.float32)
    for i in range(n_averaging):
        if verbose &gt; 0:
            print(f&#39;-------- {i+1}/{n_averaging} ----------&#39;)
        # The stress inversion is sensitive to initial conditions,
        # which are random, especially when dealing with highly
        # noisy focal mechanisms. Therefore, one can repeat the inversion
        # n_averaging times and average the results.
        # -----------------------------------------
        # initialize the average stress tensor array by repeating the
        # stress inversion on n_random_selections datasets drawn by
        # randomly selecting either of the nodal planes as the fault planes
        avg_stress_tensor = np.zeros((3, 3), dtype=np.float32)
        for n in range(n_random_selections):
            nodal_planes = np.random.randint(0, 2, size=n_earthquakes)
            flat_indexes = np.int32(np.arange(n_earthquakes)*2+nodal_planes)
            selected_strikes = strikes[flat_indexes]
            selected_dips = dips[flat_indexes]
            selected_rakes = rakes[flat_indexes]
            # invert this subset of nodal planes
            if variable_shear:
                stress_tensor = \
                        iterative_linear_si(
                                selected_strikes, selected_dips, selected_rakes,
                                max_n_iterations=200, return_eigen=False,
                                Tarantola_kwargs=Tarantola_kwargs)
            else:
                stress_tensor = \
                        Michael1984_inversion(
                                selected_strikes, selected_dips, selected_rakes,
                                return_eigen=False, Tarantola_kwargs=Tarantola_kwargs)
            # add them to the average
            avg_stress_tensor += stress_tensor
        avg_stress_tensor /= float(n_random_selections)
        principal_stresses, principal_directions = \
                utils_stress.stress_tensor_eigendecomposition(avg_stress_tensor)
        R = utils_stress.R_(principal_stresses)
        if verbose &gt; 0:
            print(&#39;Initial shape ratio: {:.2f}&#39;.format(R))
        # uncomment the following lines if you want the friction parameter
        # to be derived from the initial stress tensor guess
        # (prone to overfitting)
        #friction_coefficient = find_optimal_friction(strikes_1, dips_1, rakes_1,
        #                                             strikes_2, dips_2, rakes_2,
        #                                             principal_directions, R,
        #                                             friction_min=friction_min,
        #                                             friction_max=friction_max,
        #                                             friction_step=friction_step)
        # uncomment the following line if you want to use a fixed friction value
        # I suggest to use 0.6 as it is a reasonable value and this does not
        # greatly influence the results anyway
        friction_coefficient = 0.60
        stress_tensor, C_m_post, C_d_post = _stress_inversion_instability(
                avg_stress_tensor, friction_coefficient,
                strikes_1, dips_1, rakes_1, strikes_2, dips_2, rakes_2,
                n_stress_iter=n_stress_iter, Tarantola_kwargs=Tarantola_kwargs,
                variable_shear=variable_shear, weighted=weighted,
                max_n_iterations=max_n_iterations,
                shear_update_atol=shear_update_atol,
                stress_tensor_update_atol=stress_tensor_update_atol,
                signed_instability=signed_instability,
                verbose=verbose, plot=plot)
        final_stress_tensor += stress_tensor
    final_stress_tensor /= float(n_averaging)
    principal_stresses, principal_directions = \
            utils_stress.stress_tensor_eigendecomposition(final_stress_tensor)
    R = utils_stress.R_(principal_stresses)
    # uncomment if you want to evaluate the friction
    # coefficient that maximizes instability, given
    # the stress tensor that was inverted
    # note: this is certainly a weird computation since we compute
    # the instability parameter to select the fault planes, and
    # then search for the value of friction coefficient that maximizes
    # the instability parameter on this set of fault planes, but this
    # new value would in turn select new fault planes...
    instability, fault_strikes, fault_dips, fault_rakes =\
            compute_instability_parameter(principal_directions, R, friction_coefficient,
                                          strikes_1, dips_1, rakes_1,
                                          strikes_2, dips_2, rakes_2,
                                          return_fault_planes=True,
                                          signed_instability=signed_instability)
    optimal_friction = find_optimal_friction_one_set(
            fault_strikes, fault_dips, fault_rakes,
            principal_directions, R,
            friction_min=friction_min,
            friction_max=friction_max,
            friction_step=friction_step)
    if verbose &gt; 0:
        print(&#39;Final results:&#39;)
        print(&#39;Stress tensor:\n&#39;, final_stress_tensor)
        print(&#39;Shape ratio: {:.2f}&#39;.format(R))
    output = (final_stress_tensor, optimal_friction,\
              principal_stresses, principal_directions,)
    if return_stats:
        output = output + (C_m_post, C_d_post,)
    return output

def inversion_jackknife_instability(principal_directions, R,
                                    jack_strikes, jack_dips, jack_rakes,
                                    friction_coefficient, n_resamplings=100,
                                    n_stress_iter=10,
                                    stress_tensor_update_atol=1.e-4,
                                    Tarantola_kwargs=None,
                                    bootstrap_events=False,
                                    n_earthquakes=None,
                                    variable_shear=True,
                                    max_n_iterations=300,
                                    shear_update_atol=1.e-5,
                                    signed_instability=True,
                                    weighted=False,
                                    parallel=False):
    &#34;&#34;&#34;
    This routine was tailored for one of my application, but it can
    be of interest to others. Each earthquake comes with an ensemble
    of focal mechanism solutions that were obtained by resampling the
    set of seismic stations used in the focal mechanism inversion. The
    resampling was done with the delete-k-jackknife method, hence the
    name of the routine. This routine randomly samples focal mechanisms
    from these ensembles and runs the stress inversion. This is a way
    of propagating the focal mechanism uncertainties into the stress
    inversion. Use the instability parameter to seek which nodal planes
    are more likely to be the fault planes (cf. B. Lund and R. Slunga 1999,
    V. Vavrycuk 2013,2014).  

    Use a previously determined stress tensor (e.g. the output of
    `inversion_one_set_instability`) described by its principal stress
    directions and shape ratio as the prior model in the Tarantola
    and Valette formula. In general, you can keep the default parameter
    values, except for n_resamplings which depends on the time you can 
    afford spending.

    Parameters
    -----------
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
    R: scalar float
        Shape ratio of the reference stress tensor.
    friction_coefficient: scalar float
        Friction value used in the instability parameter. This can be
        the value output by `inversion_one_set_instability`.
    jack_strikes: (n_earthquakes, n_jackknifes) array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    jack_dips: (n_earthquakes, n_jackknifes) array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    jack_rakes: (n_earthquakes, n_jackknifes) array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_stress_iter: integer, default to 10
        Maximum number of iterations to seek for the best fault planes.
        See Beauce et al. 2021 for explanations.
    stress_tensor_update_atol: float, default to 1.e-4
        If the RMS difference of the stress tensors between two
        iterations fall below this threshold, convergence has been reached.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    signed_instability: boolean, default to True
        If True, the instability parameter ranges from -1 to +1. Negative
        values mean that the predicted and observed slip have opposite
        directions. If False, the instability parameter is the one
        defined in Vavrycuk 2013, 2014.
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    bootstrap_events: boolean, default to False
        If True, the resampling is also done accross earthquakes,
        following the bootstrapping method.
    weighted: boolean, default to False
        This option is exploratory. If True:  
            1) More weight is given to the fault planes that are clearly
               more unstable than their auxiliary counterpart in the
               stress field estimated at iteration t-1  
            2) Randomly mixes the set of fault planes at iterations
               t-1 and t, giving larger probability to the planes
               belonging to the set that produced the larger instability.  
        This option can be interesting for reaching convergence on
        data sets of bad quality.
    parallel: boolean, default to False
        If True, resampling is run in parallel.

    Returns
    --------
    jack_avg_stress_tensors: (n_resamplings, 3, 3) numpy array
        The inverted stress tensors.
    jack_principal_stresses: (n_resamplings, 3) numpy array
        The three eigenvalues of the stress tensors, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    jack_principal_directions: (n_resamplings, 3, 3) numpy array
        The three eigenvectors of the stress tensors, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i for the b-th resampled data set
        is given by: `principal_directions[b, :, i]`.
    &#34;&#34;&#34;
    # compute auxiliary planes
    jack_strikes_1, jack_dips_1, jack_rakes_1 = jack_strikes, jack_dips, jack_rakes
    jack_strikes_2, jack_dips_2, jack_rakes_2 = \
            np.vectorize(utils_stress.aux_plane)(jack_strikes_1, jack_dips_1, jack_rakes_1)
    # make a copy of Tarantola_kwargs, on which this function will work
    Tarantola_kwargs_ = Tarantola_kwargs.copy()
    # build reduced stress tensor from principal directions and shape ratio
    stress_tensor_main = utils_stress.reduced_stress_tensor(principal_directions, R)
    sigma_main = np.array([stress_tensor_main[0,0], stress_tensor_main[0,1],
                           stress_tensor_main[0,2], stress_tensor_main[1,1],
                           stress_tensor_main[1,2]]).reshape(-1, 1)
    # define shape variables
    n_earthquakes, n_jackknife = jack_strikes_1.shape
    # initialize the average stress tensor arrays
    jack_stress_tensors = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    jack_principal_stresses = np.zeros((n_resamplings, 3), dtype=np.float32)
    jack_principal_directions = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    jack_strikes_1, jack_dips_1, jack_rakes_1 = \
            jack_strikes_1.flatten(), jack_dips_1.flatten(), jack_rakes_1.flatten()
    jack_strikes_2, jack_dips_2, jack_rakes_2 = \
            jack_strikes_2.flatten(), jack_dips_2.flatten(), jack_rakes_2.flatten()
    #n_jackknife = None if bootstrap_events else n_jackknife
    n_earthquakes = n_earthquakes if bootstrap_events else None
    _bootstrap_solution_p = partial(_bootstrap_solution,
            strikes_1=jack_strikes_1, dips_1=jack_dips_1, rakes_1=jack_rakes_1,
            strikes_2=jack_strikes_2, dips_2=jack_dips_2, rakes_2=jack_rakes_2,
            stress_tensor_main=stress_tensor_main,
            friction_coefficient=friction_coefficient,
            stress_tensor_update_atol=stress_tensor_update_atol,
            n_stress_iter=n_stress_iter, Tarantola_kwargs=Tarantola_kwargs,
            variable_shear=variable_shear,
            weighted=weighted, max_n_iterations=max_n_iterations,
            shear_update_atol=shear_update_atol,
            n_jackknife=n_jackknife, n_earthquakes=n_earthquakes,
            signed_instability=signed_instability)
    if parallel:
        import concurrent.futures
        with concurrent.futures.ProcessPoolExecutor() as executor:
            results = list(executor.map(_bootstrap_solution_p, range(n_resamplings)))
        jack_stress_tensors = np.asarray([results[b][0] for b in range(n_resamplings)])
        jack_principal_stresses = np.asarray([results[b][1] for b in range(n_resamplings)])
        jack_principal_directions = np.asarray([results[b][2] for b in range(n_resamplings)])
    else:
        for b in range(n_resamplings):
            if b%100 == 0:
                print(f&#39;---------- Bootstrapping {b+1}/{n_resamplings} ----------&#39;)
            jack_stress_tensors[b, ...],\
                    jack_principal_stresses[b, ...],\
                    jack_principal_directions[b, ...] = _bootstrap_solution_p(b)
    return jack_stress_tensors, jack_principal_stresses, jack_principal_directions

def inversion_bootstrap_instability(principal_directions, R,
                                    strikes, dips, rakes,
                                    friction_coefficient, n_resamplings=100,
                                    n_stress_iter=10,
                                    stress_tensor_update_atol=1.e-5,
                                    Tarantola_kwargs=None,
                                    variable_shear=True,
                                    max_n_iterations=300,
                                    shear_update_atol=1.e-5,
                                    signed_instability=True,
                                    weighted=False,
                                    parallel=False):
    &#34;&#34;&#34;
    Invert one set of focal mechanisms with the instability parameter
    to seek which nodal planes are more likely to be the fault planes
    (cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).
    Performs bootstrap resampling of the data set to return an
    ensemble of solutions.  

    Use a previously determined stress tensor (e.g. the output of
    `inversion_one_set_instability`) described by its principal stress
    directions and shape ratio as the prior model in the Tarantola
    and Valette formula. In general, you can keep the default parameter
    values, except for n_resamplings which depends on the time you can 
    afford spending.

    Parameters
    -----------
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`. 
    R: float
        Shape ratio of the reference stress tensor.
    friction_coefficient: float
        Value of the friction coefficient used in the instability parameter.
        This can be the value output by `inversion_one_set_instability`.
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_stress_iter: integer, default to 10
        Maximum number of iterations to seek for the best fault planes.
        See Beauce et al. 2021 for explanations.
    stress_tensor_update_atol: float, default to 1.e-4
        If the RMS difference of the stress tensors between two
        iterations fall below this threshold, convergence has been reached.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    signed_instability: boolean, default to True
        If True, the instability parameter ranges from -1 to +1. Negative
        values mean that the predicted and observed slip have opposite
        directions. If False, the instability parameter is the one
        defined in Vavrycuk 2013, 2014.
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    weighted: boolean, default to False
        This option is exploratory. If True:  
            1) More weight is given to the fault planes that are clearly
               more unstable than their auxiliary counterpart in the
               stress field estimated at iteration t-1  
            2) Randomly mixes the set of fault planes at iterations
               t-1 and t, giving larger probability to the planes
               belonging to the set that produced the larger instability.  
        This option can be interesting for reaching convergence on
        data sets of bad quality.
    parallel: boolean, default to False
        If True, resampling is run in parallel.

    Returns
    --------
    boot_avg_stress_tensors: (n_resamplings, 3, 3) numpy array
        The inverted stress tensors.
    boot_principal_stresses: (n_resamplings, 3) numpy array
        The three eigenvalues of the stress tensors, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    boot_principal_directions: (n_resamplings, 3, 3) numpy array
        The three eigenvectors of the stress tensors, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i for the b-th resampled data set
        is given by: `principal_directions[b, :, i]`.
    &#34;&#34;&#34;
    # compute auxiliary planes
    strikes_1, dips_1, rakes_1 = strikes, dips, rakes
    strikes_2, dips_2, rakes_2 = \
            np.asarray(list(map(utils_stress.aux_plane, strikes, dips, rakes))).T
    # build reduced stress tensor from principal directions and shape ratio
    stress_tensor_main = utils_stress.reduced_stress_tensor(principal_directions, R)
    sigma_main = np.array([stress_tensor_main[0,0], stress_tensor_main[0,1], stress_tensor_main[0,2],
                           stress_tensor_main[1,1], stress_tensor_main[1,2]]).reshape(-1, 1)
    if Tarantola_kwargs is None:
        Tarantola_kwargs = {}
    Tarantola_kwargs[&#39;m_prior&#39;] = sigma_main.copy()
    # define shape variables
    n_earthquakes = len(strikes_1)
    # initialize the average stress tensor arrays
    boot_stress_tensors = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    boot_principal_stresses = np.zeros((n_resamplings, 3), dtype=np.float32)
    boot_principal_directions = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    _bootstrap_solution_p = partial(_bootstrap_solution,
            strikes_1=strikes_1, dips_1=dips_1, rakes_1=rakes_1,
            strikes_2=strikes_2, dips_2=dips_2, rakes_2=rakes_2,
            stress_tensor_main=stress_tensor_main,
            friction_coefficient=friction_coefficient,
            stress_tensor_update_atol=stress_tensor_update_atol,
            n_stress_iter=n_stress_iter, Tarantola_kwargs=Tarantola_kwargs,
            variable_shear=variable_shear,
            weighted=weighted, max_n_iterations=max_n_iterations,
            shear_update_atol=shear_update_atol,
            signed_instability=signed_instability)
    if parallel:
        import concurrent.futures
        with concurrent.futures.ProcessPoolExecutor() as executor:
            results = list(executor.map(_bootstrap_solution_p, range(n_resamplings)))
        boot_stress_tensors = np.asarray([results[b][0] for b in range(n_resamplings)])
        boot_principal_stresses = np.asarray([results[b][1] for b in range(n_resamplings)])
        boot_principal_directions = np.asarray([results[b][2] for b in range(n_resamplings)])
    else:
        for b in range(n_resamplings):
            if b%100 == 0:
                print(f&#39;---------- Bootstrapping {b+1}/{n_resamplings} ----------&#39;)
            boot_stress_tensors[b, ...], \
                    boot_principal_stresses[b, ...],\
                    boot_principal_directions[b, ...] = _bootstrap_solution_p(b)
    return boot_stress_tensors, boot_principal_stresses, boot_principal_directions

def _bootstrap_solution(_, strikes_1, dips_1, rakes_1,
                        strikes_2, dips_2, rakes_2,
                        stress_tensor_main, friction_coefficient,
                        stress_tensor_update_atol, n_stress_iter,
                        Tarantola_kwargs, variable_shear,
                        weighted, max_n_iterations, shear_update_atol,
                        n_jackknife=None, n_earthquakes=None, signed_instability=True):
    &#34;&#34;&#34; Used to parallelize resampling.  
    
    Should not be used directly. If `n_jackknife` is provided, this function
    assumes that strikes, dips, and rakes are given in the &#34;jackknife&#34; format,
    where blocks of `n_jackknifes` contiguous samples are for `n_jackknifes`
    possible solutions of the *same* focal mechanism. Resampling is then
    performed only among the jackknife solutions, and each earthquake still
    appears one time, as in the original data set. Therefore, this resampling
    method only propagates the uncertainties in the focal mechanisms, and not
    the uncertainties related to spatial sampling.
    &#34;&#34;&#34;
    if n_jackknife is None and n_earthquakes is None:
        bootstrap_set = np.random.choice(
                np.arange(len(strikes_1)), replace=True, size=len(strikes_1))
    elif n_earthquakes is None:
        # default jackknife mode:
        # strikes_1/dips_1/etc... come with contiguous blocks
        # of n_jackknife focal mechanisms that are different
        # possible solutions of the same earthquake, and we
        # only sample from these without sampling with replacement
        # among earthquakes
        n_earthquakes = len(strikes_1)//n_jackknife
        bootstrap_set = np.arange(n_earthquakes)*n_jackknife\
                + np.random.randint(0, n_jackknife, size=n_earthquakes)
    else:
        # n_earthquakes is specified, bootstrap on jackknife solutions
        # AND on events
        bootstrap_set = np.random.choice(
                np.arange(n_earthquakes), replace=True, size=n_earthquakes)*n_jackknife\
                + np.random.randint(0, n_jackknife, size=n_earthquakes)
    strikes_1_b, dips_1_b, rakes_1_b = \
            strikes_1[bootstrap_set], dips_1[bootstrap_set], rakes_1[bootstrap_set]
    strikes_2_b, dips_2_b, rakes_2_b = \
            strikes_2[bootstrap_set], dips_2[bootstrap_set], rakes_2[bootstrap_set]
    stress_tensor, C_m_post, C_d_post = _stress_inversion_instability(
            stress_tensor_main, friction_coefficient,
            strikes_1_b, dips_1_b, rakes_1_b, strikes_2_b, dips_2_b, rakes_2_b,
            n_stress_iter=n_stress_iter, Tarantola_kwargs=Tarantola_kwargs,
            variable_shear=variable_shear,
            weighted=weighted, max_n_iterations=max_n_iterations,
            shear_update_atol=shear_update_atol,
            stress_tensor_update_atol=stress_tensor_update_atol,
            signed_instability=signed_instability, verbose=0, plot=False)
    return (stress_tensor,) + utils_stress.stress_tensor_eigendecomposition(stress_tensor) 


def _stress_inversion_instability(stress_tensor0, friction_coefficient,
                                  strikes_1, dips_1, rakes_1,
                                  strikes_2, dips_2, rakes_2,
                                  **kwargs):
    &#34;&#34;&#34;
    Core wrapper function to run the iterative linear stress inversion
    whether shear stress is assumed to be constant (i.e. equivalent to
    the method described in Vavrycuk 2013, 2014) or not (the method described
    in Beauce et al. 2021). This function should be not called directly by
    the user.
    &#34;&#34;&#34;
    Tarantola_kwargs = kwargs.get(&#39;Tarantola_kwargs&#39;, None)
    n_stress_iter = kwargs.get(&#39;n_stress_iter&#39;, 10)
    weighted = kwargs.get(&#39;weighted&#39;, False)
    variable_shear = kwargs.get(&#39;variable_shear&#39;, True)
    max_n_iterations = kwargs.get(&#39;max_n_iterations&#39;, 500)
    shear_update_atol = kwargs.get(&#39;shear_update_atol&#39;, 1.e-7)
    signed_instability = kwargs.get(&#39;signed_instability&#39;, True)
    stress_tensor_update_atol = kwargs.get(&#39;stress_tensor_update_atol&#39;, 1.e-4)
    verbose = kwargs.get(&#39;verbose&#39;, 1)
    plot = kwargs.get(&#39;plot&#39;, False)
    if Tarantola_kwargs is None:
        Tarantola_kwargs = {}
    else:
        # make copy to not overwrite the input dictionary
        Tarantola_kwargs = Tarantola_kwargs.copy()
    # ------------------------------
    #   Start instability criterion
    # ------------------------------
    # initialize variables
    n_earthquakes = len(strikes_1)
    stress_tensor = stress_tensor0
    principal_stresses, principal_directions = \
            utils_stress.stress_tensor_eigendecomposition(stress_tensor0)
    stress_diff = 0.
    total_instability = 0.
    total_differential_instability = -100.
    instability = 0.1*np.ones((n_earthquakes, 2), dtype=np.float32)
    residuals = np.finfo(np.float32).max
    best_residuals = np.finfo(np.float32).max
    fault_strikes, fault_dips, fault_rakes = [np.zeros(n_earthquakes) for i in range(3)]
    C_m_post = np.zeros((5, 5), dtype=np.float32)
    C_d_post = np.zeros((3*n_earthquakes, 3*n_earthquakes), dtype=np.float32)
    weights = np.ones(3*n_earthquakes, dtype=np.float32)
    # start the nodal plane selection loop
    for n in range(n_stress_iter):
        R = utils_stress.R_(principal_stresses)
        # ------------
        # copy variables from previous iteration
        stress_tensor0 = stress_tensor.copy()
        total_instability0 = float(total_instability)
        total_differential_instability0 = float(total_differential_instability)
        instability0 = instability.copy()
        stress_diff0 = float(stress_diff)
        residuals0 = float(residuals)
        fault_strikes0, fault_dips0, fault_rakes0 = \
                fault_strikes.copy(), fault_dips.copy(), fault_rakes.copy()
        # -----------
        instability, fault_strikes, fault_dips, fault_rakes =\
                compute_instability_parameter(principal_directions, R, friction_coefficient,
                                              strikes_1, dips_1, rakes_1,
                                              strikes_2, dips_2, rakes_2,
                                              signed_instability=signed_instability,
                                              return_fault_planes=True)
        total_instability = np.mean(np.max(instability, axis=-1))
        total_differential_instability = np.mean(np.abs(instability[:, 1] - instability[:, 0]))
        if weighted:
            # decide to keep or not previous fault planes probabilisticly based
            # on the instability values
            # sigmoid probability:
            X = total_differential_instability0/total_differential_instability - 1.
            p0 = 1./(1. + np.exp(-X))
            #print(&#39;Probability: {:.3f} (before: {:.2f}, now: {:.2f})&#39;.format(p0, total_differential_instability0, total_differential_instability))
            R = np.random.random(n_earthquakes)
            fault_strikes = np.float32([fault_strikes0[i] if R[i] &lt; p0 else fault_strikes[i] for i in range(n_earthquakes)])
            fault_dips = np.float32([fault_dips0[i] if R[i] &lt; p0 else fault_dips[i] for i in range(n_earthquakes)])
            fault_rakes = np.float32([fault_rakes0[i] if R[i] &lt; p0 else fault_rakes[i] for i in range(n_earthquakes)])
            instability = np.float32([instability0[i] if R[i] &lt; p0 else instability[i] for i in range(n_earthquakes)])
            # give more weights to focal mechanisms where the most unstable
            # nodal plane is well defined, i.e. has an instability parameter
            # clearly larger than the other plane
            weights = np.repeat(np.abs(instability[:, 1] - instability[:, 0]), 3)
            if weights.sum() == 0.:
                weights = np.ones(3*n_earthquakes, dtype=np.float32)
            # normalize the weights such that 1/max(weights) = 0.1 (which is
            # the standard deviation I would give to a good slip measurement)
            weights /= np.median(weights)
            weights = np.clip(weights, 1./np.sqrt(3.), np.sqrt(3.))
            weights = 10.*weights**2
        else:
            weights = np.ones(3*n_earthquakes, dtype=np.float32)
        p = (weights/np.sum(weights))[::3]
        if &#39;C_d&#39; in Tarantola_kwargs:
            # update existing covariance matrix
            Tarantola_kwargs[&#39;C_d&#39;] = Tarantola_kwargs[&#39;C_d&#39;] + np.diag(1./weights)
        elif &#39;C_d&#39; in Tarantola_kwargs and weighted:
            # keep previous weights in memory
            Tarantola_kwargs[&#39;C_d&#39;] = 0.7*Tarantola_kwargs[&#39;C_d&#39;] + 0.3*np.diag(1./weights)
        else:
            Tarantola_kwargs[&#39;C_d&#39;] = np.diag(1./weights)
        Tarantola_kwargs[&#39;C_d_inv&#39;] = np.linalg.inv(Tarantola_kwargs[&#39;C_d&#39;])
        if variable_shear:
            stress_tensor, _, principal_stresses, principal_directions, C_m_post, C_d_post =\
                    iterative_linear_si(
                            fault_strikes, fault_dips, fault_rakes, return_eigen=True,
                            return_stats=True, Tarantola_kwargs=Tarantola_kwargs,
                            max_n_iterations=max_n_iterations,
                            shear_update_atol=shear_update_atol)
        else:
            stress_tensor, principal_stresses, principal_directions, C_m_post, C_d_post =\
                    Michael1984_inversion(
                            fault_strikes, fault_dips, fault_rakes, return_eigen=True,
                            return_stats=True, Tarantola_kwargs=Tarantola_kwargs)
        R = utils_stress.R_(principal_stresses)
        stress_diff = np.sum((stress_tensor-stress_tensor0)**2)
        # compute residuals
        n_, d_ = utils_stress.normal_slip_vectors(fault_strikes, fault_dips, fault_rakes)
        _, _, shear_traction = utils_stress.compute_traction(stress_tensor, n_.T)
        shear_mag = np.sqrt(np.sum(shear_traction**2, axis=-1))
        res = (shear_traction - shear_mag[:, np.newaxis]*d_.T).reshape(-1, 1)
        residuals = (res.T@Tarantola_kwargs[&#39;C_d_inv&#39;]@res)[0,0]\
                   /np.sum(np.diag(Tarantola_kwargs[&#39;C_d_inv&#39;]))
        if residuals &lt; best_residuals:
            Tarantola_kwargs[&#39;m_prior&#39;] = \
                    np.array([stress_tensor[0,0], stress_tensor[0,1], stress_tensor[0,2],
                              stress_tensor[1,1], stress_tensor[1,2]]).reshape(-1, 1)
            # store best results
            best_residuals = float(residuals)
            best_stress_tensor = stress_tensor.copy()
            best_C_m_post = C_m_post.copy()
            best_C_d_post = C_d_post.copy()
            # uncomment the following lines if you want to update the
            # friction parameter
            #optimal_friction = find_optimal_friction_one_set(
            #        fault_strikes, fault_dips, fault_rakes,
            #        principal_directions, R,
            #        friction_min=friction_min,
            #        friction_max=friction_max,
            #        friction_step=friction_step)
        if plot:
            fig = plt.figure(&#39;iteration_{:d}&#39;.format(n))
            ax1 = fig.add_subplot(2, 2, 1, projection=&#39;stereonet&#39;)
            ax1.set_title(&#39;R={:.2f}&#39;.format(R))
            markers = [&#39;o&#39;, &#39;s&#39;, &#39;v&#39;]
            for k in range(3):
                az, pl = utils_stress.get_bearing_plunge(
                        principal_directions[:, k])
                ax1.line(pl, az, marker=markers[k], markeredgecolor=&#39;k&#39;,
                         color=f&#39;C{k}&#39;, markersize=15)
            ax2 = fig.add_subplot(2, 2, 2, projection=&#39;stereonet&#39;)
            cNorm = Normalize(vmin=0., vmax=p.max())
            scalar_map = ScalarMappable(norm=cNorm, cmap=&#39;cividis&#39;)
            #ax2.plane(fault_strikes, fault_dips, color=scalar_map.to_rgba(p), lw=2.0)
            for ii in range(len(fault_strikes)):
                ax2.plane(
                        fault_strikes[ii], fault_dips[ii],
                        color=scalar_map.to_rgba(p[ii]), lw=2.0)
            divider = make_axes_locatable(ax2)
            cax = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.08, axes_class=plt.Axes)
            plt.colorbar(scalar_map, cax=cax, label=&#39;Weight&#39;, orientation=&#39;vertical&#39;)
            plt.show(block=True)
        if verbose == 2:
            print(&#39;----------&#39;)
            print(&#39;Stress tensor difference at iteration {:d}: {}.&#39;.
                    format(n, stress_diff))
            #print(stress_tensor)
            print(&#39;R={:.2f}, friction={:.2f}&#39;.format(R, friction_coefficient))
            print(&#39;Total instability: {:.2f}/Total differential instability: {:.2f}&#39;.
                    format(total_instability, total_differential_instability))
            print(&#39;Average angle: {:.2f}&#39;.format(
                utils_stress.mean_angular_residual(
                    stress_tensor, fault_strikes, fault_dips, fault_rakes)))
            print(&#39;Squared residuals: {:.2e}&#39;.format(residuals))
        if stress_diff &lt; stress_tensor_update_atol:
            # stop stress instability loop
            break
    if stress_diff &gt;= stress_tensor_update_atol:
        # did not convergence, get results from
        # best stress tensor
        stress_tensor = best_stress_tensor
        C_m_post = best_C_m_post
        C_d_post = best_C_d_post
        if verbose &gt; 0:
            principal_stresses, principal_directions = \
                    utils_stress.stress_tensor_eigendecomposition(stress_tensor)
            R = utils_stress.R_(principal_stresses)
            print(&#39;Did not converge, return best (R={:.2f})&#39;.format(R))
    return stress_tensor, C_m_post, C_d_post


# ---------------------------------------------------
#
#          Routines for instability criterion
#
# ---------------------------------------------------

def find_optimal_friction(strikes_1, dips_1, rakes_1,
                          strikes_2, dips_2, rakes_2,
                          principal_directions, R,
                          friction_min=0.1,
                          friction_max=0.8,
                          friction_step=0.05,
                          signed_instability=True):
    &#34;&#34;&#34;
    Find the friction that maximizes the instability parameter I
    based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.

    Parameters
    -----------
    strikes_1: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_1: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_1: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    strikes_2: list or array, float
        The strike of nodal planes 2, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_2: list or array, float
        The dip of nodal planes 2, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_2: list or array, float
        The rake of nodal planes 2, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
    R: float
        Shape ratio of the reference stress tensor.
    friction_min: float, default to 0.1
        Lower bound of explored friction values.
    friction_max: float, default to 0.8
        Upper bound of explored friction values.
    friction_step: float, default to 0.05
        Step employed in the grid search of the friction value
        that maximizes the instability parameter.

    Returns
    --------
    optimal_friction: float
        The friction value that maximizes the mean instability parameter.
    &#34;&#34;&#34;
    friction = np.arange(friction_min, friction_max+friction_step, friction_step)
    n_fric = len(friction)
    I = np.zeros(n_fric, dtype=np.float32)
    for i, fric in enumerate(friction):
        I_ = compute_instability_parameter(
                   principal_directions, R, fric,
                   strikes_1, dips_1, rakes_1,
                   strikes_2, dips_2, rakes_2,
                   signed_instability=signed_instability)
        I[i] = np.sum(np.max(I_, axis=-1))
    optimal_friction = friction[I.argmax()]
    return optimal_friction

def find_optimal_friction_one_set(strikes_1, dips_1, rakes_1,
                                  principal_directions, R,
                                  friction_min=0.2, friction_max=0.8, friction_step=0.05,
                                  signed_instability=True):
    &#34;&#34;&#34;
    Find the friction that maximizes the instability parameter I
    based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.

    Parameters
    -----------
    strikes_1: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_1: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_1: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
    R: float
        Shape ratio of the reference stress tensor.
    friction_min: float, default to 0.1
        Lower bound of explored friction values.
    friction_max: float, default to 0.8
        Upper bound of explored friction values.
    friction_step: float, default to 0.05
        Step employed in the grid search of the friction value
        that maximizes the instability parameter.

    Returns
    --------
    optimal_friction: float
        The friction value that maximizes the mean instability parameter.
    &#34;&#34;&#34;

    # fake nodal planes #2
    strikes_2, dips_2, rakes_2 = [np.zeros(len(strikes_1)) for i in range(3)]
    friction = np.arange(friction_min, friction_max+friction_step, friction_step)
    n_fric = len(friction)
    I = np.zeros(n_fric, dtype=np.float32)
    for i, fric in enumerate(friction):
        I_ = compute_instability_parameter(
                   principal_directions, R, fric,
                   strikes_1, dips_1, rakes_1,
                   strikes_2, dips_2, rakes_2,
                   signed_instability=signed_instability)
        # only look at instability on nodal planes #1
        I[i] = np.sum(I_[:, 0])
    optimal_friction = friction[I.argmax()]
    return optimal_friction

def compute_instability_parameter(principal_directions, R, friction,
                                  strike_1, dip_1, rake_1,
                                  strike_2, dip_2, rake_2,
                                  return_fault_planes=False,
                                  signed_instability=True):
    &#34;&#34;&#34;
    Compute the instability parameter as introduced by Lund and Slunga 1999,
    re-used by Vavrycuk 2013-2014 and modified by Beauce 2021.
    For a given stress field characterized by the principal stress
    directions and shape ratio R=(sig1-sig2)/(sig1-sig3), and for
    a given rock friction, this routine computes an instability
    parameter based on the Mohr-Coulomb failure criterion to determine
    which of the two nodal planes of a focal mechanism solution
    is more likely to be the fault plane.
    Beauce 2021 includes the sign of the dot product between
    the shear stress and the slip vector on the fault. This instability
    ranges from -1 to +1, instead of from 0 to +1.

    Parameters
    -----------
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: principal_directions[:, i] 
    R: float
        Shape ratio of the reference stress tensor.
    strikes_1: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_1: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_1: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    strikes_2: list or array, float
        The strike of nodal planes 2, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_2: list or array, float
        The dip of nodal planes 2, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_2: list or array, float
        The rake of nodal planes 2, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    return_fault_planes: boolean, default to False
        If True, return the strikes, dips, rakes of the selected
        fault planes.

    Returns
    --------
    instability_parameter: (n_earthquakes, 2) array
        The instability parameter as defined in Beauce 2021 for the two
        nodal planes of each focal mechanism datum.
    strikes: list or array, float, optional
        Strikes of the fault planes with largest instability.
        Only provided if `return_fault_planes=True`.
    dips: list or array, float, optional
        Dips of the fault planes with largest instability.
        Only provided if `return_fault_planes=True`.
    rakes: list or array, float, optional
        Rakes of the fault planes with largest instability.
        Only provided if `return_fault_planes=True`.
    &#34;&#34;&#34;
    # the calculation is done in the eigenbasis, therefore
    # we need to project the normal vectors onto the eigenbasis
    n_earthquakes = len(strike_1)
    n_1 = np.zeros((n_earthquakes, 3), dtype=np.float32)
    n_2 = np.zeros((n_earthquakes, 3), dtype=np.float32)
    d_1 = np.zeros((n_earthquakes, 3), dtype=np.float32)
    d_2 = np.zeros((n_earthquakes, 3), dtype=np.float32)
    # compute the normals of the two nodal planes
    for i in range(n_earthquakes):
        n_1[i, :], d_1[i, :] = utils_stress.normal_slip_vectors(
                strike_1[i], dip_1[i], rake_1[i], direction=&#39;inward&#39;)
        n_2[i, :], d_2[i, :] = utils_stress.normal_slip_vectors(
                strike_2[i], dip_2[i], rake_2[i], direction=&#39;inward&#39;)
    # project the normals onto the eigenbasis
    n_1 = np.dot(n_1, principal_directions)
    n_2 = np.dot(n_2, principal_directions)
    d_1 = np.dot(d_1, principal_directions)
    d_2 = np.dot(d_2, principal_directions)
    # when parameterazing the reduced stress tensor as:
    # sigma_1 = -1, sigma_2 = 2R-1 and sigma_3 = +1,
    # (CONVENTION: TENSION IS POSITIVE)
    # the critical shear and normal stresses are:
    sig1 = -1.
    sig2 = 2.*R-1.
    sig3 = +1.
    tau_c = 1./np.sqrt(1.+friction**2)
    sig_c = friction/np.sqrt(1.+friction**2)
    #print(sig1, sig2, sig3, tau_c, sig_c)
    # and the shear and normal stresses on each fault are:
    normal_1 = sig1*n_1[:, 0]**2 + sig2*n_1[:, 1]**2 + sig3*n_1[:, 2]**2
    shear_1 = np.sqrt(sig1**2*n_1[:, 0]**2 + sig2**2*n_1[:, 1]**2 + sig3**2*n_1[:, 2]**2 - normal_1**2) 

    normal_2 = sig1*n_2[:, 0]**2 + sig2*n_2[:, 1]**2 + sig3*n_2[:, 2]**2
    shear_2 = np.sqrt(sig1**2*n_2[:, 0]**2 + sig2**2*n_2[:, 1]**2 + sig3**2*n_2[:, 2]**2 - normal_2**2) 
    # combine all of them in the definition of the instability parameter I
    Ic = (tau_c - friction*(sig1-sig_c))
    I_1 = (shear_1 - friction*(sig1-normal_1))/Ic 
    I_2 = (shear_2 - friction*(sig1-normal_2))/Ic
    # my addition: add the sign of the shear-slip dot product
    #stress_tensor = np.dot(principal_directions, np.dot(np.diag([sig1, sig2, sig3]), principal_directions.T))
    stress_tensor = np.diag([sig1, sig2, sig3])
    traction_1_vec = np.dot(stress_tensor, n_1.T).T 
    traction_2_vec = np.dot(stress_tensor, n_2.T).T
    normal_1_vec = np.sum(traction_1_vec*n_1, axis=-1)[:, np.newaxis]*n_1
    normal_2_vec = np.sum(traction_2_vec*n_2, axis=-1)[:, np.newaxis]*n_2
    shear_1_vec = traction_1_vec - normal_1_vec
    shear_2_vec = traction_2_vec - normal_2_vec
    sign_dot_1 = np.sign(np.sum(shear_1_vec*d_1, axis=-1))
    sign_dot_2 = np.sign(np.sum(shear_2_vec*d_2, axis=-1))
    #print(sign_dot_1)
    if signed_instability:
        # multiplying the instability parameter by the sign of the
        # dot product between shear direction and slip direction is
        # the difference with the instability parameter defined in Vavrycuk 2013
        I_1 *= sign_dot_1
        I_2 *= sign_dot_2

    if return_fault_planes:
        strikes = np.zeros(n_earthquakes, dtype=np.float32)
        dips = np.zeros(n_earthquakes, dtype=np.float32)
        rakes = np.zeros(n_earthquakes, dtype=np.float32)
        mask_1 = I_1 &gt;= I_2
        strikes[mask_1] = strike_1[mask_1]
        dips[mask_1] = dip_1[mask_1]
        rakes[mask_1] = rake_1[mask_1]
        mask_2 = ~mask_1
        strikes[mask_2] = strike_2[mask_2]
        dips[mask_2] = dip_2[mask_2]
        rakes[mask_2] = rake_2[mask_2]
        return np.column_stack((I_1, I_2)), strikes, dips, rakes
    else:
        return np.column_stack((I_1, I_2))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ILSI.ilsi.Michael1984_inversion"><code class="name flex">
<span>def <span class="ident">Michael1984_inversion</span></span>(<span>strikes, dips, rakes, Tarantola_kwargs=None, return_eigen=True, return_stats=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear inversion described in Michael 1984.
</p>
<p>This method assumes:<br>
- The tectonic stress field is uniform.<br>
- Wallace-Bott hypothesis: The slip vector points in the same
direction as shear stress on the fault.<br>
- The resolved shear stress magnitude is constant on
all faults.<br>
The parameters we invert for are the directions of the three
principal stresses and the shape ratio. Because this inversion does not
aim at infering the absolute stress values, we only consider the
deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot
determine the norm of the stress tensor, therefore sum sigma**2 = 1.
Each iteration of this inversion scheme is a linear inversion.
N.B.: This routine is written assuming outward footwall normals and slip
vectors of the hanging wall w.r.t. the footwall. Therefore, the stress
tensor sign convention is compression negative.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strikes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>Tarantola_kwargs</code></strong> :&ensp;<code>Dictionary</code>, default <code>to None</code></dt>
<dd>If not None, should contain key word arguments
for the Tarantola and Valette inversion.</dd>
<dt><strong><code>return_eigen</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, returns the eigendecomposition of the inverted
stress tensor in addition to returning the stress tensor.</dd>
<dt><strong><code>return_stats</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, the posterior data and model parameter distributions
estimated from the Tarantola and Valette formula
(cf. Tarantola_Valette routine).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>full_stress_tensor</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>The inverted stress tensor.</dd>
<dt><strong><code>principal_stresses</code></strong> :&ensp;<code>(3,) numpy array</code>, optional</dt>
<dd>The three eigenvalues of the stress tensor, ordered
from most compressive (sigma1) to least compressive (sigma3).
Only provided if <code>return_eigen</code> is True.</dd>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) numpy array</code>, optional</dt>
<dd>The three eigenvectors of the stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.
Only provided if <code>return_eigen</code> is True.</dd>
<dt><strong><code>C_m_posterior</code></strong> :&ensp;<code>(5, 5) array</code>, optional</dt>
<dd>Posterior covariance of the model parameter distribution
estimated from the Tarantola and Valette formula.
Only provided if <code>return_stats</code> is True.</dd>
<dt><strong><code>C_d_posterior</code></strong> :&ensp;<code>(3 x n_earthquakes, 3 x n_earthquakes) array</code>, optional</dt>
<dd>Posterior covariance of the data distribution
estimated from the Tarantola and Valette formula.
Only provided if <code>return_stats</code> is True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Michael1984_inversion(strikes, dips, rakes,
                          Tarantola_kwargs=None,
                          return_eigen=True,
                          return_stats=False):
    &#34;&#34;&#34;
    Linear inversion described in Michael 1984.  

    This method assumes:  
        - The tectonic stress field is uniform.  
        - Wallace-Bott hypothesis: The slip vector points in the same
          direction as shear stress on the fault.  
        - The resolved shear stress magnitude is constant on
          all faults.  
    The parameters we invert for are the directions of the three
    principal stresses and the shape ratio. Because this inversion does not
    aim at infering the absolute stress values, we only consider the 
    deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot 
    determine the norm of the stress tensor, therefore sum sigma**2 = 1.
    Each iteration of this inversion scheme is a linear inversion.
    N.B.: This routine is written assuming outward footwall normals and slip
    vectors of the hanging wall w.r.t. the footwall. Therefore, the stress
    tensor sign convention is compression negative.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    return_eigen: boolean, default to True
        If True, returns the eigendecomposition of the inverted
        stress tensor in addition to returning the stress tensor.
    return_stats: boolean, default to True
        If True, the posterior data and model parameter distributions
        estimated from the Tarantola and Valette formula
        (cf. Tarantola_Valette routine).

    Returns
    --------
    full_stress_tensor: (3, 3) numpy array
        The inverted stress tensor.
    principal_stresses: (3,) numpy array, optional
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
        Only provided if `return_eigen` is True.
    principal_directions: (3, 3) numpy array, optional
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`. 
        Only provided if `return_eigen` is True.
    C_m_posterior: (5, 5) array, optional
        Posterior covariance of the model parameter distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array, optional
        Posterior covariance of the data distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    &#34;&#34;&#34;
    # First, convert the strike/dip/rake into slip and normal vectors.
    n_earthquakes = len(strikes)
    n_ = np.zeros((n_earthquakes, 3), dtype=np.float32) # normal vectors
    d_ = np.zeros((n_earthquakes, 3), dtype=np.float32) # slip vectors
    for i in range(n_earthquakes):
        n_[i, :], d_[i, :] = utils_stress.normal_slip_vectors(
                                    strikes[i], dips[i], rakes[i], direction=&#39;inward&#39;)
    # Next, define the matrix that relates the stress tensor
    # to the observed slip vectors, given the fault geometries
    # characterized by the normal vectors.
    # For each earthquake, an (3 x 5) matrix relates the 5 independent
    # stress tensor components to the 3 slip vector components.
    G = forward_model(n_)
    if Tarantola_kwargs is not None:
        sigma, C_m_posterior, C_d_posterior = Tarantola_Valette(\
                G, d_, **Tarantola_kwargs)
        sigma = sigma.squeeze()
    else:
        # We choose any inversion method to invert G:
        G_pinv = np.linalg.pinv(G)
        # Given how we defined G, the stress tensor components
        # we get are in this order:
        # sigma_11, sigma_12, sigma_13, sigma_22, sigma_23
        sigma = np.dot(G_pinv, d_.reshape(-1, 1)).squeeze()
        # fake C_m and C_d
        C_m_posterior = np.ones((5, 5), dtype=np.float32)
        C_d_posterior = np.diag(np.ones(3*n_earthquakes, dtype=np.float32))
    full_stress_tensor = np.array([[sigma[0], sigma[1], sigma[2]],
                                   [sigma[1], sigma[3], sigma[4]],
                                   [sigma[2], sigma[4], -sigma[0]-sigma[3]]])
    norm = np.sqrt(np.sum(full_stress_tensor**2))
    norm = 1 if norm == 0. else norm
    full_stress_tensor /= norm
    output = full_stress_tensor,
    if return_eigen:
        # solve the eigenvalue problem
        principal_stresses, principal_directions = \
                utils_stress.stress_tensor_eigendecomposition(full_stress_tensor)
        output = output + (principal_stresses, principal_directions,)
    if return_stats:
        output = output + (C_m_posterior, C_d_posterior,)
    if len(output) == 1:
        return output[0]
    else:
        return output</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.Tarantola_Valette"><code class="name flex">
<span>def <span class="ident">Tarantola_Valette</span></span>(<span>G, data, C_d=None, C_d_inv=None, C_m=None, C_m_inv=None, m_prior=None, inversion_space='model_space')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Tarantola's and Valette's least square solution for
a given linear operator <code>G</code> and observation vector <code>data</code>. If the
covariance matrices of the observations and of the model
parameters are not known, we assume them to be identity. The
inversion can be performed either in the data space or in
the model space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>(n, m) numpy array</code></dt>
<dd>The linear operator projecting elements of the model
space m onto the data space: d = G.m
n is the dimension of the data space,
m is the dimension of the model space.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>(n,)</code> or <code>(n, 1) numpy array</code></dt>
<dd>Vector of observations.</dd>
<dt><strong><code>C_d</code></strong> :&ensp;<code>(n, n) numpy array</code>, default <code>to None</code></dt>
<dd>Covariance matrix of the observations. It quantifies
the errors in the observations and propagates them
in the inversion to give more weight to the observations
with low errors. If None, then <code>C_d</code> is identity.</dd>
<dt><strong><code>C_m</code></strong> :&ensp;<code>(m, m) numpy array</code>, default <code>to None</code></dt>
<dd>Covariance matrix of the model parameters. It quantifies
the errors in the model parameters and propagates them
in the inversion to determine the range of acceptable
model parameters for a given set of observations.
If None, then <code>C_m</code> is identity.</dd>
<dt><strong><code>m_prior</code></strong> :&ensp;<code>(m,)</code> or <code>(m, 1) numpy array</code>, default <code>to None</code></dt>
<dd>If one already has a rough estimate of what the model
parameters are, then m_prior should be filled with this estimate.
If None, <code>m_prior</code> is set to zero.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>m_inv</code></strong> :&ensp;<code>(m, 1) numpy array</code></dt>
<dd>The inverted model parameters.</dd>
<dt><strong><code>C_m_posterior</code></strong> :&ensp;<code>(5, 5) array</code></dt>
<dd>Posterior covariance of the model parameter distribution.</dd>
<dt><strong><code>C_d_posterior</code></strong> :&ensp;<code>(3 x n_earthquakes, 3 x n_earthquakes) array</code></dt>
<dd>Posterior covariance of the data distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Tarantola_Valette(G, data, C_d=None, C_d_inv=None,
                      C_m=None, C_m_inv=None, m_prior=None,
                      inversion_space=&#39;model_space&#39;):
    &#34;&#34;&#34;
    Returns Tarantola&#39;s and Valette&#39;s least square solution for
    a given linear operator `G` and observation vector `data`. If the
    covariance matrices of the observations and of the model
    parameters are not known, we assume them to be identity. The
    inversion can be performed either in the data space or in
    the model space.

    Parameters
    -----------
    G: (n, m) numpy array
        The linear operator projecting elements of the model
        space m onto the data space: d = G.m
        n is the dimension of the data space,
        m is the dimension of the model space.
    data: (n,) or (n, 1) numpy array
        Vector of observations.
    C_d: (n, n) numpy array, default to None
        Covariance matrix of the observations. It quantifies
        the errors in the observations and propagates them
        in the inversion to give more weight to the observations
        with low errors. If None, then `C_d` is identity.
    C_m: (m, m) numpy array, default to None
        Covariance matrix of the model parameters. It quantifies
        the errors in the model parameters and propagates them
        in the inversion to determine the range of acceptable
        model parameters for a given set of observations.
        If None, then `C_m` is identity.
    m_prior: (m,) or (m, 1) numpy array, default to None
        If one already has a rough estimate of what the model
        parameters are, then m_prior should be filled with this estimate.
        If None, `m_prior` is set to zero.

    Returns
    ---------
    m_inv: (m, 1) numpy array
        The inverted model parameters.
    C_m_posterior: (5, 5) array
        Posterior covariance of the model parameter distribution.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array
        Posterior covariance of the data distribution.
    &#34;&#34;&#34;
    #t_start = give_time()
    dim_D = G.shape[0]
    dim_M = G.shape[1]
    # pre-compute transposed G
    #Gt = G.T
    if C_d is None:
        C_d = np.identity(dim_D, dtype=np.float32)
        C_d_inv = np.identity(dim_D, dtype=np.float32)
    elif C_d_inv is None and inversion_space == &#39;model_space&#39;:
        try:
            C_d_inv = np.linalg.inv(C_d)
        except LinAlgError:
            print(&#39;Cannot invert data covariance matrix:&#39;)
            print(C_d)
            sys.exit()
    if C_m is None:
        C_m = np.identity(dim_M, dtype=np.float32)
        C_m_inv = np.zeros_like(C_m)
    elif C_m_inv is None and inversion_space == &#39;model_space&#39;:
        try:
            C_m_inv = np.linalg.inv(C_m)
        except LinAlgError:
            print(&#39;Cannot invert model covariance matrix:&#39;)
            print(C_m)
            sys.exit()
    if m_prior is None:
        m_prior = np.zeros((dim_M, 1), dtype=np.float32)
    # make sure data is a column vector
    data = data.reshape(-1, 1)
    if inversion_space == &#39;data_space&#39;:
        # perform the inversion in the data space
        # pre-compute recurrent terms:
        Cm_Gt = C_m.dot(G.T)
        inv = np.linalg.inv(G.dot(Cm_Gt) + C_d)
        Cm_Gt_inv = Cm_Gt.dot(inv)
        m_inv = m_prior\
                + np.dot(Cm_Gt_inv, data - np.dot(G, m_prior))
        C_m_posterior = C_m - (Cm_Gt_inv.dot(G)).dot(C_m)
    elif inversion_space == &#39;model_space&#39;:
        # perform the inversion in the model space
        # pre-compute recurrent terms
        Gt_Cdinv = G.T.dot(C_d_inv)
        try:
            inv = np.linalg.inv(Gt_Cdinv.dot(G) + C_m_inv)
        except LinAlgError:
            print(&#39;Forward modelling matrix:&#39;, G)
            print(&#39;Inverse data cov matrix:&#39;, C_d_inv)
            print(&#39;Inverse model cov matrix:&#39;, C_m_inv)
            print(np.dot(Gt_Cdinv, G))
            sys.exit()
        if inv[1,1] &lt; 0.:
            print(G.T@G, C_d_inv, C_m_inv)
        m_inv = m_prior\
                + (inv.dot(Gt_Cdinv)).dot(data - G.dot(m_prior))
        #m_inv = inv@G.T@data
        C_m_posterior = inv.copy()
    else:
        print(&#39;inversion_spce should either be &#34;model_space&#34; &#39;
              &#39;or &#34;data_space&#34;&#39;)
        return
    C_d_posterior = (G.dot(C_m_posterior)).dot(G.T)
    #t_end = give_time()
    #print(&#39;{:.3f}sec on Tarantola&#39;.format(t_end-t_start))
    return m_inv, C_m_posterior, C_d_posterior</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.compute_instability_parameter"><code class="name flex">
<span>def <span class="ident">compute_instability_parameter</span></span>(<span>principal_directions, R, friction, strike_1, dip_1, rake_1, strike_2, dip_2, rake_2, return_fault_planes=False, signed_instability=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the instability parameter as introduced by Lund and Slunga 1999,
re-used by Vavrycuk 2013-2014 and modified by Beauce 2021.
For a given stress field characterized by the principal stress
directions and shape ratio R=(sig1-sig2)/(sig1-sig3), and for
a given rock friction, this routine computes an instability
parameter based on the Mohr-Coulomb failure criterion to determine
which of the two nodal planes of a focal mechanism solution
is more likely to be the fault plane.
Beauce 2021 includes the sign of the dot product between
the shear stress and the slip vector on the fault. This instability
ranges from -1 to +1, instead of from 0 to +1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) array, float</code></dt>
<dd>The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: principal_directions[:, i]</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>float</code></dt>
<dd>Shape ratio of the reference stress tensor.</dd>
<dt><strong><code>strikes_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>strikes_2</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 2, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips_2</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 2, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes_2</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 2, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>return_fault_planes</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, return the strikes, dips, rakes of the selected
fault planes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>instability_parameter</code></strong> :&ensp;<code>(n_earthquakes, 2) array</code></dt>
<dd>The instability parameter as defined in Beauce 2021 for the two
nodal planes of each focal mechanism datum.</dd>
<dt><strong><code>strikes</code></strong> :&ensp;<code>list</code> or <code>array, float</code>, optional</dt>
<dd>Strikes of the fault planes with largest instability.
Only provided if <code>return_fault_planes=True</code>.</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>list</code> or <code>array, float</code>, optional</dt>
<dd>Dips of the fault planes with largest instability.
Only provided if <code>return_fault_planes=True</code>.</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>list</code> or <code>array, float</code>, optional</dt>
<dd>Rakes of the fault planes with largest instability.
Only provided if <code>return_fault_planes=True</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_instability_parameter(principal_directions, R, friction,
                                  strike_1, dip_1, rake_1,
                                  strike_2, dip_2, rake_2,
                                  return_fault_planes=False,
                                  signed_instability=True):
    &#34;&#34;&#34;
    Compute the instability parameter as introduced by Lund and Slunga 1999,
    re-used by Vavrycuk 2013-2014 and modified by Beauce 2021.
    For a given stress field characterized by the principal stress
    directions and shape ratio R=(sig1-sig2)/(sig1-sig3), and for
    a given rock friction, this routine computes an instability
    parameter based on the Mohr-Coulomb failure criterion to determine
    which of the two nodal planes of a focal mechanism solution
    is more likely to be the fault plane.
    Beauce 2021 includes the sign of the dot product between
    the shear stress and the slip vector on the fault. This instability
    ranges from -1 to +1, instead of from 0 to +1.

    Parameters
    -----------
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: principal_directions[:, i] 
    R: float
        Shape ratio of the reference stress tensor.
    strikes_1: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_1: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_1: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    strikes_2: list or array, float
        The strike of nodal planes 2, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_2: list or array, float
        The dip of nodal planes 2, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_2: list or array, float
        The rake of nodal planes 2, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    return_fault_planes: boolean, default to False
        If True, return the strikes, dips, rakes of the selected
        fault planes.

    Returns
    --------
    instability_parameter: (n_earthquakes, 2) array
        The instability parameter as defined in Beauce 2021 for the two
        nodal planes of each focal mechanism datum.
    strikes: list or array, float, optional
        Strikes of the fault planes with largest instability.
        Only provided if `return_fault_planes=True`.
    dips: list or array, float, optional
        Dips of the fault planes with largest instability.
        Only provided if `return_fault_planes=True`.
    rakes: list or array, float, optional
        Rakes of the fault planes with largest instability.
        Only provided if `return_fault_planes=True`.
    &#34;&#34;&#34;
    # the calculation is done in the eigenbasis, therefore
    # we need to project the normal vectors onto the eigenbasis
    n_earthquakes = len(strike_1)
    n_1 = np.zeros((n_earthquakes, 3), dtype=np.float32)
    n_2 = np.zeros((n_earthquakes, 3), dtype=np.float32)
    d_1 = np.zeros((n_earthquakes, 3), dtype=np.float32)
    d_2 = np.zeros((n_earthquakes, 3), dtype=np.float32)
    # compute the normals of the two nodal planes
    for i in range(n_earthquakes):
        n_1[i, :], d_1[i, :] = utils_stress.normal_slip_vectors(
                strike_1[i], dip_1[i], rake_1[i], direction=&#39;inward&#39;)
        n_2[i, :], d_2[i, :] = utils_stress.normal_slip_vectors(
                strike_2[i], dip_2[i], rake_2[i], direction=&#39;inward&#39;)
    # project the normals onto the eigenbasis
    n_1 = np.dot(n_1, principal_directions)
    n_2 = np.dot(n_2, principal_directions)
    d_1 = np.dot(d_1, principal_directions)
    d_2 = np.dot(d_2, principal_directions)
    # when parameterazing the reduced stress tensor as:
    # sigma_1 = -1, sigma_2 = 2R-1 and sigma_3 = +1,
    # (CONVENTION: TENSION IS POSITIVE)
    # the critical shear and normal stresses are:
    sig1 = -1.
    sig2 = 2.*R-1.
    sig3 = +1.
    tau_c = 1./np.sqrt(1.+friction**2)
    sig_c = friction/np.sqrt(1.+friction**2)
    #print(sig1, sig2, sig3, tau_c, sig_c)
    # and the shear and normal stresses on each fault are:
    normal_1 = sig1*n_1[:, 0]**2 + sig2*n_1[:, 1]**2 + sig3*n_1[:, 2]**2
    shear_1 = np.sqrt(sig1**2*n_1[:, 0]**2 + sig2**2*n_1[:, 1]**2 + sig3**2*n_1[:, 2]**2 - normal_1**2) 

    normal_2 = sig1*n_2[:, 0]**2 + sig2*n_2[:, 1]**2 + sig3*n_2[:, 2]**2
    shear_2 = np.sqrt(sig1**2*n_2[:, 0]**2 + sig2**2*n_2[:, 1]**2 + sig3**2*n_2[:, 2]**2 - normal_2**2) 
    # combine all of them in the definition of the instability parameter I
    Ic = (tau_c - friction*(sig1-sig_c))
    I_1 = (shear_1 - friction*(sig1-normal_1))/Ic 
    I_2 = (shear_2 - friction*(sig1-normal_2))/Ic
    # my addition: add the sign of the shear-slip dot product
    #stress_tensor = np.dot(principal_directions, np.dot(np.diag([sig1, sig2, sig3]), principal_directions.T))
    stress_tensor = np.diag([sig1, sig2, sig3])
    traction_1_vec = np.dot(stress_tensor, n_1.T).T 
    traction_2_vec = np.dot(stress_tensor, n_2.T).T
    normal_1_vec = np.sum(traction_1_vec*n_1, axis=-1)[:, np.newaxis]*n_1
    normal_2_vec = np.sum(traction_2_vec*n_2, axis=-1)[:, np.newaxis]*n_2
    shear_1_vec = traction_1_vec - normal_1_vec
    shear_2_vec = traction_2_vec - normal_2_vec
    sign_dot_1 = np.sign(np.sum(shear_1_vec*d_1, axis=-1))
    sign_dot_2 = np.sign(np.sum(shear_2_vec*d_2, axis=-1))
    #print(sign_dot_1)
    if signed_instability:
        # multiplying the instability parameter by the sign of the
        # dot product between shear direction and slip direction is
        # the difference with the instability parameter defined in Vavrycuk 2013
        I_1 *= sign_dot_1
        I_2 *= sign_dot_2

    if return_fault_planes:
        strikes = np.zeros(n_earthquakes, dtype=np.float32)
        dips = np.zeros(n_earthquakes, dtype=np.float32)
        rakes = np.zeros(n_earthquakes, dtype=np.float32)
        mask_1 = I_1 &gt;= I_2
        strikes[mask_1] = strike_1[mask_1]
        dips[mask_1] = dip_1[mask_1]
        rakes[mask_1] = rake_1[mask_1]
        mask_2 = ~mask_1
        strikes[mask_2] = strike_2[mask_2]
        dips[mask_2] = dip_2[mask_2]
        rakes[mask_2] = rake_2[mask_2]
        return np.column_stack((I_1, I_2)), strikes, dips, rakes
    else:
        return np.column_stack((I_1, I_2))</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.find_optimal_friction"><code class="name flex">
<span>def <span class="ident">find_optimal_friction</span></span>(<span>strikes_1, dips_1, rakes_1, strikes_2, dips_2, rakes_2, principal_directions, R, friction_min=0.1, friction_max=0.8, friction_step=0.05, signed_instability=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the friction that maximizes the instability parameter I
based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strikes_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>strikes_2</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 2, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips_2</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 2, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes_2</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 2, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) array, float</code></dt>
<dd>The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>float</code></dt>
<dd>Shape ratio of the reference stress tensor.</dd>
<dt><strong><code>friction_min</code></strong> :&ensp;<code>float</code>, default <code>to 0.1</code></dt>
<dd>Lower bound of explored friction values.</dd>
<dt><strong><code>friction_max</code></strong> :&ensp;<code>float</code>, default <code>to 0.8</code></dt>
<dd>Upper bound of explored friction values.</dd>
<dt><strong><code>friction_step</code></strong> :&ensp;<code>float</code>, default <code>to 0.05</code></dt>
<dd>Step employed in the grid search of the friction value
that maximizes the instability parameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>optimal_friction</code></strong> :&ensp;<code>float</code></dt>
<dd>The friction value that maximizes the mean instability parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_optimal_friction(strikes_1, dips_1, rakes_1,
                          strikes_2, dips_2, rakes_2,
                          principal_directions, R,
                          friction_min=0.1,
                          friction_max=0.8,
                          friction_step=0.05,
                          signed_instability=True):
    &#34;&#34;&#34;
    Find the friction that maximizes the instability parameter I
    based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.

    Parameters
    -----------
    strikes_1: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_1: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_1: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    strikes_2: list or array, float
        The strike of nodal planes 2, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_2: list or array, float
        The dip of nodal planes 2, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_2: list or array, float
        The rake of nodal planes 2, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
    R: float
        Shape ratio of the reference stress tensor.
    friction_min: float, default to 0.1
        Lower bound of explored friction values.
    friction_max: float, default to 0.8
        Upper bound of explored friction values.
    friction_step: float, default to 0.05
        Step employed in the grid search of the friction value
        that maximizes the instability parameter.

    Returns
    --------
    optimal_friction: float
        The friction value that maximizes the mean instability parameter.
    &#34;&#34;&#34;
    friction = np.arange(friction_min, friction_max+friction_step, friction_step)
    n_fric = len(friction)
    I = np.zeros(n_fric, dtype=np.float32)
    for i, fric in enumerate(friction):
        I_ = compute_instability_parameter(
                   principal_directions, R, fric,
                   strikes_1, dips_1, rakes_1,
                   strikes_2, dips_2, rakes_2,
                   signed_instability=signed_instability)
        I[i] = np.sum(np.max(I_, axis=-1))
    optimal_friction = friction[I.argmax()]
    return optimal_friction</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.find_optimal_friction_one_set"><code class="name flex">
<span>def <span class="ident">find_optimal_friction_one_set</span></span>(<span>strikes_1, dips_1, rakes_1, principal_directions, R, friction_min=0.2, friction_max=0.8, friction_step=0.05, signed_instability=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the friction that maximizes the instability parameter I
based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strikes_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes_1</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) array, float</code></dt>
<dd>The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>float</code></dt>
<dd>Shape ratio of the reference stress tensor.</dd>
<dt><strong><code>friction_min</code></strong> :&ensp;<code>float</code>, default <code>to 0.1</code></dt>
<dd>Lower bound of explored friction values.</dd>
<dt><strong><code>friction_max</code></strong> :&ensp;<code>float</code>, default <code>to 0.8</code></dt>
<dd>Upper bound of explored friction values.</dd>
<dt><strong><code>friction_step</code></strong> :&ensp;<code>float</code>, default <code>to 0.05</code></dt>
<dd>Step employed in the grid search of the friction value
that maximizes the instability parameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>optimal_friction</code></strong> :&ensp;<code>float</code></dt>
<dd>The friction value that maximizes the mean instability parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_optimal_friction_one_set(strikes_1, dips_1, rakes_1,
                                  principal_directions, R,
                                  friction_min=0.2, friction_max=0.8, friction_step=0.05,
                                  signed_instability=True):
    &#34;&#34;&#34;
    Find the friction that maximizes the instability parameter I
    based on V. Vavrycuk 2013,2014 and B. Lund and R. Slunga 1999.

    Parameters
    -----------
    strikes_1: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips_1: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes_1: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
    R: float
        Shape ratio of the reference stress tensor.
    friction_min: float, default to 0.1
        Lower bound of explored friction values.
    friction_max: float, default to 0.8
        Upper bound of explored friction values.
    friction_step: float, default to 0.05
        Step employed in the grid search of the friction value
        that maximizes the instability parameter.

    Returns
    --------
    optimal_friction: float
        The friction value that maximizes the mean instability parameter.
    &#34;&#34;&#34;

    # fake nodal planes #2
    strikes_2, dips_2, rakes_2 = [np.zeros(len(strikes_1)) for i in range(3)]
    friction = np.arange(friction_min, friction_max+friction_step, friction_step)
    n_fric = len(friction)
    I = np.zeros(n_fric, dtype=np.float32)
    for i, fric in enumerate(friction):
        I_ = compute_instability_parameter(
                   principal_directions, R, fric,
                   strikes_1, dips_1, rakes_1,
                   strikes_2, dips_2, rakes_2,
                   signed_instability=signed_instability)
        # only look at instability on nodal planes #1
        I[i] = np.sum(I_[:, 0])
    optimal_friction = friction[I.argmax()]
    return optimal_friction</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.forward_model"><code class="name flex">
<span>def <span class="ident">forward_model</span></span>(<span>n_)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the forward modeling matrix <code>G</code> given a collection
of fault normals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n_</code></strong> :&ensp;<code>(n_earthquakes, 3) array</code></dt>
<dd>The i-th row n_ are the components of the i-th
fault normal in the (north, west, south) coordinate
system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>(3 x n_earthquakes, 5) array</code></dt>
<dd>The forward modeling matrix giving the slip (shear stress)
directions on the faults characterized by <code>n_</code>, given the 5
elements of the deviatoric stress tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_model(n_):
    &#34;&#34;&#34;
    Build the forward modeling matrix ``G`` given a collection
    of fault normals.

    Parameters
    ------------
    n_: (n_earthquakes, 3) array
        The i-th row n_ are the components of the i-th
        fault normal in the (north, west, south) coordinate
        system.

    Returns
    ---------
    G: (3 x n_earthquakes, 5) array
        The forward modeling matrix giving the slip (shear stress)
        directions on the faults characterized by `n_`, given the 5
        elements of the deviatoric stress tensor.
    &#34;&#34;&#34;
    n_earthquakes = n_.shape[0]
    G = np.zeros((n_earthquakes*3, 5), dtype=np.float32)
    for i in range(n_earthquakes):
        ii = i*3
        n1, n2, n3 = n_[i, :]
        G[ii+0, 0] = n1 + n1*n3**2 - n1**3
        G[ii+0, 1] = n2 - 2.*n2*n1**2
        G[ii+0, 2] = n3 - 2.*n3*n1**2
        G[ii+0, 3] = n1*n3**2 - n1*n2**2
        G[ii+0, 4] = -2.*n1*n2*n3
        G[ii+1, 0] = n2*n3**2 - n2*n1**2
        G[ii+1, 1] = n1 - 2.*n1*n2**2
        G[ii+1, 2] = -2.*n1*n2*n3
        G[ii+1, 3] = n2 + n2*n3**2 - n2**3
        G[ii+1, 4] = n3 - 2.*n3*n2**2
        G[ii+2, 0] = n3**3 - n3 - n3*n1**2
        G[ii+2, 1] = -2.*n1*n2*n3
        G[ii+2, 2] = n1 - 2.*n1*n3**2
        G[ii+2, 3] = n3**3 - n3 - n3*n2**2
        G[ii+2, 4] = n2 - 2.*n2*n3**2
    return G</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.inversion_bootstrap"><code class="name flex">
<span>def <span class="ident">inversion_bootstrap</span></span>(<span>strikes, dips, rakes, n_random_selections=1, n_resamplings=100, variable_shear=True, max_n_iterations=300, shear_update_atol=1e-05, Tarantola_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverts one set of focal mechanisms without seeking which nodal planes
are more likely to be the fault planes. Performs bootstrap resampling
of the data set to return an ensemble of solutions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strikes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>n_random_selections</code></strong> :&ensp;<code>integer</code>, default <code>to 5</code></dt>
<dd>Number of random selections of subsets of nodal planes on
which the stress inversion is run. The final stress tensor
is averaged over the n_random_selections solutions.</dd>
<dt><strong><code>n_resamplings</code></strong> :&ensp;<code>integer</code>, default <code>to 100</code></dt>
<dd>Number of times the data set is resampled following
the bootstrapping method (sampling with replacement).
n_resamplings stress tensors are returned, allowing to
estimate uncertainties from the distribution of solutions.</dd>
<dt><strong><code>shear_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1e-5</code></dt>
<dd>Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</dd>
<dt><strong><code>max_n_iterations</code></strong> :&ensp;<code>integer</code>, default <code>to 300</code></dt>
<dd>The maximum number of iterations if shear stress magnitude update
does not fall below <code>shear_update_atol</code>.</dd>
<dt><strong><code>variable_shear</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, use the iterative linear method described in
Beauce et al. 2021, else use the classic linear method
due to Michael 1984.</dd>
<dt><strong><code>Tarantola_kwargs</code></strong> :&ensp;<code>Dictionary</code>, default <code>to None</code></dt>
<dd>If not None, should contain key word arguments
for the Tarantola and Valette inversion.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>boot_avg_stress_tensors</code></strong> :&ensp;<code>(n_resamplings, 3, 3) numpy array</code></dt>
<dd>The inverted stress tensors.</dd>
<dt><strong><code>boot_principal_stresses</code></strong> :&ensp;<code>(n_resamplings, 3) numpy array</code></dt>
<dd>The three eigenvalues of the stress tensors, ordered
from most compressive (sigma1) to least compressive (sigma3).</dd>
<dt><strong><code>boot_principal_directions</code></strong> :&ensp;<code>(n_resamplings, 3, 3) numpy array</code></dt>
<dd>The three eigenvectors of the stress tensors, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i for the b-th resampled data set
is given by: <code>principal_directions[b, :, i]</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversion_bootstrap(strikes, dips, rakes,
                        n_random_selections=1,
                        n_resamplings=100,
                        variable_shear=True,
                        max_n_iterations=300,
                        shear_update_atol=1.e-5,
                        Tarantola_kwargs=None):
    &#34;&#34;&#34;
    Inverts one set of focal mechanisms without seeking which nodal planes
    are more likely to be the fault planes. Performs bootstrap resampling
    of the data set to return an ensemble of solutions.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_random_selections: integer, default to 5
        Number of random selections of subsets of nodal planes on
        which the stress inversion is run. The final stress tensor
        is averaged over the n_random_selections solutions.
    n_resamplings: integer, default to 100
        Number of times the data set is resampled following
        the bootstrapping method (sampling with replacement).
        n_resamplings stress tensors are returned, allowing to 
        estimate uncertainties from the distribution of solutions.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.

    Returns
    --------
    boot_avg_stress_tensors: (n_resamplings, 3, 3) numpy array
        The inverted stress tensors.
    boot_principal_stresses: (n_resamplings, 3) numpy array
        The three eigenvalues of the stress tensors, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    boot_principal_directions: (n_resamplings, 3, 3) numpy array
        The three eigenvectors of the stress tensors, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i for the b-th resampled data set
        is given by: `principal_directions[b, :, i]`.
    &#34;&#34;&#34;

    # compute auxiliary planes
    strikes_1, dips_1, rakes_1 = strikes, dips, rakes
    strikes_2, dips_2, rakes_2 = \
            np.asarray(list(map(utils_stress.aux_plane, strikes, dips, rakes))).T
    # define shape variables
    n_earthquakes = len(strikes_1)
    n_planes_per_ev = 2
    # initialize the average stress tensor arrays
    boot_avg_stress_tensors = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    boot_principal_stresses = np.zeros((n_resamplings, 3), dtype=np.float32)
    boot_principal_directions = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    # flatten strikes/dips/rakes of planes
    strikes = np.stack((strikes_1, strikes_2), axis=1).flatten()
    dips = np.stack((dips_1, dips_2), axis=1).flatten()
    rakes = np.stack((rakes_1, rakes_2), axis=1).flatten()
    for b in range(n_resamplings):
        if b%100 == 0:
            print(f&#39;---------- Bootstrapping {b+1}/{n_resamplings} ----------&#39;)
        bootstrap_set = np.random.choice(
                np.arange(n_earthquakes), replace=True, size=n_earthquakes)
        # I now believe there is no point in adding this extra loop
        # in the bootstrapping method. Averaging only disturbs the 
        # uncertainty estimation
        #for n in range(n_random_selections):
        nodal_planes = np.random.randint(0, 2, size=n_earthquakes)
        flat_indexes = np.int32(bootstrap_set*n_planes_per_ev\
                              + nodal_planes)
        selected_strikes = strikes[flat_indexes]
        selected_dips = dips[flat_indexes]
        selected_rakes = rakes[flat_indexes]
        # invert this subset of nodal planes
        if variable_shear:
            stress_tensor = \
                    iterative_linear_si(selected_strikes,
                                        selected_dips,
                                        selected_rakes,
                                        return_eigen=False,
                                        Tarantola_kwargs=Tarantola_kwargs)
        else:
            stress_tensor = \
                    Michael1984_inversion(selected_strikes,
                                          selected_dips,
                                          selected_rakes,
                                          return_eigen=False,
                                          Tarantola_kwargs=Tarantola_kwargs)
        # uncomment if extra loop (and indent)
        ## add them to the average
        #boot_avg_stress_tensors[b, ...] += stress_tensor
        #boot_avg_stress_tensors[b, ...] /= float(n_random_selections)
        boot_avg_stress_tensors[b, ...] = stress_tensor
        boot_principal_stresses[b, ...], boot_principal_directions[b, ...] = \
                utils_stress.stress_tensor_eigendecomposition(boot_avg_stress_tensors[b, ...])
    return boot_avg_stress_tensors, boot_principal_stresses, boot_principal_directions</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.inversion_bootstrap_instability"><code class="name flex">
<span>def <span class="ident">inversion_bootstrap_instability</span></span>(<span>principal_directions, R, strikes, dips, rakes, friction_coefficient, n_resamplings=100, n_stress_iter=10, stress_tensor_update_atol=1e-05, Tarantola_kwargs=None, variable_shear=True, max_n_iterations=300, shear_update_atol=1e-05, signed_instability=True, weighted=False, parallel=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Invert one set of focal mechanisms with the instability parameter
to seek which nodal planes are more likely to be the fault planes
(cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).
Performs bootstrap resampling of the data set to return an
ensemble of solutions.
</p>
<p>Use a previously determined stress tensor (e.g. the output of
<code><a title="ILSI.ilsi.inversion_one_set_instability" href="#ILSI.ilsi.inversion_one_set_instability">inversion_one_set_instability()</a></code>) described by its principal stress
directions and shape ratio as the prior model in the Tarantola
and Valette formula. In general, you can keep the default parameter
values, except for n_resamplings which depends on the time you can
afford spending.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) array, float</code></dt>
<dd>The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>float</code></dt>
<dd>Shape ratio of the reference stress tensor.</dd>
<dt><strong><code>friction_coefficient</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the friction coefficient used in the instability parameter.
This can be the value output by <code><a title="ILSI.ilsi.inversion_one_set_instability" href="#ILSI.ilsi.inversion_one_set_instability">inversion_one_set_instability()</a></code>.</dd>
<dt><strong><code>strikes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>n_stress_iter</code></strong> :&ensp;<code>integer</code>, default <code>to 10</code></dt>
<dd>Maximum number of iterations to seek for the best fault planes.
See Beauce et al. 2021 for explanations.</dd>
<dt><strong><code>stress_tensor_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1.e-4</code></dt>
<dd>If the RMS difference of the stress tensors between two
iterations fall below this threshold, convergence has been reached.</dd>
<dt><strong><code>shear_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1e-5</code></dt>
<dd>Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</dd>
<dt><strong><code>signed_instability</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</dd>
<dt><strong><code>max_n_iterations</code></strong> :&ensp;<code>integer</code>, default <code>to 300</code></dt>
<dd>The maximum number of iterations if shear stress magnitude update
does not fall below <code>shear_update_atol</code>.</dd>
<dt><strong><code>variable_shear</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, use the iterative linear method described in
Beauce et al. 2021, else use the classic linear method
due to Michael 1984.</dd>
<dt><strong><code>Tarantola_kwargs</code></strong> :&ensp;<code>Dictionary</code>, default <code>to None</code></dt>
<dd>If not None, should contain key word arguments
for the Tarantola and Valette inversion.</dd>
<dt><strong><code>weighted</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>This option is exploratory. If True:<br>
1) More weight is given to the fault planes that are clearly
more unstable than their auxiliary counterpart in the
stress field estimated at iteration t-1<br>
2) Randomly mixes the set of fault planes at iterations
t-1 and t, giving larger probability to the planes
belonging to the set that produced the larger instability.<br>
This option can be interesting for reaching convergence on
data sets of bad quality.</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, resampling is run in parallel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>boot_avg_stress_tensors</code></strong> :&ensp;<code>(n_resamplings, 3, 3) numpy array</code></dt>
<dd>The inverted stress tensors.</dd>
<dt><strong><code>boot_principal_stresses</code></strong> :&ensp;<code>(n_resamplings, 3) numpy array</code></dt>
<dd>The three eigenvalues of the stress tensors, ordered
from most compressive (sigma1) to least compressive (sigma3).</dd>
<dt><strong><code>boot_principal_directions</code></strong> :&ensp;<code>(n_resamplings, 3, 3) numpy array</code></dt>
<dd>The three eigenvectors of the stress tensors, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i for the b-th resampled data set
is given by: <code>principal_directions[b, :, i]</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversion_bootstrap_instability(principal_directions, R,
                                    strikes, dips, rakes,
                                    friction_coefficient, n_resamplings=100,
                                    n_stress_iter=10,
                                    stress_tensor_update_atol=1.e-5,
                                    Tarantola_kwargs=None,
                                    variable_shear=True,
                                    max_n_iterations=300,
                                    shear_update_atol=1.e-5,
                                    signed_instability=True,
                                    weighted=False,
                                    parallel=False):
    &#34;&#34;&#34;
    Invert one set of focal mechanisms with the instability parameter
    to seek which nodal planes are more likely to be the fault planes
    (cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).
    Performs bootstrap resampling of the data set to return an
    ensemble of solutions.  

    Use a previously determined stress tensor (e.g. the output of
    `inversion_one_set_instability`) described by its principal stress
    directions and shape ratio as the prior model in the Tarantola
    and Valette formula. In general, you can keep the default parameter
    values, except for n_resamplings which depends on the time you can 
    afford spending.

    Parameters
    -----------
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`. 
    R: float
        Shape ratio of the reference stress tensor.
    friction_coefficient: float
        Value of the friction coefficient used in the instability parameter.
        This can be the value output by `inversion_one_set_instability`.
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_stress_iter: integer, default to 10
        Maximum number of iterations to seek for the best fault planes.
        See Beauce et al. 2021 for explanations.
    stress_tensor_update_atol: float, default to 1.e-4
        If the RMS difference of the stress tensors between two
        iterations fall below this threshold, convergence has been reached.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    signed_instability: boolean, default to True
        If True, the instability parameter ranges from -1 to +1. Negative
        values mean that the predicted and observed slip have opposite
        directions. If False, the instability parameter is the one
        defined in Vavrycuk 2013, 2014.
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    weighted: boolean, default to False
        This option is exploratory. If True:  
            1) More weight is given to the fault planes that are clearly
               more unstable than their auxiliary counterpart in the
               stress field estimated at iteration t-1  
            2) Randomly mixes the set of fault planes at iterations
               t-1 and t, giving larger probability to the planes
               belonging to the set that produced the larger instability.  
        This option can be interesting for reaching convergence on
        data sets of bad quality.
    parallel: boolean, default to False
        If True, resampling is run in parallel.

    Returns
    --------
    boot_avg_stress_tensors: (n_resamplings, 3, 3) numpy array
        The inverted stress tensors.
    boot_principal_stresses: (n_resamplings, 3) numpy array
        The three eigenvalues of the stress tensors, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    boot_principal_directions: (n_resamplings, 3, 3) numpy array
        The three eigenvectors of the stress tensors, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i for the b-th resampled data set
        is given by: `principal_directions[b, :, i]`.
    &#34;&#34;&#34;
    # compute auxiliary planes
    strikes_1, dips_1, rakes_1 = strikes, dips, rakes
    strikes_2, dips_2, rakes_2 = \
            np.asarray(list(map(utils_stress.aux_plane, strikes, dips, rakes))).T
    # build reduced stress tensor from principal directions and shape ratio
    stress_tensor_main = utils_stress.reduced_stress_tensor(principal_directions, R)
    sigma_main = np.array([stress_tensor_main[0,0], stress_tensor_main[0,1], stress_tensor_main[0,2],
                           stress_tensor_main[1,1], stress_tensor_main[1,2]]).reshape(-1, 1)
    if Tarantola_kwargs is None:
        Tarantola_kwargs = {}
    Tarantola_kwargs[&#39;m_prior&#39;] = sigma_main.copy()
    # define shape variables
    n_earthquakes = len(strikes_1)
    # initialize the average stress tensor arrays
    boot_stress_tensors = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    boot_principal_stresses = np.zeros((n_resamplings, 3), dtype=np.float32)
    boot_principal_directions = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    _bootstrap_solution_p = partial(_bootstrap_solution,
            strikes_1=strikes_1, dips_1=dips_1, rakes_1=rakes_1,
            strikes_2=strikes_2, dips_2=dips_2, rakes_2=rakes_2,
            stress_tensor_main=stress_tensor_main,
            friction_coefficient=friction_coefficient,
            stress_tensor_update_atol=stress_tensor_update_atol,
            n_stress_iter=n_stress_iter, Tarantola_kwargs=Tarantola_kwargs,
            variable_shear=variable_shear,
            weighted=weighted, max_n_iterations=max_n_iterations,
            shear_update_atol=shear_update_atol,
            signed_instability=signed_instability)
    if parallel:
        import concurrent.futures
        with concurrent.futures.ProcessPoolExecutor() as executor:
            results = list(executor.map(_bootstrap_solution_p, range(n_resamplings)))
        boot_stress_tensors = np.asarray([results[b][0] for b in range(n_resamplings)])
        boot_principal_stresses = np.asarray([results[b][1] for b in range(n_resamplings)])
        boot_principal_directions = np.asarray([results[b][2] for b in range(n_resamplings)])
    else:
        for b in range(n_resamplings):
            if b%100 == 0:
                print(f&#39;---------- Bootstrapping {b+1}/{n_resamplings} ----------&#39;)
            boot_stress_tensors[b, ...], \
                    boot_principal_stresses[b, ...],\
                    boot_principal_directions[b, ...] = _bootstrap_solution_p(b)
    return boot_stress_tensors, boot_principal_stresses, boot_principal_directions</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.inversion_jackknife"><code class="name flex">
<span>def <span class="ident">inversion_jackknife</span></span>(<span>jack_strikes, jack_dips, jack_rakes, n_random_selections=1, n_resamplings=100, max_n_iterations=300, shear_update_atol=1e-05, variable_shear=True, Tarantola_kwargs=None, bootstrap_events=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This routine was tailored for one of my application, but it can
be of interest to others. Each earthquake comes with an ensemble
of focal mechanism solutions that were obtained by resampling the
set of seismic stations used in the focal mechanism inversion. The
resampling was done with the delete-k-jackknife method, hence the
name of the routine. This routine randomly samples focal mechanisms
from these ensembles and runs the stress inversion. This is a way
of propagating the focal mechanism uncertainties into the stress
inversion. In this routine we do not seek which nodal planes are
more likely to be the fault planes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>jack_strikes</code></strong> :&ensp;<code>(n_earthquakes, n_jackknifes) array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>jack_dips</code></strong> :&ensp;<code>(n_earthquakes, n_jackknifes) array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>jack_rakes</code></strong> :&ensp;<code>(n_earthquakes, n_jackknifes) array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>n_random_selections</code></strong> :&ensp;<code>integer</code>, default <code>to 20</code></dt>
<dd>Number of random selections of subsets of nodal planes on
which the stress inversion is run. The final stress tensor
is averaged over the n_random_selections solutions.</dd>
<dt><strong><code>n_resamplings</code></strong> :&ensp;<code>integer</code>, default <code>to 100</code></dt>
<dd>Number of times the data set is resampled from the ensembles
of focal mechanism solutions available for each earthquake.
n_resamplings stress tensors are returned, allowing to
estimate uncertainties from the distribution of solutions.</dd>
<dt><strong><code>bootstrap_events</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, the resampling is also done accross earthquakes,
following the bootstrapping method.</dd>
<dt><strong><code>shear_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1e-5</code></dt>
<dd>Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</dd>
<dt><strong><code>max_n_iterations</code></strong> :&ensp;<code>integer</code>, default <code>to 300</code></dt>
<dd>The maximum number of iterations if shear stress magnitude update
does not fall below <code>shear_update_atol</code>.</dd>
<dt><strong><code>variable_shear</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, use the iterative linear method described in
Beauce et al. 2021, else use the classic linear method
due to Michael 1984.</dd>
<dt><strong><code>Tarantola_kwargs</code></strong> :&ensp;<code>Dictionary</code>, default <code>to None</code></dt>
<dd>If not None, should contain key word arguments
for the Tarantola and Valette inversion.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>jack_avg_stress_tensors</code></strong> :&ensp;<code>(n_resamplings, 3, 3) numpy array</code></dt>
<dd>The inverted stress tensors.</dd>
<dt><strong><code>jack_principal_stresses</code></strong> :&ensp;<code>(n_resamplings, 3) numpy array</code></dt>
<dd>The three eigenvalues of the stress tensors, ordered
from most compressive (sigma1) to least compressive (sigma3).</dd>
<dt><strong><code>jack_principal_directions</code></strong> :&ensp;<code>(n_resamplings, 3, 3) numpy array</code></dt>
<dd>The three eigenvectors of the stress tensors, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i for the b-th resampled data set
is given by: <code>principal_directions[b, :, i]</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversion_jackknife(jack_strikes, jack_dips, jack_rakes,
                        n_random_selections=1,
                        n_resamplings=100,
                        max_n_iterations=300,
                        shear_update_atol=1.e-5,
                        variable_shear=True,
                        Tarantola_kwargs=None,
                        bootstrap_events=False):
    &#34;&#34;&#34;
    This routine was tailored for one of my application, but it can
    be of interest to others. Each earthquake comes with an ensemble
    of focal mechanism solutions that were obtained by resampling the
    set of seismic stations used in the focal mechanism inversion. The
    resampling was done with the delete-k-jackknife method, hence the
    name of the routine. This routine randomly samples focal mechanisms
    from these ensembles and runs the stress inversion. This is a way
    of propagating the focal mechanism uncertainties into the stress
    inversion. In this routine we do not seek which nodal planes are
    more likely to be the fault planes.

    Parameters
    -----------
    jack_strikes: (n_earthquakes, n_jackknifes) array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    jack_dips: (n_earthquakes, n_jackknifes) array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    jack_rakes: (n_earthquakes, n_jackknifes) array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_random_selections: integer, default to 20
        Number of random selections of subsets of nodal planes on
        which the stress inversion is run. The final stress tensor
        is averaged over the n_random_selections solutions.
    n_resamplings: integer, default to 100
        Number of times the data set is resampled from the ensembles
        of focal mechanism solutions available for each earthquake.
        n_resamplings stress tensors are returned, allowing to 
        estimate uncertainties from the distribution of solutions.
    bootstrap_events: boolean, default to False
        If True, the resampling is also done accross earthquakes,
        following the bootstrapping method.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.

    Returns
    --------
    jack_avg_stress_tensors: (n_resamplings, 3, 3) numpy array
        The inverted stress tensors.
    jack_principal_stresses: (n_resamplings, 3) numpy array
        The three eigenvalues of the stress tensors, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    jack_principal_directions: (n_resamplings, 3, 3) numpy array
        The three eigenvectors of the stress tensors, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i for the b-th resampled data set
        is given by: `principal_directions[b, :, i]`. 
    &#34;&#34;&#34;
    # compute auxiliary planes
    jack_strikes_1, jack_dips_1, jack_rakes_1 = jack_strikes, jack_dips, jack_rakes
    jack_strikes_2, jack_dips_2, jack_rakes_2 = \
            np.vectorize(utils_stress.aux_plane)(jack_strikes_1, jack_dips_1, jack_rakes_1)
    # define shape variables
    n_earthquakes, n_jackknife = jack_strikes_1.shape
    n_planes_per_tp = int(n_jackknife*2)
    # define flat arrays
    jack_strikes = np.hstack((jack_strikes_1[..., np.newaxis], jack_strikes_2[..., np.newaxis])).flatten()
    jack_dips = np.hstack((jack_dips_1[..., np.newaxis], jack_dips_2[..., np.newaxis])).flatten()
    jack_rakes = np.hstack((jack_rakes_1[..., np.newaxis], jack_rakes_2[..., np.newaxis])).flatten()
    # initialize the average stress tensor arrays
    jack_avg_stress_tensors = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    jack_principal_stresses = np.zeros((n_resamplings, 3), dtype=np.float32)
    jack_principal_directions = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    for b in range(n_resamplings):
        bootstrap_fm = np.random.randint(0, n_jackknife, size=n_earthquakes)*2
        if bootstrap_events:
            bootstrap_ev = np.random.choice(np.arange(n_earthquakes), size=n_earthquakes)
        # see inversion_bootstrap for reason for commenting the extra loop
        #for n in range(n_random_selections):
        nodal_planes = np.random.randint(0, 2, size=n_earthquakes)
        if bootstrap_events:
            flat_indexes = np.int32(bootstrap_ev*n_planes_per_tp\
                                  + bootstrap_fm + nodal_planes)
        else:
            flat_indexes = np.int32(np.arange(n_earthquakes)*n_planes_per_tp\
                                  + bootstrap_fm + nodal_planes)
        selected_strikes = jack_strikes[flat_indexes]
        selected_dips = jack_dips[flat_indexes]
        selected_rakes = jack_rakes[flat_indexes]
        # invert this subset of nodal planes
        if variable_shear:
            # invert for both the stress tensor and values
            # of (normalized) resolved shear stress magnitude
            stress_tensor = \
                    iterative_linear_si(
                            selected_strikes, selected_dips, selected_rakes,
                            max_n_iterations=max_n_iterations,
                            shear_update_atol=shear_update_atol,
                            Tarantola_kwargs=Tarantola_kwargs,
                            return_eigen=False, return_stats=False)
        else:
            # invert only for the stress tensor, assuming
            # constant shear stress on all faults
            stress_tensor = \
                    Michael1984_inversion(
                            selected_strikes, selected_dips, selected_rakes,
                            Tarantola_kwargs=Tarantola_kwargs,
                            return_eigen=False, return_stats=False)
        ## add them to the average
        #jack_avg_stress_tensors[b, ...] += stress_tensor
        #jack_avg_stress_tensors[b, ...] /= float(n_random_selections)
        jack_avg_stress_tensors[b, ...] = stress_tensor
        jack_principal_stresses[b, ...], jack_principal_directions[b, ...] = \
                utils_stress.stress_tensor_eigendecomposition(jack_avg_stress_tensors[b, ...])
    return jack_avg_stress_tensors, jack_principal_stresses, jack_principal_directions</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.inversion_jackknife_instability"><code class="name flex">
<span>def <span class="ident">inversion_jackknife_instability</span></span>(<span>principal_directions, R, jack_strikes, jack_dips, jack_rakes, friction_coefficient, n_resamplings=100, n_stress_iter=10, stress_tensor_update_atol=0.0001, Tarantola_kwargs=None, bootstrap_events=False, n_earthquakes=None, variable_shear=True, max_n_iterations=300, shear_update_atol=1e-05, signed_instability=True, weighted=False, parallel=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This routine was tailored for one of my application, but it can
be of interest to others. Each earthquake comes with an ensemble
of focal mechanism solutions that were obtained by resampling the
set of seismic stations used in the focal mechanism inversion. The
resampling was done with the delete-k-jackknife method, hence the
name of the routine. This routine randomly samples focal mechanisms
from these ensembles and runs the stress inversion. This is a way
of propagating the focal mechanism uncertainties into the stress
inversion. Use the instability parameter to seek which nodal planes
are more likely to be the fault planes (cf. B. Lund and R. Slunga 1999,
V. Vavrycuk 2013,2014).
</p>
<p>Use a previously determined stress tensor (e.g. the output of
<code><a title="ILSI.ilsi.inversion_one_set_instability" href="#ILSI.ilsi.inversion_one_set_instability">inversion_one_set_instability()</a></code>) described by its principal stress
directions and shape ratio as the prior model in the Tarantola
and Valette formula. In general, you can keep the default parameter
values, except for n_resamplings which depends on the time you can
afford spending.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) array, float</code></dt>
<dd>The three eigenvectors of the reference stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>scalar float</code></dt>
<dd>Shape ratio of the reference stress tensor.</dd>
<dt><strong><code>friction_coefficient</code></strong> :&ensp;<code>scalar float</code></dt>
<dd>Friction value used in the instability parameter. This can be
the value output by <code><a title="ILSI.ilsi.inversion_one_set_instability" href="#ILSI.ilsi.inversion_one_set_instability">inversion_one_set_instability()</a></code>.</dd>
<dt><strong><code>jack_strikes</code></strong> :&ensp;<code>(n_earthquakes, n_jackknifes) array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>jack_dips</code></strong> :&ensp;<code>(n_earthquakes, n_jackknifes) array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>jack_rakes</code></strong> :&ensp;<code>(n_earthquakes, n_jackknifes) array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>n_stress_iter</code></strong> :&ensp;<code>integer</code>, default <code>to 10</code></dt>
<dd>Maximum number of iterations to seek for the best fault planes.
See Beauce et al. 2021 for explanations.</dd>
<dt><strong><code>stress_tensor_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1.e-4</code></dt>
<dd>If the RMS difference of the stress tensors between two
iterations fall below this threshold, convergence has been reached.</dd>
<dt><strong><code>shear_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1e-5</code></dt>
<dd>Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</dd>
<dt><strong><code>signed_instability</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</dd>
<dt><strong><code>max_n_iterations</code></strong> :&ensp;<code>integer</code>, default <code>to 300</code></dt>
<dd>The maximum number of iterations if shear stress magnitude update
does not fall below <code>shear_update_atol</code>.</dd>
<dt><strong><code>variable_shear</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, use the iterative linear method described in
Beauce et al. 2021, else use the classic linear method
due to Michael 1984.</dd>
<dt><strong><code>Tarantola_kwargs</code></strong> :&ensp;<code>Dictionary</code>, default <code>to None</code></dt>
<dd>If not None, should contain key word arguments
for the Tarantola and Valette inversion.</dd>
<dt><strong><code>bootstrap_events</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, the resampling is also done accross earthquakes,
following the bootstrapping method.</dd>
<dt><strong><code>weighted</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>This option is exploratory. If True:<br>
1) More weight is given to the fault planes that are clearly
more unstable than their auxiliary counterpart in the
stress field estimated at iteration t-1<br>
2) Randomly mixes the set of fault planes at iterations
t-1 and t, giving larger probability to the planes
belonging to the set that produced the larger instability.<br>
This option can be interesting for reaching convergence on
data sets of bad quality.</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, resampling is run in parallel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>jack_avg_stress_tensors</code></strong> :&ensp;<code>(n_resamplings, 3, 3) numpy array</code></dt>
<dd>The inverted stress tensors.</dd>
<dt><strong><code>jack_principal_stresses</code></strong> :&ensp;<code>(n_resamplings, 3) numpy array</code></dt>
<dd>The three eigenvalues of the stress tensors, ordered
from most compressive (sigma1) to least compressive (sigma3).</dd>
<dt><strong><code>jack_principal_directions</code></strong> :&ensp;<code>(n_resamplings, 3, 3) numpy array</code></dt>
<dd>The three eigenvectors of the stress tensors, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i for the b-th resampled data set
is given by: <code>principal_directions[b, :, i]</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversion_jackknife_instability(principal_directions, R,
                                    jack_strikes, jack_dips, jack_rakes,
                                    friction_coefficient, n_resamplings=100,
                                    n_stress_iter=10,
                                    stress_tensor_update_atol=1.e-4,
                                    Tarantola_kwargs=None,
                                    bootstrap_events=False,
                                    n_earthquakes=None,
                                    variable_shear=True,
                                    max_n_iterations=300,
                                    shear_update_atol=1.e-5,
                                    signed_instability=True,
                                    weighted=False,
                                    parallel=False):
    &#34;&#34;&#34;
    This routine was tailored for one of my application, but it can
    be of interest to others. Each earthquake comes with an ensemble
    of focal mechanism solutions that were obtained by resampling the
    set of seismic stations used in the focal mechanism inversion. The
    resampling was done with the delete-k-jackknife method, hence the
    name of the routine. This routine randomly samples focal mechanisms
    from these ensembles and runs the stress inversion. This is a way
    of propagating the focal mechanism uncertainties into the stress
    inversion. Use the instability parameter to seek which nodal planes
    are more likely to be the fault planes (cf. B. Lund and R. Slunga 1999,
    V. Vavrycuk 2013,2014).  

    Use a previously determined stress tensor (e.g. the output of
    `inversion_one_set_instability`) described by its principal stress
    directions and shape ratio as the prior model in the Tarantola
    and Valette formula. In general, you can keep the default parameter
    values, except for n_resamplings which depends on the time you can 
    afford spending.

    Parameters
    -----------
    principal_directions: (3, 3) array, float
        The three eigenvectors of the reference stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
    R: scalar float
        Shape ratio of the reference stress tensor.
    friction_coefficient: scalar float
        Friction value used in the instability parameter. This can be
        the value output by `inversion_one_set_instability`.
    jack_strikes: (n_earthquakes, n_jackknifes) array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    jack_dips: (n_earthquakes, n_jackknifes) array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    jack_rakes: (n_earthquakes, n_jackknifes) array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_stress_iter: integer, default to 10
        Maximum number of iterations to seek for the best fault planes.
        See Beauce et al. 2021 for explanations.
    stress_tensor_update_atol: float, default to 1.e-4
        If the RMS difference of the stress tensors between two
        iterations fall below this threshold, convergence has been reached.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    signed_instability: boolean, default to True
        If True, the instability parameter ranges from -1 to +1. Negative
        values mean that the predicted and observed slip have opposite
        directions. If False, the instability parameter is the one
        defined in Vavrycuk 2013, 2014.
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    bootstrap_events: boolean, default to False
        If True, the resampling is also done accross earthquakes,
        following the bootstrapping method.
    weighted: boolean, default to False
        This option is exploratory. If True:  
            1) More weight is given to the fault planes that are clearly
               more unstable than their auxiliary counterpart in the
               stress field estimated at iteration t-1  
            2) Randomly mixes the set of fault planes at iterations
               t-1 and t, giving larger probability to the planes
               belonging to the set that produced the larger instability.  
        This option can be interesting for reaching convergence on
        data sets of bad quality.
    parallel: boolean, default to False
        If True, resampling is run in parallel.

    Returns
    --------
    jack_avg_stress_tensors: (n_resamplings, 3, 3) numpy array
        The inverted stress tensors.
    jack_principal_stresses: (n_resamplings, 3) numpy array
        The three eigenvalues of the stress tensors, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    jack_principal_directions: (n_resamplings, 3, 3) numpy array
        The three eigenvectors of the stress tensors, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i for the b-th resampled data set
        is given by: `principal_directions[b, :, i]`.
    &#34;&#34;&#34;
    # compute auxiliary planes
    jack_strikes_1, jack_dips_1, jack_rakes_1 = jack_strikes, jack_dips, jack_rakes
    jack_strikes_2, jack_dips_2, jack_rakes_2 = \
            np.vectorize(utils_stress.aux_plane)(jack_strikes_1, jack_dips_1, jack_rakes_1)
    # make a copy of Tarantola_kwargs, on which this function will work
    Tarantola_kwargs_ = Tarantola_kwargs.copy()
    # build reduced stress tensor from principal directions and shape ratio
    stress_tensor_main = utils_stress.reduced_stress_tensor(principal_directions, R)
    sigma_main = np.array([stress_tensor_main[0,0], stress_tensor_main[0,1],
                           stress_tensor_main[0,2], stress_tensor_main[1,1],
                           stress_tensor_main[1,2]]).reshape(-1, 1)
    # define shape variables
    n_earthquakes, n_jackknife = jack_strikes_1.shape
    # initialize the average stress tensor arrays
    jack_stress_tensors = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    jack_principal_stresses = np.zeros((n_resamplings, 3), dtype=np.float32)
    jack_principal_directions = np.zeros((n_resamplings, 3, 3), dtype=np.float32)
    jack_strikes_1, jack_dips_1, jack_rakes_1 = \
            jack_strikes_1.flatten(), jack_dips_1.flatten(), jack_rakes_1.flatten()
    jack_strikes_2, jack_dips_2, jack_rakes_2 = \
            jack_strikes_2.flatten(), jack_dips_2.flatten(), jack_rakes_2.flatten()
    #n_jackknife = None if bootstrap_events else n_jackknife
    n_earthquakes = n_earthquakes if bootstrap_events else None
    _bootstrap_solution_p = partial(_bootstrap_solution,
            strikes_1=jack_strikes_1, dips_1=jack_dips_1, rakes_1=jack_rakes_1,
            strikes_2=jack_strikes_2, dips_2=jack_dips_2, rakes_2=jack_rakes_2,
            stress_tensor_main=stress_tensor_main,
            friction_coefficient=friction_coefficient,
            stress_tensor_update_atol=stress_tensor_update_atol,
            n_stress_iter=n_stress_iter, Tarantola_kwargs=Tarantola_kwargs,
            variable_shear=variable_shear,
            weighted=weighted, max_n_iterations=max_n_iterations,
            shear_update_atol=shear_update_atol,
            n_jackknife=n_jackknife, n_earthquakes=n_earthquakes,
            signed_instability=signed_instability)
    if parallel:
        import concurrent.futures
        with concurrent.futures.ProcessPoolExecutor() as executor:
            results = list(executor.map(_bootstrap_solution_p, range(n_resamplings)))
        jack_stress_tensors = np.asarray([results[b][0] for b in range(n_resamplings)])
        jack_principal_stresses = np.asarray([results[b][1] for b in range(n_resamplings)])
        jack_principal_directions = np.asarray([results[b][2] for b in range(n_resamplings)])
    else:
        for b in range(n_resamplings):
            if b%100 == 0:
                print(f&#39;---------- Bootstrapping {b+1}/{n_resamplings} ----------&#39;)
            jack_stress_tensors[b, ...],\
                    jack_principal_stresses[b, ...],\
                    jack_principal_directions[b, ...] = _bootstrap_solution_p(b)
    return jack_stress_tensors, jack_principal_stresses, jack_principal_directions</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.inversion_one_set"><code class="name flex">
<span>def <span class="ident">inversion_one_set</span></span>(<span>strikes, dips, rakes, n_random_selections=20, max_n_iterations=300, shear_update_atol=1e-05, variable_shear=True, Tarantola_kwargs=None, return_stats=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Invert one set of focal mechanisms without seeking which nodal planes
are more likely to be the fault planes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strikes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>n_random_selections</code></strong> :&ensp;<code>integer</code>, default <code>to 20</code></dt>
<dd>Number of random selections of subsets of nodal planes on
which the stress inversion is run. The final stress tensor
is averaged over the n_random_selections solutions.</dd>
<dt><strong><code>shear_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1e-5</code></dt>
<dd>Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</dd>
<dt><strong><code>max_n_iterations</code></strong> :&ensp;<code>integer</code>, default <code>to 300</code></dt>
<dd>The maximum number of iterations if shear stress magnitude update
does not fall below <code>shear_update_atol</code>.</dd>
<dt><strong><code>variable_shear</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, use the iterative linear method described in
Beauce et al. 2021, else use the classic linear method
due to Michael 1984.</dd>
<dt><strong><code>Tarantola_kwargs</code></strong> :&ensp;<code>Dictionary</code>, default <code>to None</code></dt>
<dd>If not None, should contain key word arguments
for the Tarantola and Valette inversion.</dd>
<dt><strong><code>return_stats</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, the posterior data and model parameter distributions
estimated from the Tarantola and Valette formula
(cf. Tarantola_Valette routine).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>full_stress_tensor</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>The inverted stress tensor.</dd>
<dt><strong><code>principal_stresses</code></strong> :&ensp;<code>(3,) numpy array</code></dt>
<dd>The three eigenvalues of the stress tensor, ordered
from most compressive (sigma1) to least compressive (sigma3).</dd>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>The three eigenvectors of the stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: principal_directions[:, i]</dd>
<dt><strong><code>C_m_posterior</code></strong> :&ensp;<code>(5, 5) array</code>, optional</dt>
<dd>Posterior covariance of the model parameter distribution
estimated from the Tarantola and Valette formula.
Only provided if <code>return_stats</code> is True.</dd>
<dt><strong><code>C_d_posterior</code></strong> :&ensp;<code>(3 x n_earthquakes, 3 x n_earthquakes) array</code>, optional</dt>
<dd>Posterior covariance of the data distribution
estimated from the Tarantola and Valette formula.
Only provided if <code>return_stats</code> is True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversion_one_set(strikes, dips, rakes,
                      n_random_selections=20,
                      max_n_iterations=300,
                      shear_update_atol=1.e-5,
                      variable_shear=True,
                      Tarantola_kwargs=None,
                      return_stats=False):
    &#34;&#34;&#34;
    Invert one set of focal mechanisms without seeking which nodal planes
    are more likely to be the fault planes.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    n_random_selections: integer, default to 20
        Number of random selections of subsets of nodal planes on
        which the stress inversion is run. The final stress tensor
        is averaged over the n_random_selections solutions.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    return_stats: boolean, default to True
        If True, the posterior data and model parameter distributions
        estimated from the Tarantola and Valette formula
        (cf. Tarantola_Valette routine).

    Returns
    --------
    full_stress_tensor: (3, 3) numpy array
        The inverted stress tensor.
    principal_stresses: (3,) numpy array
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    principal_directions: (3, 3) numpy array
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: principal_directions[:, i] 
    C_m_posterior: (5, 5) array, optional
        Posterior covariance of the model parameter distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array, optional
        Posterior covariance of the data distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    &#34;&#34;&#34;
    # compute auxiliary planes
    strikes_1, dips_1, rakes_1 = strikes, dips, rakes
    strikes_2, dips_2, rakes_2 = \
            np.asarray(list(map(utils_stress.aux_plane, strikes, dips, rakes))).T
    # define shape variable
    n_earthquakes = len(strikes)
    # define flat arrays
    strikes = np.hstack((strikes_1.reshape(-1, 1), strikes_2.reshape(-1, 1))).flatten()
    dips = np.hstack((dips_1.reshape(-1, 1), dips_2.reshape(-1, 1))).flatten()
    rakes = np.hstack((rakes_1.reshape(-1, 1), rakes_2.reshape(-1, 1))).flatten()
    # initialize the average stress tensor array
    avg_stress_tensor = np.zeros((3, 3), dtype=np.float32)
    # initialize posterior covariance matrices
    avg_C_m_posterior = np.zeros((5, 5), dtype=np.float32)
    avg_C_d_posterior = np.zeros((3*n_earthquakes, 3*n_earthquakes), dtype=np.float32)
    # randomly select subsets of nodal planes and invert for the stress tensor
    for n in range(n_random_selections):
        nodal_planes = np.random.randint(0, 2, size=n_earthquakes)
        flat_indexes = np.int32(np.arange(n_earthquakes)*2+nodal_planes)
        selected_strikes = strikes[flat_indexes]
        selected_dips = dips[flat_indexes]
        selected_rakes = rakes[flat_indexes]
        # invert this subset of nodal planes
        if variable_shear:
            # invert for both the stress tensor and values
            # of (normalized) resolved shear stress magnitude
            stress_tensor, C_m_post, C_d_post = \
                    iterative_linear_si(
                            selected_strikes, selected_dips, selected_rakes,
                            max_n_iterations=max_n_iterations,
                            shear_update_atol=shear_update_atol,
                            Tarantola_kwargs=Tarantola_kwargs,
                            return_eigen=False, return_stats=True)
        else:
            # invert only for the stress tensor, assuming
            # constant shear stress on all faults
            stress_tensor, C_m_post, C_d_post = \
                    Michael1984_inversion(
                            selected_strikes, selected_dips, selected_rakes,
                            Tarantola_kwargs=Tarantola_kwargs,
                            return_eigen=False, return_stats=True)
        # add them to the average
        avg_stress_tensor += stress_tensor
        avg_C_m_posterior += C_m_post
        avg_C_d_posterior += C_d_post
    avg_stress_tensor /= float(n_random_selections)
    avg_C_m_posterior /= float(n_random_selections)
    avg_C_d_posterior /= float(n_random_selections)
    principal_stresses, principal_directions = \
            utils_stress.stress_tensor_eigendecomposition(avg_stress_tensor)
    output = (avg_stress_tensor, principal_stresses, principal_directions,)
    if return_stats:
        output = output + (avg_C_m_posterior, avg_C_d_posterior,)
    return output</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.inversion_one_set_instability"><code class="name flex">
<span>def <span class="ident">inversion_one_set_instability</span></span>(<span>strikes, dips, rakes, friction_min=0.1, friction_max=0.8, friction_step=0.05, n_stress_iter=10, n_random_selections=20, stress_tensor_update_atol=0.0001, Tarantola_kwargs=None, max_n_iterations=300, shear_update_atol=1e-05, n_averaging=1, signed_instability=True, verbose=True, variable_shear=True, return_stats=False, weighted=False, plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Invert one set of focal mechanisms with the instability parameter
to seek which nodal planes are more likely to be the fault planes
(cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).
In general, you can keep the default parameter values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strikes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>friction_min</code></strong> :&ensp;<code>float</code>, default <code>to 0.1</code></dt>
<dd>Lower bound of explored friction values.</dd>
<dt><strong><code>friction_max</code></strong> :&ensp;<code>float</code>, default <code>to 0.8</code></dt>
<dd>Upper bound of explored friction values.</dd>
<dt><strong><code>friction_step</code></strong> :&ensp;<code>float</code>, default <code>to 0.05</code></dt>
<dd>Step employed in the grid search of the friction value
that maximizes the instability parameter.</dd>
<dt><strong><code>n_stress_iter</code></strong> :&ensp;<code>integer</code>, default <code>to 10</code></dt>
<dd>Maximum number of iterations to seek for the best fault planes.
See Beauce et al. 2021 for explanations.</dd>
<dt><strong><code>stress_tensor_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1.e-4</code></dt>
<dd>If the RMS difference of the stress tensors between two
iterations fall below this threshold, convergence has been reached.</dd>
<dt><strong><code>n_random_selections</code></strong> :&ensp;<code>integer</code>, default <code>to 20</code></dt>
<dd>Number of random selections of subsets of nodal planes on
which the stress inversion is run. The final stress tensor
is averaged over the n_random_selections solutions.</dd>
<dt><strong><code>shear_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1e-5</code></dt>
<dd>Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</dd>
<dt><strong><code>max_n_iterations</code></strong> :&ensp;<code>integer</code>, default <code>to 300</code></dt>
<dd>The maximum number of iterations if shear stress magnitude update
does not fall below <code>shear_update_atol</code>.</dd>
<dt><strong><code>variable_shear</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, use the iterative linear method described in
Beauce et al. 2021, else use the classic linear method
due to Michael 1984.</dd>
<dt><strong><code>n_averaging</code></strong> :&ensp;<code>integer</code>, default <code>to 1</code></dt>
<dd>The inversion can be sensitive to initial conditions. To improve
reproducibility of the results it is good to repeat the inversion
several times and average the results. Set <code>n_averaging</code> to ~5 if
you can afford the increase in run time.</dd>
<dt><strong><code>signed_instability</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, the instability parameter ranges from -1 to +1. Negative
values mean that the predicted and observed slip have opposite
directions. If False, the instability parameter is the one
defined in Vavrycuk 2013, 2014.</dd>
<dt><strong><code>Tarantola_kwargs</code></strong> :&ensp;<code>Dictionary</code>, default <code>to None</code></dt>
<dd>If not None, should contain key word arguments
for the Tarantola and Valette inversion.</dd>
<dt><strong><code>return_stats</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, the posterior data and model parameter distributions
estimated from the Tarantola and Valette formula
(cf. Tarantola_Valette routine).</dd>
<dt><strong><code>weighted</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>This option is exploratory. If True:
1) More weight is given to the fault planes that are clearly
more unstable than their auxiliary counterpart in the
stress field estimated at iteration t-1
2) Randomly mixes the set of fault planes at iterations
t-1 and t, giving larger probability to the planes
belonging to the set that produced the larger instability.
This option can be interesting for reaching convergence on
data sets of bad quality.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, plot the set of nodal planes selected at each iteration,
and the weight attributed to each of these planes. Can be used
with <code>weighted=True</code> to see if the inversion convergences to a
well defined set of planes.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>integer</code>, default <code>to 1</code></dt>
<dd>Level of verbosity.<br>
0: No print statements.<br>
1: Print whether the algorithm converged.<br>
2: Print the stress tensor at the end of each fault plane
selection iteration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>full_stress_tensor</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>The inverted stress tensor.</dd>
<dt><strong><code>optimal_friction</code></strong> :&ensp;<code>float</code></dt>
<dd>The friction value that maximizes the instability parameter
found during the grid search.</dd>
<dt><strong><code>principal_stresses</code></strong> :&ensp;<code>(3,) numpy array</code></dt>
<dd>The three eigenvalues of the stress tensor, ordered
from most compressive (sigma1) to least compressive (sigma3).</dd>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>The three eigenvectors of the stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.</dd>
<dt><strong><code>C_m_posterior</code></strong> :&ensp;<code>(5, 5) array</code>, optional</dt>
<dd>Posterior covariance of the model parameter distribution
estimated from the Tarantola and Valette formula.
Only provided if <code>return_stats</code> is True.</dd>
<dt><strong><code>C_d_posterior</code></strong> :&ensp;<code>(3 x n_earthquakes, 3 x n_earthquakes) array</code>, optional</dt>
<dd>Posterior covariance of the data distribution
estimated from the Tarantola and Valette formula.
Only provided if <code>return_stats</code> is True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversion_one_set_instability(strikes, dips, rakes,
                                  friction_min=0.1, friction_max=0.8,
                                  friction_step=0.05, n_stress_iter=10,
                                  n_random_selections=20,
                                  stress_tensor_update_atol=1.e-4,
                                  Tarantola_kwargs=None,
                                  max_n_iterations=300,
                                  shear_update_atol=1.e-5,
                                  n_averaging=1,
                                  signed_instability=True,
                                  verbose=True,
                                  variable_shear=True,
                                  return_stats=False,
                                  weighted=False,
                                  plot=False):
    &#34;&#34;&#34;
    Invert one set of focal mechanisms with the instability parameter
    to seek which nodal planes are more likely to be the fault planes
    (cf. B. Lund and R. Slunga 1999, V. Vavrycuk 2013,2014).
    In general, you can keep the default parameter values.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    friction_min: float, default to 0.1
        Lower bound of explored friction values.
    friction_max: float, default to 0.8
        Upper bound of explored friction values.
    friction_step: float, default to 0.05
        Step employed in the grid search of the friction value
        that maximizes the instability parameter.
    n_stress_iter: integer, default to 10
        Maximum number of iterations to seek for the best fault planes.
        See Beauce et al. 2021 for explanations.
    stress_tensor_update_atol: float, default to 1.e-4
        If the RMS difference of the stress tensors between two
        iterations fall below this threshold, convergence has been reached.
    n_random_selections: integer, default to 20
        Number of random selections of subsets of nodal planes on
        which the stress inversion is run. The final stress tensor
        is averaged over the n_random_selections solutions.
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    variable_shear: boolean, default to True
        If True, use the iterative linear method described in
        Beauce et al. 2021, else use the classic linear method
        due to Michael 1984.
    n_averaging: integer, default to 1
        The inversion can be sensitive to initial conditions. To improve
        reproducibility of the results it is good to repeat the inversion
        several times and average the results. Set `n_averaging` to ~5 if
        you can afford the increase in run time.
    signed_instability: boolean, default to True
        If True, the instability parameter ranges from -1 to +1. Negative
        values mean that the predicted and observed slip have opposite
        directions. If False, the instability parameter is the one
        defined in Vavrycuk 2013, 2014.
    Tarantola_kwargs: Dictionary, default to None
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    return_stats: boolean, default to True
        If True, the posterior data and model parameter distributions
        estimated from the Tarantola and Valette formula
        (cf. Tarantola_Valette routine).
    weighted: boolean, default to False
        This option is exploratory. If True:
            1) More weight is given to the fault planes that are clearly
               more unstable than their auxiliary counterpart in the
               stress field estimated at iteration t-1
            2) Randomly mixes the set of fault planes at iterations
               t-1 and t, giving larger probability to the planes
               belonging to the set that produced the larger instability.
        This option can be interesting for reaching convergence on
        data sets of bad quality.
    plot: boolean, default to False
        If True, plot the set of nodal planes selected at each iteration,
        and the weight attributed to each of these planes. Can be used
        with `weighted=True` to see if the inversion convergences to a
        well defined set of planes.
    verbose: integer, default to 1
        Level of verbosity.  
        0: No print statements.  
        1: Print whether the algorithm converged.  
        2: Print the stress tensor at the end of each fault plane
           selection iteration.


    Returns
    --------
    full_stress_tensor: (3, 3) numpy array
        The inverted stress tensor.
    optimal_friction: float
        The friction value that maximizes the instability parameter
        found during the grid search.
    principal_stresses: (3,) numpy array
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    principal_directions: (3, 3) numpy array
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
    C_m_posterior: (5, 5) array, optional
        Posterior covariance of the model parameter distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array, optional
        Posterior covariance of the data distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    &#34;&#34;&#34;
    if plot:
        import mplstereonet
        import matplotlib.pyplot as plt
        from matplotlib.colors import Normalize
        from matplotlib.cm import ScalarMappable
        from mpl_toolkits.axes_grid1 import make_axes_locatable
    # compute auxiliary planes
    strikes_1, dips_1, rakes_1 = strikes, dips, rakes
    strikes_2, dips_2, rakes_2 = \
            np.asarray(list(map(utils_stress.aux_plane, strikes, dips, rakes))).T
    # define shape variable
    n_earthquakes = strikes_1.shape[0]
    # define flat arrays
    strikes = np.hstack((strikes_1.reshape(-1, 1), strikes_2.reshape(-1, 1))).flatten()
    dips = np.hstack((dips_1.reshape(-1, 1), dips_2.reshape(-1, 1))).flatten()
    rakes = np.hstack((rakes_1.reshape(-1, 1), rakes_2.reshape(-1, 1))).flatten()
    final_stress_tensor = np.zeros((3, 3), dtype=np.float32)
    for i in range(n_averaging):
        if verbose &gt; 0:
            print(f&#39;-------- {i+1}/{n_averaging} ----------&#39;)
        # The stress inversion is sensitive to initial conditions,
        # which are random, especially when dealing with highly
        # noisy focal mechanisms. Therefore, one can repeat the inversion
        # n_averaging times and average the results.
        # -----------------------------------------
        # initialize the average stress tensor array by repeating the
        # stress inversion on n_random_selections datasets drawn by
        # randomly selecting either of the nodal planes as the fault planes
        avg_stress_tensor = np.zeros((3, 3), dtype=np.float32)
        for n in range(n_random_selections):
            nodal_planes = np.random.randint(0, 2, size=n_earthquakes)
            flat_indexes = np.int32(np.arange(n_earthquakes)*2+nodal_planes)
            selected_strikes = strikes[flat_indexes]
            selected_dips = dips[flat_indexes]
            selected_rakes = rakes[flat_indexes]
            # invert this subset of nodal planes
            if variable_shear:
                stress_tensor = \
                        iterative_linear_si(
                                selected_strikes, selected_dips, selected_rakes,
                                max_n_iterations=200, return_eigen=False,
                                Tarantola_kwargs=Tarantola_kwargs)
            else:
                stress_tensor = \
                        Michael1984_inversion(
                                selected_strikes, selected_dips, selected_rakes,
                                return_eigen=False, Tarantola_kwargs=Tarantola_kwargs)
            # add them to the average
            avg_stress_tensor += stress_tensor
        avg_stress_tensor /= float(n_random_selections)
        principal_stresses, principal_directions = \
                utils_stress.stress_tensor_eigendecomposition(avg_stress_tensor)
        R = utils_stress.R_(principal_stresses)
        if verbose &gt; 0:
            print(&#39;Initial shape ratio: {:.2f}&#39;.format(R))
        # uncomment the following lines if you want the friction parameter
        # to be derived from the initial stress tensor guess
        # (prone to overfitting)
        #friction_coefficient = find_optimal_friction(strikes_1, dips_1, rakes_1,
        #                                             strikes_2, dips_2, rakes_2,
        #                                             principal_directions, R,
        #                                             friction_min=friction_min,
        #                                             friction_max=friction_max,
        #                                             friction_step=friction_step)
        # uncomment the following line if you want to use a fixed friction value
        # I suggest to use 0.6 as it is a reasonable value and this does not
        # greatly influence the results anyway
        friction_coefficient = 0.60
        stress_tensor, C_m_post, C_d_post = _stress_inversion_instability(
                avg_stress_tensor, friction_coefficient,
                strikes_1, dips_1, rakes_1, strikes_2, dips_2, rakes_2,
                n_stress_iter=n_stress_iter, Tarantola_kwargs=Tarantola_kwargs,
                variable_shear=variable_shear, weighted=weighted,
                max_n_iterations=max_n_iterations,
                shear_update_atol=shear_update_atol,
                stress_tensor_update_atol=stress_tensor_update_atol,
                signed_instability=signed_instability,
                verbose=verbose, plot=plot)
        final_stress_tensor += stress_tensor
    final_stress_tensor /= float(n_averaging)
    principal_stresses, principal_directions = \
            utils_stress.stress_tensor_eigendecomposition(final_stress_tensor)
    R = utils_stress.R_(principal_stresses)
    # uncomment if you want to evaluate the friction
    # coefficient that maximizes instability, given
    # the stress tensor that was inverted
    # note: this is certainly a weird computation since we compute
    # the instability parameter to select the fault planes, and
    # then search for the value of friction coefficient that maximizes
    # the instability parameter on this set of fault planes, but this
    # new value would in turn select new fault planes...
    instability, fault_strikes, fault_dips, fault_rakes =\
            compute_instability_parameter(principal_directions, R, friction_coefficient,
                                          strikes_1, dips_1, rakes_1,
                                          strikes_2, dips_2, rakes_2,
                                          return_fault_planes=True,
                                          signed_instability=signed_instability)
    optimal_friction = find_optimal_friction_one_set(
            fault_strikes, fault_dips, fault_rakes,
            principal_directions, R,
            friction_min=friction_min,
            friction_max=friction_max,
            friction_step=friction_step)
    if verbose &gt; 0:
        print(&#39;Final results:&#39;)
        print(&#39;Stress tensor:\n&#39;, final_stress_tensor)
        print(&#39;Shape ratio: {:.2f}&#39;.format(R))
    output = (final_stress_tensor, optimal_friction,\
              principal_stresses, principal_directions,)
    if return_stats:
        output = output + (C_m_post, C_d_post,)
    return output</code></pre>
</details>
</dd>
<dt id="ILSI.ilsi.iterative_linear_si"><code class="name flex">
<span>def <span class="ident">iterative_linear_si</span></span>(<span>strikes, dips, rakes, max_n_iterations=300, shear_update_atol=1e-05, Tarantola_kwargs=None, return_eigen=True, return_stats=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterative stress inversion described in Beauce et al. 2021.
</p>
<p>This method assumes:<br>
- The tectonic stress field is uniform.<br>
- Wallace-Bott hypothesis: The slip vector points in the same
direction as shear stress on the fault.<br>
The parameters we invert for are the directions of the three
principal stresses and the shape ratio. Because this inversion does not
aim at infering the absolute stress values, we only consider the
deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot
determine the norm of the stress tensor, therefore sum sigma**2 = 1.
Each iteration of this inversion scheme is a linear inversion.
N.B.: This routine is written assuming outward footwall normals and slip
vectors of the hanging wall w.r.t. the footwall. Therefore, the stress
tensor sign convention is compression negative.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strikes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The strike of nodal planes 1, angle between north and
the fault's horizontal (0-360).</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The dip of nodal planes 1, angle between the horizontal
plane and the fault plane (0-90).</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>list</code> or <code>array, float</code></dt>
<dd>The rake of nodal planes 1, angle between the fault's horizontal
and the slip direction of the hanging wall w.r.t. the
foot wall (0-360 or -180-180).</dd>
<dt><strong><code>shear_update_atol</code></strong> :&ensp;<code>float</code>, default <code>to 1e-5</code></dt>
<dd>Convergence criterion on the shear stress magnitude updates.
Convergence is reached when the RMS difference between two
estimates of shear stress magnitudes falls below that threshold.</dd>
<dt><strong><code>max_n_iterations</code></strong> :&ensp;<code>integer</code>, default <code>to 300</code></dt>
<dd>The maximum number of iterations if shear stress magnitude update
does not fall below <code>shear_update_atol</code>.</dd>
<dt><strong><code>Tarantola_kwargs</code></strong> :&ensp;<code>Dictionary</code>, default <code>to None:</code></dt>
<dd>If not None, should contain key word arguments
for the Tarantola and Valette inversion.</dd>
<dt><strong><code>return_eigen</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, returns the eigendecomposition of the inverted
stress tensor in addition to returning the stress tensor.</dd>
<dt><strong><code>return_stats</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, the posterior data and model parameter distributions
estimated from the Tarantola and Valette formula
(cf. Tarantola_Valette routine).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>full_stress_tensor</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>The inverted stress tensor.</dd>
<dt><strong><code>principal_stresses</code></strong> :&ensp;<code>(3,) numpy array</code>, optional</dt>
<dd>The three eigenvalues of the stress tensor, ordered
from most compressive (sigma1) to least compressive (sigma3).
Only provided if <code>return_eigen</code> is True.</dd>
<dt><strong><code>principal_directions</code></strong> :&ensp;<code>(3, 3) numpy array</code>, optional</dt>
<dd>The three eigenvectors of the stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.
Only provided if <code>return_eigen</code> is True.</dd>
<dt><strong><code>C_m_posterior</code></strong> :&ensp;<code>(5, 5) array</code>, optional</dt>
<dd>Posterior covariance of the model parameter distribution
estimated from the Tarantola and Valette formula.
Only provided if <code>return_stats</code> is True.</dd>
<dt><strong><code>C_d_posterior</code></strong> :&ensp;<code>(3 x n_earthquakes, 3 x n_earthquakes) array</code>, optional</dt>
<dd>Posterior covariance of the data distribution
estimated from the Tarantola and Valette formula.
Only provided if <code>return_stats</code> is True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterative_linear_si(strikes, dips, rakes,
                        max_n_iterations=300,
                        shear_update_atol=1.e-5,
                        Tarantola_kwargs=None,
                        return_eigen=True,
                        return_stats=False):
    &#34;&#34;&#34;
    Iterative stress inversion described in Beauce et al. 2021.  

    This method assumes:  
        - The tectonic stress field is uniform.  
        - Wallace-Bott hypothesis: The slip vector points in the same
          direction as shear stress on the fault.  
    The parameters we invert for are the directions of the three
    principal stresses and the shape ratio. Because this inversion does not
    aim at infering the absolute stress values, we only consider the 
    deviatoric stress tensor, therefore Trace(sigma) = 0. Furthermore, we cannot 
    determine the norm of the stress tensor, therefore sum sigma**2 = 1.
    Each iteration of this inversion scheme is a linear inversion.
    N.B.: This routine is written assuming outward footwall normals and slip
    vectors of the hanging wall w.r.t. the footwall. Therefore, the stress
    tensor sign convention is compression negative.

    Parameters
    -----------
    strikes: list or array, float
        The strike of nodal planes 1, angle between north and
        the fault&#39;s horizontal (0-360).
    dips: list or array, float
        The dip of nodal planes 1, angle between the horizontal
        plane and the fault plane (0-90).
    rakes: list or array, float
        The rake of nodal planes 1, angle between the fault&#39;s horizontal
        and the slip direction of the hanging wall w.r.t. the
        foot wall (0-360 or -180-180).
    shear_update_atol: float, default to 1e-5
        Convergence criterion on the shear stress magnitude updates.
        Convergence is reached when the RMS difference between two
        estimates of shear stress magnitudes falls below that threshold. 
    max_n_iterations: integer, default to 300
        The maximum number of iterations if shear stress magnitude update
        does not fall below `shear_update_atol`.
    Tarantola_kwargs: Dictionary, default to None:
        If not None, should contain key word arguments
        for the Tarantola and Valette inversion.
    return_eigen: boolean, default to True
        If True, returns the eigendecomposition of the inverted
        stress tensor in addition to returning the stress tensor.
    return_stats: boolean, default to True
        If True, the posterior data and model parameter distributions
        estimated from the Tarantola and Valette formula
        (cf. Tarantola_Valette routine).

    Returns
    --------
    full_stress_tensor: (3, 3) numpy array
        The inverted stress tensor.
    principal_stresses: (3,) numpy array, optional
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
        Only provided if `return_eigen` is True.
    principal_directions: (3, 3) numpy array, optional
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`.
        Only provided if `return_eigen` is True.
    C_m_posterior: (5, 5) array, optional
        Posterior covariance of the model parameter distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    C_d_posterior: (3 x n_earthquakes, 3 x n_earthquakes) array, optional
        Posterior covariance of the data distribution
        estimated from the Tarantola and Valette formula.
        Only provided if `return_stats` is True.
    &#34;&#34;&#34;
    #t_start = give_time()
    # First, convert the strike/dip/rake into slip and normal vectors.
    n_earthquakes = len(strikes)
    n_ = np.zeros((n_earthquakes, 3), dtype=np.float32) # normal vectors
    d_ = np.zeros((n_earthquakes, 3), dtype=np.float32) # slip vectors
    for i in range(n_earthquakes):
        n_[i, :], d_[i, :] = utils_stress.normal_slip_vectors(
                                    strikes[i], dips[i], rakes[i], direction=&#39;inward&#39;)
    # Next, define the matrix that relates the stress tensor
    # to the observed slip vectors, given the fault geometries
    # characterized by the normal vectors.
    # For each earthquake, an (3 x 5) matrix relates the 5 independent
    # stress tensor components to the 3 slip vector components.
    G = forward_model(n_)
    if Tarantola_kwargs is not None:
        # -----------------------------------------
        # copy Tarantola_kwargs because all modifications are made in-place
        Tarantola_kwargs = Tarantola_kwargs.copy()
    else:
        Tarantola_kwargs = {}
    # initialize shear magnitudes
    if &#39;m_prior&#39; in Tarantola_kwargs:
        shear = np.sqrt(np.sum((G@Tarantola_kwargs[&#39;m_prior&#39;].astype(&#39;float32&#39;)).
            reshape(n_earthquakes, 3)**2, axis=-1))
    else:
        shear = np.ones(n_earthquakes, dtype=np.float32)
    for j in range(max_n_iterations):
        sigma, C_m_posterior, C_d_posterior = Tarantola_Valette(
                G, d_*shear[:, np.newaxis], **Tarantola_kwargs)
        sigma = sigma.squeeze()
        # normalize the stress tensor to make sure the units of
        # shear does not explode or vanish (it can behave like a
        # geometrical series), this normalization gives the reduced
        # stress tensor (up to a multiplicative constant)
        full_stress_tensor = np.array([[sigma[0], sigma[1], sigma[2]],
                                       [sigma[1], sigma[3], sigma[4]],
                                       [sigma[2], sigma[4], -sigma[0]-sigma[3]]])
        norm = np.sqrt(np.sum(full_stress_tensor**2))
        norm = 1 if norm == 0. else norm
        sigma /= norm
        Tarantola_kwargs[&#39;m_prior&#39;] = sigma.reshape(5, 1).copy()
        # Note: From Tarantola&#39;s book: in an iterative non-linear
        # inversion, he does not input the posterior distribution from
        # previous iteration to the next iteration. Doing so leads to
        # vanishing or exploding covariance matrices!
        # -----------------------------
        # compute shear magnitudes
        shear0 = shear.copy()
        shear = np.sqrt(np.sum((G@sigma).reshape(n_earthquakes, 3)**2, axis=-1))
        shear_update = np.sqrt(np.mean((shear-shear0)**2))
        #print(&#39;Shear stress update: {:.3e}&#39;.format(shear_update))
        if (shear_update &lt; shear_update_atol):
            # convergence has been reached, according to the
            # user-prescribed criterion
            #print(&#39;Stop at iteration {:d}! (shear update: {:.3e})&#39;.format(j, shear_update))
            break
    sigma = sigma.squeeze()
    # build full stress tensor
    full_stress_tensor = np.array([[sigma[0], sigma[1], sigma[2]],
                                   [sigma[1], sigma[3], sigma[4]],
                                   [sigma[2], sigma[4], -sigma[0]-sigma[3]]])
    norm = np.sqrt(np.sum(full_stress_tensor**2))
    norm = 1 if norm == 0. else norm
    full_stress_tensor /= norm
    output = full_stress_tensor,
    if return_eigen:
        # solve the eigenvalue problem
        principal_stresses, principal_directions = \
                utils_stress.stress_tensor_eigendecomposition(full_stress_tensor)
        output = output + (shear, principal_stresses, principal_directions,)
    if return_stats:
        output = output + (C_m_posterior, C_d_posterior,)
    #t_end = give_time()
    #print(&#39;iterative_linear_si finished in {:.2f}sec&#39;.format(t_end-t_start))
    if len(output) == 1:
        return output[0]
    else:
        return output</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ILSI" href="index.html">ILSI</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ILSI.ilsi.Michael1984_inversion" href="#ILSI.ilsi.Michael1984_inversion">Michael1984_inversion</a></code></li>
<li><code><a title="ILSI.ilsi.Tarantola_Valette" href="#ILSI.ilsi.Tarantola_Valette">Tarantola_Valette</a></code></li>
<li><code><a title="ILSI.ilsi.compute_instability_parameter" href="#ILSI.ilsi.compute_instability_parameter">compute_instability_parameter</a></code></li>
<li><code><a title="ILSI.ilsi.find_optimal_friction" href="#ILSI.ilsi.find_optimal_friction">find_optimal_friction</a></code></li>
<li><code><a title="ILSI.ilsi.find_optimal_friction_one_set" href="#ILSI.ilsi.find_optimal_friction_one_set">find_optimal_friction_one_set</a></code></li>
<li><code><a title="ILSI.ilsi.forward_model" href="#ILSI.ilsi.forward_model">forward_model</a></code></li>
<li><code><a title="ILSI.ilsi.inversion_bootstrap" href="#ILSI.ilsi.inversion_bootstrap">inversion_bootstrap</a></code></li>
<li><code><a title="ILSI.ilsi.inversion_bootstrap_instability" href="#ILSI.ilsi.inversion_bootstrap_instability">inversion_bootstrap_instability</a></code></li>
<li><code><a title="ILSI.ilsi.inversion_jackknife" href="#ILSI.ilsi.inversion_jackknife">inversion_jackknife</a></code></li>
<li><code><a title="ILSI.ilsi.inversion_jackknife_instability" href="#ILSI.ilsi.inversion_jackknife_instability">inversion_jackknife_instability</a></code></li>
<li><code><a title="ILSI.ilsi.inversion_one_set" href="#ILSI.ilsi.inversion_one_set">inversion_one_set</a></code></li>
<li><code><a title="ILSI.ilsi.inversion_one_set_instability" href="#ILSI.ilsi.inversion_one_set_instability">inversion_one_set_instability</a></code></li>
<li><code><a title="ILSI.ilsi.iterative_linear_si" href="#ILSI.ilsi.iterative_linear_si">iterative_linear_si</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>