<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ILSI.utils_stress API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ILSI.utils_stress</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys

import numpy as np
from numpy.linalg import LinAlgError

def hist2d(azimuths, plunges,
           nbins=200, smoothing_sig=0,
           plot=False):
    &#34;&#34;&#34;
    Computes the 2d histogram in the stereographic space
    of a collection lines described by their azimuth and plunge.

    Parameters
    -----------
    azimuths: (n_lines) list or array, float
        Azimuths of the lines.
    plunges: (n_lines) list or array, float
        Plunges (angle from horizontal) of the lines.
    nbins: integer, default to 200
        Number of bins, in both axes, used to discretized
        the 2d space.
    smoothing_sih: float, default to 0
        If greater than 0, smooth the 2d distribution
        with a gaussian kernel. This is useful to derive
        smooth confidence intervals.
    plot: boolean, default to False
        If True, plot the 2d histogram.
    &#34;&#34;&#34;
    import mplstereonet
    from scipy.ndimage.filters import gaussian_filter
    # convert azimuths and plunges to longitudes and latitudes
    # on a stereographic plot
    lons, lats = mplstereonet.stereonet_math.line(plunges, azimuths)
    count, lon_bins, lat_bins = np.histogram2d(
            lons, lats, range=([-np.pi/2., np.pi/2.], [-np.pi/2., np.pi/2.]), bins=nbins)
    lons_g, lats_g = np.meshgrid((lon_bins[1:] + lon_bins[:-1])/2.,
                                 (lat_bins[1:] + lat_bins[:-1])/2.,
                                 indexing=&#39;ij&#39;)
    if smoothing_sig &gt; 0:
        count = gaussian_filter(count, smoothing_sig)
    if plot:
        fig = plt.figure(&#39;2d_histogram_stereo&#39;, figsize=(18, 9))
        ax = fig.add_subplot(111, projection=&#39;stereonet&#39;)
        pcl = ax.pcolormesh(lons_g, lats_g, count)
        plt.colorbar(mappable=pcl)
    return count, lons_g, lats_g

def joint_CDF(count):
    # normalize the histogram
    density = count / np.sum(count)
    # integrate along first axis, and then along second axis
    # while keeping the original shape
    joint = np.cumsum(np.cumsum(density, axis=0), axis=1)
    return joint

def get_CI_levels(azimuths, plunges, confidence_intervals=[95., 90.],
                  nbins=200, smoothing_sig=1, return_count=False,
                  plot=False):
    &#34;&#34;&#34;
    Computes the 2d histogram in the stereographic space
    of a collection lines described by their azimuth and plunge.

    Parameters
    -----------
    azimuths: (n_lines) list or array, float
        Azimuths of the lines.
    plunges: (n_lines) list or array, float
        Plunges (angle from horizontal) of the lines.
    nbins: integer, default to 200
        Number of bins, in both axes, used to discretized
        the 2d space.
    smoothing_sig: float, default to 1
        If greater than 0, smooth the 2d distribution
        with a gaussian kernel. This is useful to derive
        smooth confidence intervals.
    plot: boolean, default to False
        If True, plot the 2d histogram.

    Returns
    ---------
    count: (nbins, nbins) array, integer, optional
        2D histogram of the lines dsecribed by azimuths and plunges.
        Only provided if `return_count` is True.
    lons_g: (nbins, nbins) array, float, optional
        2D grid of the longitudinal coordinate of each bin.
        Only provided if `return_count` is True.
    lats_g: (nbins, nbins) array, float, optional
        2D grid f the latitudinal coordinate of each bin.
        Only provided if `return_count` is True.
    confidence_intervals: (nbins, nbins) array, float
        2D distribution of the mass.
    &#34;&#34;&#34;
    from scipy.interpolate import interp1d
    # get histogram on a 2d grid
    count, lons_g, lats_g = hist2d(
            azimuths, plunges, nbins=nbins, smoothing_sig=smoothing_sig)
    # flatten the count array and sort it from largest to smallest
    count_vector = np.sort(count.copy().flatten())[::-1]
    # compute the &#34;CDF&#34; of the counts
    count_CDF = np.hstack(
            ([0.], np.cumsum(count_vector)/count_vector.sum(), [1.]))
    count_vector = np.hstack(([count_vector.max()+1.], count_vector, [0.]))
    # build an interpolator that gives the count number 
    # for a given % of the total mass
    mass_dist = interp1d(100.*count_CDF, count_vector)
    mass_dist_ = lambda x: mass_dist(x).item()
    confidence_intervals = list(
            map(mass_dist_, [k for k in confidence_intervals]))
    if plot:
        import matplotlib.pyplot as plt
        fig = plt.figure(&#39;2d_histogram_stereo&#39;, figsize=(18, 9))
        ax = fig.add_subplot(111, projection=&#39;stereonet&#39;)
        pcl = ax.pcolormesh(lons_g, lats_g, count)
        ax.contour(
                lons_g, lats_g, count,
                levels=confidence_intervals, zorder=2, cmap=&#39;jet&#39;)
        plt.colorbar(mappable=pcl)
    if return_count:
        return count, lons_g, lats_g, confidence_intervals
    else:
        return confidence_intervals

def get_CI_levels_joint(azimuths, plunges, confidence_intervals=[90., 95.],
                        nbins=200, smoothing_sig=1, return_count=False,
                        plot=False):
    &#34;&#34;&#34;
    Computes the 2d histogram in the stereographic space
    of a collection lines described by their azimuth and plunge.
    This is an EXPERIMENTAL function.

    Parameters
    -----------
    azimuths: (n_lines) list or array, float
        Azimuths of the lines.
    plunges: (n_lines) list or array, float
        Plunges (angle from horizontal) of the lines.
    nbins: integer, default to 200
        Number of bins, in both axes, used to discretized
        the 2d space.
    smoothing_sig: float, default to 1
        If greater than 0, smooth the 2d distribution
        with a gaussian kernel. This is useful to derive
        smooth confidence intervals.
    plot: boolean, default to False
        If True, plot the 2d histogram.

    Returns
    ---------
    count: (nbins, nbins) array, integer, optional
        2D histogram of the lines dsecribed by azimuths and plunges.
        Only provided if `return_count` is True.
    lons_g: (nbins, nbins) array, float, optional
        2D grid of the longitudinal coordinate of each bin.
        Only provided if `return_count` is True.
    lats_g: (nbins, nbins) array, float, optional
        2D grid f the latitudinal coordinate of each bin.
        Only provided if `return_count` is True.
    confidence_intervals: (nbins, nbins) array, float
        2D distribution of the mass.
    &#34;&#34;&#34;
    from scipy.interpolate import interp1d
    # get histogram on a 2d grid
    count, lons_g, lats_g = hist2d(
            azimuths, plunges, nbins=nbins, smoothing_sig=smoothing_sig)
    # compute the joint cumulative distribution function (CDF)
    joint = joint_CDF(count)
    # because we define the (1-2a) confidence interval from the
    # a-th and the (1-a)-th percentiles, we conveniently define the
    # following function:
    g = 2.*np.abs(joint - 0.5)*100.
    # all points for which g &lt; 1-2a are within the 1-2a confidence interval
    if plot:
        import matplotlib.pyplot as plt
        confidence_intervals.sort()
        fig = plt.figure(&#39;2d_histogram_stereo&#39;, figsize=(18, 9))
        ax1 = fig.add_subplot(221, projection=&#39;stereonet&#39;)
        pcl1 = ax1.pcolormesh(lons_g, lats_g, count)
        ax1.contour(lons_g, lats_g, g,
                    levels=confidence_intervals, zorder=2, cmap=&#39;jet&#39;)
        plt.colorbar(mappable=pcl1)
        ax2 = fig.add_subplot(222, projection=&#39;stereonet&#39;)
        pcl2 = ax2.pcolormesh(lons_g, lats_g, joint)
        ax2.contour(lons_g, lats_g, g,
                    levels=confidence_intervals, zorder=2, cmap=&#39;jet&#39;)
        plt.colorbar(mappable=pcl2)
        ax3 = fig.add_subplot(223, projection=&#39;stereonet&#39;)
        pcl3 = ax3.pcolormesh(lons_g, lats_g, g)
        ax3.contour(lons_g, lats_g, g,
                    levels=confidence_intervals, zorder=2, cmap=&#39;jet&#39;)
        plt.colorbar(mappable=pcl3)
    if return_count:
        return count, lons_g, lats_g, confidence_intervals
    else:
        return confidence_intervals

def angular_residual(stress_tensor, strikes, dips, rakes):
    &#34;&#34;&#34;
    Compute the angle between the direction of the resolved shear
    stress predicted by the stress tensor and the direction of
    slip given by the strike/dip/rake data.

    Parameters
    ------------
    stress_tensor: (3, 3) array
        The Cauchy stress tensor.
    strikes: (n_earthquakes) list or array
        Fault strikes.
    dips: (n_earthquakes) list or array
        Fault dips.
    rakes: (n_earthquakes) list or array
        Fault rakes.

    Returns
    ----------
    angles: (n_earthquakes) array
        Angles between shear stress and slip.
    &#34;&#34;&#34;
    angles = np.zeros(len(strikes), dtype=np.float32)
    for i in range(len(strikes)):
        angles[i] = shear_slip_angle_difference(
                stress_tensor, strikes[i], dips[i], rakes[i])
    return angles

def aux_plane(s1, d1, r1):
    &#34;&#34;&#34;
    Get Strike and dip of second plane.
    
    Adapted from MATLAB script
    `bb.m &lt;http://www.ceri.memphis.edu/people/olboyd/Software/Software.html&gt;`_
    written by Andy Michael, Chen Ji and Oliver Boyd.

    Taken from &lt;https://docs.obspy.org/_modules/obspy/imaging/beachball.html#aux_plane&gt;.  
    See Obspy project at &lt;https://github.com/obspy/obspy&gt;.
    &#34;&#34;&#34;
    r2d = 180 / np.pi

    def _strike_dip(n, e, u):
        &#34;&#34;&#34;
        Finds strike and dip of plane given normal vector having components n, e,
        and u.
        
        Adapted from MATLAB script
        `bb.m &lt;http://www.ceri.memphis.edu/people/olboyd/Software/Software.html&gt;`_
        written by Andy Michael, Chen Ji and Oliver Boyd.
        &#34;&#34;&#34;
        r2d = 180 / np.pi
        if u &lt; 0:
            n = -n
            e = -e
            u = -u

        strike = np.arctan2(e, n) * r2d
        strike = strike - 90
        while strike &gt;= 360:
            strike = strike - 360
        while strike &lt; 0:
            strike = strike + 360
        x = np.sqrt(np.power(n, 2) + np.power(e, 2))
        dip = np.arctan2(x, u) * r2d
        return (strike, dip)

    # modified by me:
    if r1 &gt; 180.:
        # convert rake between 0 and 360
        # to rake between -180 and +180
        r1 = r1-360.
    
    z = (s1 + 90) / r2d
    z2 = d1 / r2d
    z3 = r1 / r2d
    # slick vector in plane 1
    sl1 = -np.cos(z3) * np.cos(z) - np.sin(z3) * np.sin(z) * np.cos(z2)
    sl2 = np.cos(z3) * np.sin(z) - np.sin(z3) * np.cos(z) * np.cos(z2)
    sl3 = np.sin(z3) * np.sin(z2)
    (strike, dip) = _strike_dip(sl2, sl1, sl3)
    
    n1 = np.sin(z) * np.sin(z2)  # normal vector to plane 1
    n2 = np.cos(z) * np.sin(z2)
    h1 = -sl2  # strike vector of plane 2
    h2 = sl1
    # note h3=0 always so we leave it out
    # n3 = np.cos(z2)
    
    z = h1 * n1 + h2 * n2
    z = z / np.sqrt(h1 * h1 + h2 * h2)
    # we might get above 1.0 only due to floating point
    # precision. Clip for those cases.
    float64epsilon = 2.2204460492503131e-16
    if 1.0 &lt; abs(z) &lt; 1.0 + 100 * float64epsilon:
        z = np.copysign(1.0, z)
    z = np.arccos(round_cos(z))
    rake = 0
    if sl3 &gt; 0:
        rake = z * r2d
    if sl3 &lt;= 0:
        rake = -z * r2d
    return strike%360., dip, rake%360.

def check_right_handedness(basis):
    &#34;&#34;&#34;
    Make sure the matrix of column vectors forms
    a right-handed basis. This is particularly important
    when re-ordering the principal stress directions
    based on their eigenvalues.

    Parameters
    -----------
    basis: (3, 3) numpy array
        Matrix with column vectors that form the basis of interest.

    Returns
    ----------
    rh_basis: (3, 3) numpy array
        Matrix with column vectors that form the right-handed
        version of the input basis. One of the unit vectors
        might have been reversed in the process.
    &#34;&#34;&#34;
    vector1 = basis[:, 0]
    vector2 = basis[:, 1]
    vector3 = np.cross(vector1, vector2)
    return np.stack([vector1, vector2, vector3], axis=1)

def compute_traction(stress_tensor, normal):
    &#34;&#34;&#34;
    Parameters
    -----------
    stress_tensor: (3, 3) numpy array
        Cauchy stress tensor.
    normal: (n_earthquakes, 3) numpy array
        Matrix of n_earthquakes row vectors of fault normals.

    Returns
    --------
    traction: (n_earthquakes, 3) numpy array
        Tractions on the surfaces defined by normal.
    normal_traction: (n_earthquakes, 3) numpy array
        Normal component of the tractions.
    shear_traction: (n_earthquakes, 3) numpy array
        Tangential component of the tractions.
    &#34;&#34;&#34;
    traction = np.dot(stress_tensor, normal.T).T
    normal_traction = np.sum(traction*normal, axis=-1)[:, np.newaxis]\
                      *normal
    shear_traction = traction - normal_traction
    return traction, normal_traction, shear_traction


def errors_in_data(strike, dip, rake,
                   jack_strikes_1, jack_dips_1, jack_rakes_1,
                   jack_strikes_2, jack_dips_2, jack_rakes_2):
    &#34;&#34;&#34;
    This routines was tailored for my applications.
    Use the multiple solutions obtained during the jackknife resampling
    of the focal mechanism inversion to compute the deviation of these
    multiple solutions from the best solution. A low deviation means a
    good quality focal mechanism. Because there are two possible slip vectors
    for each focal mechanism solution, we systematically look among the
    jackknife solutions 1 and 2 for the closest slip vector to the target
    vector, defined by (strike, dip, rake).
    We recommend to run this function for (strike, dip, rake)_1 and
    (strike, dip, rake)_2 of the best focal mechanism solution, and
    average the outputs.
    &#34;&#34;&#34;
    r2d = 180./np.pi
    n_jackknife = len(jack_strikes_1)
    # slip vector from the best nodal plane
    _, slip_vector_best = normal_slip_vectors(strike, dip, rake)
    # slip vectors from the jackknife nodal planes
    slip_vectors = np.zeros((n_jackknife, 2, 3), dtype=np.float32)
    # angles between the jackknife slip vectors and the best slip vector
    # since it is ambiguous which of the planes are the fault planes,
    # we simply systematically compute the angle between both planes
    # and keep the lowest angle.
    slip_angles = np.zeros(n_jackknife, dtype=np.float32)
    for i in range(n_jackknife):
        _, slip_vectors[i, 0, :] = normal_slip_vectors(
                jack_strikes_1[i], jack_dips_1[i], jack_rakes_1[i])
        _, slip_vectors[i, 1, :] = normal_slip_vectors(
                jack_strikes_2[i], jack_dips_2[i], jack_rakes_2[i])
    # a little bit of clipping is necessary in case of numerical errors
    # putting the scalar products sligthly above or below +1/-1.
    scalar_prod1 = np.clip(np.sum(slip_vectors[:, 0, :]*slip_vector_best, axis=-1), -1., +1.)
    scalar_prod2 = np.clip(np.sum(slip_vectors[:, 1, :]*slip_vector_best, axis=-1), -1., +1.)
    angles_1 = np.arccos(scalar_prod1)
    angles_2 = np.arccos(scalar_prod2)
    abs_angles_1 = np.abs(np.arccos(scalar_prod1))
    abs_angles_2 = np.abs(np.arccos(scalar_prod2))
    slip_angles = np.minimum(abs_angles_1, abs_angles_2)*r2d
    mask1 = abs_angles_1 &lt; abs_angles_2
    slip_angles[mask1] *= np.sign(angles_1[mask1])
    mask2 = abs_angles_2 &lt;= abs_angles_1
    slip_angles[mask2] *= np.sign(angles_2[mask2])
    slip_vectors_ = np.zeros((n_jackknife, 3), dtype=np.float32)
    # get the closest slip vectors
    slip_vectors_[mask1, :] = slip_vectors[mask1, 0, :]
    slip_vectors_[mask2, :] = slip_vectors[mask2, 1, :]
    # we can now use the standard deviations on each of the
    # 3 components to estimate errors in the data and use
    # Tarantola and Valette formula
    dev_n = 1.42*np.median(np.abs(slip_vectors_[:, 0] - slip_vector_best[0]))
    dev_w = 1.42*np.median(np.abs(slip_vectors_[:, 1] - slip_vector_best[1]))
    dev_z = 1.42*np.median(np.abs(slip_vectors_[:, 2] - slip_vector_best[2]))
    #for i in range(3):
    #    plt.hist(slip_vectors_[:, i], bins=20)
    #    plt.axvline(slip_vector_best[i], lw=2, color=&#39;C{:d}&#39;.format(i))
    #plt.show()
    return dev_n, dev_w, dev_z

def get_bearing_plunge(u, degrees=True, hemisphere=&#39;lower&#39;):
    &#34;&#34;&#34;
    The vectors are in the coordinate system (x1, x2, x3):  
    x1: north  
    x2: west  
    x3: upward  

    Parameters
    -----------
    u: (3) array or list
        Vector for which we want the bearing (azimuth) and plunge.
    degrees: boolean, default to True
        If True, returns bearing and plunge in degrees.
        In radians otherwise.
    hemisphere: string, default to &#39;lower&#39;
        Consider the intersection of the line defined by u
        with the lower hemisphere if `hemisphere` is &#39;lower&#39;, or
        with the upper hemisphere if `hemisphere` is &#39;upper&#39;.

    Returns
    ---------
    bearing: float
        Angle between the north and the line.
    plunge: float
        Angle between the horizontal plane and the line.
    &#34;&#34;&#34;
    r2d = 180./np.pi
    if hemisphere == &#39;lower&#39; and u[2] &gt; 0.:
        # we need to consider the end of the line
        # that plunges downward and crosses the
        # lower hemisphere
        u = -1.*u
    elif hemisphere == &#39;upper&#39; and u[2] &lt; 0.:
        u = -1.*u
    # the trigonometric sense is the opposite of the azimuthal sense,
    # therefore we need a -1 multiplicative factor
    bearing = -1.*np.arctan2(u[1], u[0])
    # the plunge is measured downward from the end of the
    # line specified by the bearing
    # this formula is valid for p_axis[2] &lt; 0
    plunge = (np.arccos(round_cos(u[2])) - np.pi/2.)
    if hemisphere == &#39;upper&#39;:
        plunge *= -1.
    if degrees:
        return (bearing*r2d)%360., plunge*r2d
    else:
        return bearing, plunge

def kagan_angle(tensor1, tensor2):
    &#34;&#34;&#34;
    Compute the minimum rotation about *some* axis required
    to match the two tensors. This angle is a measure of their
    difference.

    Parameters
    -----------
    tensor1: (3, 3) numpy array
        First tensor, e.g. moment or stress tensor.
    tensor2: (3, 3) numpy array
        Second tensor, e.g. moment of stress tensor.

    Returns
    --------
    rotation_angle: scalar float
        Smallest angle, in degrees, required to superimpose
        the two tensors.
    &#34;&#34;&#34;
    theta = np.pi
    Rx = np.array([[1., 0., 0.],
                   [0., np.cos(theta), -np.sin(theta)],
                   [0., np.sin(theta), np.cos(theta)]])
    # first, compute the eigendecomposition of each tensor using
    # the stress tensor eigendecomposition routine, i.e. that returns
    # the eigen values and vectors ordered from the most to least
    # compressive axes
    # make sure to do the change of basis from
    # (north, west, up) to (north, east, down)
    #eigval1, eigvec1 = stress_tensor_eigendecomposition(Rx.dot(tensor1.dot(Rx.T)))
    #eigval2, eigvec2 = stress_tensor_eigendecomposition(Rx.dot(tensor2.dot(Rx.T)))
    eigval1, eigvec1 = stress_tensor_eigendecomposition(tensor1)
    eigval2, eigvec2 = stress_tensor_eigendecomposition(tensor2)
    eigvec1 = check_right_handedness(np.stack([eigvec1[:, 2], eigvec1[:, 0], eigvec1[:, 1]], axis=1))
    eigvec2 = check_right_handedness(np.stack([eigvec2[:, 2], eigvec2[:, 0], eigvec2[:, 1]], axis=1))
    # second, compute the rotation matrix that takes one basis to the other
    R12 = np.dot(eigvec1.T, eigvec2)
    # compute the quaternion associated with this rotation matrix
    q = quaternion(R12[:, 0], R12[:, 1], R12[:, 2])
    # the minimum angle about some axis to superimpose the two
    # input tensors is:
    min_angle = np.arccos(round_cos(np.max(np.abs(q))))
    return 2.*np.rad2deg(min_angle)

def mean_angular_residual(stress_tensor, strikes, dips, rakes):
    &#34;&#34;&#34;
    Mean of the absolute value of the angles returned by
    angular_residual. See angular_residual for more info.
    &#34;&#34;&#34;
    return np.mean(np.abs(angular_residual(stress_tensor, strikes, dips, rakes)))

def mean_kagan_angle(strikes, dips, rakes,
                     strike0=None, dip0=None, rake0=None):
    &#34;&#34;&#34;Computes the mean kagan angle as a measure of dispersion.  

    The mean kagan angle within a population of focal mechanisms
    described by strikes/dips/rakes. If strike0, dip0, and rake0
    are specified, then the mean kagan angle is computed not from
    all pairs of focal mechanisms, but only between all focal mechanisms
    and the reference focal mechanism described by strike0/dip0/rake0.
    The mean kagan angle can be interpreted as a measure of dispersion
    within the population.

    Parameters
    -----------
    strikes: numpy array or list, float
        Strikes of the moment tensors.
    dips: numpy array or list, float
        Dips of the moment tensors.
    rakes: numpy array or list, float
        Rakes of the moment tensors.
    strike0: scalar, float, default to None
        Strike of the reference moment tensor.
    dip0: scalar, float, default to None
        Dip of the reference moment tensor.
    rake0: scalar, float, default to None
        Rake of the reference moment tensor.

    Returns
    --------
    mean_angle: scalar, float
        Mean kagan angle between the moment tensors given as input.
    &#34;&#34;&#34;
    from functools import partial
    mts = np.zeros((len(strikes), 3, 3), dtype=np.float32)
    for i in range(len(strikes)):
        mts[i, ...] = strike_dip_rake_to_mt(strikes[i], dips[i], rakes[i])
    if strike0 is not None:
        mt0 = strike_dip_rake_to_mt(strike0, dip0, rake0)
        angles = list(map(partial(kagan_angle, mt0), mts))
    else:
        angles = sum([list(map(
            partial(kagan_angle, mts[i, ...]), mts))
            for i in range(mts.shape[0])], [])
    return np.mean(np.asarray(angles))

def normal_slip_vectors(strike, dip, rake, direction=&#39;inward&#39;):
    &#34;&#34;&#34;
    Determine the normal and the slip vectors of the
    focal mechanism defined by (strike, dip, rake).
    From Stein and Wysession 2002.  

    N.B.: This is the normal of the FOOT WALL and the slip
    of the HANGING WALL w.r.t the foot wall. It means that the
    normal is an inward-pointing normal for the hanging wall,
    and an outward pointing-normal for the foot wall.

    The vectors are in the coordinate system (x1, x2, x3):  
    x1: north  
    x2: west  
    x3: upward  

    Parameters
    ------------
    strike: float
        Strike of the fault.
    dip: float
        Dip of the fault.
    rake: float
        Rake of the fault.
    direction: string, default to &#39;inward&#39;
        If &#39;inward&#39;, returns the inward normal of the HANGING wall,
        which is the formula given in Stein and Wysession. Equivalently,
        this is the outward normal of the foot wall.
        If &#39;outward&#39;, returns the outward normal of the HANGING wall,
        or, equivalently, the inward normal of the hanging wall.

    Returns
    -----------
    n: (3) array
        The fault normal.
    d: (3) array
        The slip vector given as the direction of motion
        of the hanging wall w.r.t. the foot wall.
    &#34;&#34;&#34;
    d2r = np.pi/180.
    strike = strike*d2r
    dip = dip*d2r
    rake = rake*d2r
    n = np.array([-np.sin(dip)*np.sin(strike),
                  -np.sin(dip)*np.cos(strike),
                  np.cos(dip)])
    if direction == &#39;inward&#39;:
        # this formula already gives the inward-pointing
        # normal of the hanging wall
        pass
    elif direction == &#39;outward&#39;:
        n *= -1.
    else:
        print(&#39;direction should be either &#34;inward&#34; or &#34;outward&#34;&#39;)
        return
    # slip on the hanging wall
    d = np.array([np.cos(rake)*np.cos(strike) + np.sin(rake)*np.cos(dip)*np.sin(strike),
                  -np.cos(rake)*np.sin(strike) + np.sin(rake)*np.cos(dip)*np.cos(strike),
                  np.sin(rake)*np.sin(dip)])
    return n, d

def principal_faults(stress_tensor, friction_coefficient):
    &#34;&#34;&#34;
    Compute the orientation of the most unstable fault planes given
    a stress tensor and a coefficient of friction. These faults are
    called the principal faults.

    Parameters
    -----------
    stress_tensor: (3, 3) numpy array
        Cauchy stress tensor.
    friction_coefficient: scalar float
        Coefficient of friction used for the Mohr-Coulomb
        failure criterion.

    Returns
    ---------
    n1: (3, 1) numpy array
        Normal of the first principal faults.
    n2: (3, 1) numpy array
        Normal of the second principal faults. The two
        faults form a pair of conjugate faults.
    &#34;&#34;&#34;
    # first, compute the angle between sigma 1 and the normal
    # of the most unstable plane
    lbd = np.pi/4. + 1./2.*np.arctan(friction_coefficient)
    # the coordinates of the fault normal in the eigenbasis is:
    n1 = np.array([np.cos(lbd), 0., np.sin(lbd)])
    n2 = np.array([np.cos(lbd), 0., np.sin(-1.*lbd)])
    # compute the eigenbasis
    principal_sig, principal_dir = stress_tensor_eigendecomposition(
            stress_tensor)
    n1 = np.dot(principal_dir, n1[:, np.newaxis])
    n2 = np.dot(principal_dir, n2[:, np.newaxis])
    return n1, n2

def p_t_b_axes(normal, slip):
    &#34;&#34;&#34;
    Determine the P (most compressive), T (least compressive)
    and B (intermediate, or neutral axis) axes 
    from the normal and the slip vectors, following
    Stein and Wysession 2002, Section 4.5.2.
    (P, T, B) forms an orthogonal basis.

    The vectors are in the coordinate system (x1, x2, x3):
    x1: north
    x2: west
    x3: upward
    &#34;&#34;&#34;
    p = normal - slip
    p /= np.sqrt(np.sum(p**2))
    t = normal + slip
    t /= np.sqrt(np.sum(t**2))
    b = np.cross(normal, slip)
    b /= np.sqrt(np.sum(b**2))
    return p, t, b

def quaternion(t, p, b):
    &#34;&#34;&#34;
    Formula of quaternion of rotation matrix with `t` (least compressive),
    `p` (most compressive), `b` (neutral) components expressed in the
    (north, east, down) frame of reference.
    `t`, `p`, `b` can equivalently be the sigma_3, sigma_1, sigma_2 components.
    Make sure (`t`, `p`, `b`) form a right-handed basis.
    This routine was copied from the _tpb2q routine of the Pyrocko Python
    project (see at https://pyrocko.org/docs/current/_modules/pyrocko/moment_tensor.html#kagan_angle).

    Parameters
    -----------
    t: (3,) numpy array or list
    p: (3,) numpy array or list
    b: (3,) numpy array or list

    Returns
    --------
    quaternion: (4,) numpy array
        The quaternion that represents the rotation represented by
        the matrix (t, p, b), where t, p, b are column vectors.
    &#34;&#34;&#34;
    eps = 0.0001
    x1, x2, x3 = np.float64(t), np.float64(p), np.float64(b) 
    q0 = 1. + x1[0] + x2[1] + x3[2]
    q1 = 1. + x1[0] - x2[1] - x3[2]
    q2 = 1. - x1[0] + x2[1] - x3[2]
    q3 = 1. - x1[0] - x2[1] + x3[2]

    q = np.zeros(4, dtype=np.float64)
    if q0 &gt; eps:
        q[0] = 0.5 * np.sqrt(q0)
        q[1] = x2[2] - x3[1]
        q[2] = x3[0] - x1[2]
        q[3] = x1[1] - x2[0]
    elif q1 &gt; eps:
        q[0] = 0.5 * np.sqrt(q1)
        q[1] = x2[2] - x3[1]
        q[2] = x2[0] + x1[1]
        q[3] = x3[0] + x1[2]
    elif q2 &gt; eps:
        q[0] = 0.5 * np.sqrt(q2)
        q[1] = x3[0] - x1[2]
        q[2] = x2[0] + x1[1]
        q[3] = x3[1] + x2[2]
    elif q3 &gt; eps:
        q[0] = 0.5 * np.sqrt(q3)
        q[1] = x1[1] - x2[0]
        q[2] = x3[0] + x1[2]
        q[3] = x3[1] + x2[2]
    else:
        print(&#39;Could not find the lowest component!&#39;)
        sys.exit(0)

    # normalize the components of the quaternion
    q[1:] /= 4.0*q[0]
    q /= np.sqrt(np.sum(q**2))

    return q


def R_(principal_stresses):
    &#34;&#34;&#34;
    Computes the shape ratio R=(sig1-sig2)/(sig1-sig3).

    Parameters
    -----------
    pinricpal_stresses: numpy array or list
        Contains the three eigenvalues of the stress tensor
        ordered such that:   
        `principal_stresses[0]` &lt; `principal_stresses[1]` &lt; `principal_stresses[2]`
        with `principal_stresses[0]` being the most compressional stress.

    Returns
    ---------
    shape_ratio: scalar float
    &#34;&#34;&#34;
    return (principal_stresses[0]-principal_stresses[1])\
          /(principal_stresses[0]-principal_stresses[2])

def rotation(axis, angle):
    &#34;&#34;&#34;Compute the rotation matrix about axis with angle `angle`.  

    Parameters
    ------------
    axis: (3) numpy array, float
        Axis about which the rotation is computed.
    angle: scalar, float
        Angle, in degrees, of the rotation.

    Returns
    --------
    R: (3, 3) numpy array, float
        Rotation matrix of angle `angle` degrees about `axis`.
    &#34;&#34;&#34;
    x1, x2, x3 = axis
    a = angle*np.pi/180.
    # build the rotation matrix
    ca, sa = np.cos(a), np.sin(a)
    R = np.array([[ca + x1**2*(1.-ca), x1*x2*(1.-ca) - x3*sa, x1*x3*(1.-ca) + x2*sa],
                  [x1*x2*(1.-ca) + x3*sa, ca + x2**2*(1.-ca), x2*x3*(1.-ca) - x1*sa],
                  [x1*x3*(1.-ca) - x2*sa, x2*x3*(1.-ca) + x1*sa, ca + x3**2*(1.-ca)]])
    return R

def random_rotation(max_angle=360.):
    &#34;&#34;&#34;Generate a random rotation matrix.  

    Generate a random rotation matrix by:  
      1) Generate a random unit vector in 3D.  
      2) Generate a random rotation angle between 0 and max_angle (degrees)  

    Parameters
    ------------
    max_angle: scalar float, default to 360
        Upper bound of the uniform distribution from which the rotation
        angle is randomly drawn.

    Returns
    --------
    R: (3, 3) numpy array
        Rotation matrix.
    &#34;&#34;&#34;
    x1, x2, x3 = np.random.uniform(low=-1., high=1., size=3)
    dir_ = np.array([x1, x2, x3])
    # normalize
    dir_ /= np.linalg.norm(dir_, 2)
    # draw the angle
    a = max_angle*np.random.random()
    R = rotation(dir_, a)
    return R

def reduced_stress_tensor(principal_directions, R):
    &#34;&#34;&#34;
    Computes a normalized stress tensor where the most
    and least compressive principal stresses are set to
    -1 and +1, respectively, and the intermediate stress
    is determined by the shape ratio.

    Parameters
    -----------
    principal_directions: (3, 3) numpy array.
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`. 
    R: float
        The shape ratio (sig1 - sig2)/(sig1 - sig3).
       
    Returns
    ----------
    stress_tensor: (3, 3) array
        The stress tensor built from the principal directions
        and the shape ratio.
    &#34;&#34;&#34;
    sig1 = -1.
    sig2 = 2.*R-1.
    sig3 = +1
    Sigma = np.diag(np.array([sig1, sig2, sig3]))
    Sigma /= np.sqrt(np.sum(Sigma**2))
    # make sure the principal directions form a right-handed basis
    principal_directions = check_right_handedness(principal_directions)
    stress_tensor = np.dot(principal_directions,
                           np.dot(Sigma, principal_directions.T))
    return stress_tensor

def round_cos(x):
    &#34;&#34;&#34;Clip x so that it fits with the [-1,1] interval.  

    If x is slightly outside the [-1,1] because of numerical
    imprecision, x is rounded, and can then be safely passed
    to arccos or arcsin. If x is truly outside of [-1,1], x
    is returned unchanged.

    Parameters
    -----------
    x: scalar, float
        Float variable that represents a cos or sin that
        is supposed to be within the [-1,1] interval.

    Returns
    -----------
    x_r: scalar, float
       A rounded version of x, if necessary. 
    &#34;&#34;&#34;
    if (abs(x) &gt; 1.0) and (abs(x) &lt; 1.005):
        return 1.0*np.sign(x)
    else:
        return x

def stress_tensor_eigendecomposition(stress_tensor):
    &#34;&#34;&#34;
    Parameters
    -----------
    stress_tensor: (3, 3) numpy array.
        The stress tensor for which to solve the
        eigenvalue problem.
    Returns
    --------
    principal_stresses: (3,) numpy array.
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    principal_directions: (3, 3) numpy array.
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`. 
    &#34;&#34;&#34;
    try:
        principal_stresses, principal_directions = \
                              np.linalg.eigh(stress_tensor)
    except LinAlgError:
        print(stress_tensor)
        sys.exit()
    #order = np.argsort(principal_stresses)[::-1]
    order = np.argsort(principal_stresses)
    # reorder from most compressive to most extensional
    # with tension positive convention
    # (note: principal_directions is the matrix a column-eigenvectors)
    principal_stresses = principal_stresses[order]
    principal_directions = check_right_handedness(principal_directions[:, order])
    return principal_stresses, principal_directions

def strike_dip_rake(n, d):
    &#34;&#34;&#34;
    Invert the relationships between strike/dip/rake
    and normal (n) and slip (d) vectors found in Stein.
    n and d are required to be given as the default format
    returned by normal_slip_vectors.

    Parameters
    -----------
    n: (3) array
        The outward pointing normal of the FOOT wall.
    d: (3) array
        The slip direction of the hanging wall w.r.t.
        the foot wall.

    Returns
    ---------
    strike: float
        Strike of the fault, in degress.
    dip: float
        Dip of the fault, in degrees.
    rake: float
        Rake of the fault, in degrees.
    &#34;&#34;&#34;
    r2d = 180./np.pi
    # ----------------
    # dip is straightforward:
    dip = np.arccos(round_cos(n[2]))
    sin_dip = np.sin(dip)
    if sin_dip != 0.:
        # ----------------
        # strike is more complicated because it spans 0-360 degrees
        sin_strike = -n[0]/sin_dip
        cos_strike = -n[1]/sin_dip
        strike = np.arctan2(sin_strike, cos_strike)
        # ---------------
        # rake is even more complicated
        sin_rake = d[2]/sin_dip
        cos_rake = (d[0] - sin_rake*np.cos(dip)*sin_strike)/cos_strike
        rake = np.arctan2(sin_rake, cos_rake)
    else:
        print(&#39;Dip is zero! The strike and rake cannot be determined&#39;)
        # the solution is ill-defined, we can only
        # determine rake - strike
        cos_rake_m_strike = d[0]
        sin_rake_m_strike = d[1]
        rake_m_strike = np.arctan2(sin_rake_m_strike, cos_rake_m_strike)
        # fix arbitrarily the rake to zero
        rake = 0.
        strike = -rake_m_strike
    return (strike*r2d)%360., dip*r2d, (rake*r2d)%360.

def strike_dip_rake_to_mt(strike, dip, rake):
    &#34;&#34;&#34;Compute the *normalized* moment tensor described by strike/dip/rake.

    Parameters
    -----------
    strike: scalar, float
        Strike of the input focal mechanism.
    dip: scalar, float
        Dip of the input focal mechanism.
    rake: scalar, float
        Rake of the input focal mechanism.

    Returns
    ---------
    mt: (3, 3) numpy array, float
        Normalized moment tensor. Its columns are the
        (p, b, t) axes. Note: we return (p, b, t) to be
        consistent with our stress tensor convention (sig1, sig2, sig3).
    &#34;&#34;&#34;
    # first, compute the normal and slip vectors
    n, d = normal_slip_vectors(strike, dip, rake)
    # second, compute the t, p, b axes
    p, t, b = p_t_b_axes(n, d)
    # build a matrix with columns (p b t) and make sure these form
    # a right-handed basis, this is the eigenbasis of the moment tensor
    U = check_right_handedness(np.stack([p, b, t], axis=1))
    # build the matrix of eigenvalues (a double-couple is a deviatoric
    # moment tensor with determinant = 0, see Tape and Tape 2012)
    Lambda = np.array([[-1., 0., 0.],
                       [0., 0., 0.],
                       [0., 0., +1.]], dtype=np.float32)
    mt = U.dot(Lambda.dot(U.T))
    mt /= np.sqrt(np.sum(mt**2))
    return mt

def shear_slip_angle_difference(stress_tensor, strike, dip, rake):
    &#34;&#34;&#34;
    Return the angle difference between the slip vector
    from the focal mechanism solution and the shear traction
    on the fault determined from the inverted stress tensor.
    Given that the stress inversion is made under the Wallace-Bott
    assumption, shear stress on the fault is parallel to slip, then
    this angle difference is a measure of misfit.

    Parameters
    -----------
    stress_tensor: (3, 3) array
        The Cauchy stress tensor.
    strike: float
        Strike of the fault.
    dip: float
        Dip of the fault.
    rake: float
        Rake of the fault.

    Returns
    -----------
    angle: float
        The angle between shear stress and slip, in degrees.
    &#34;&#34;&#34;
    # first, get the normal and slip vectors corresponding
    # to (strike, dip, rake)
    n, d = normal_slip_vectors(strike, dip, rake, direction=&#39;inward&#39;)
    n = n.reshape(1, -1) # make sure it&#39;s a row vector
    # second, compute the shear stress on the fault
    traction, normal_traction, shear_traction = compute_traction(
            stress_tensor, n)
    shear_dir = shear_traction/np.sqrt(np.sum(shear_traction**2))
    # the angle difference is the Arccos(dot product)
    angle = np.arccos(round_cos(np.sum(d.squeeze()*shear_dir.squeeze())))
    # return the result in degrees
    return angle*180./np.pi</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ILSI.utils_stress.R_"><code class="name flex">
<span>def <span class="ident">R_</span></span>(<span>principal_stresses)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the shape ratio R=(sig1-sig2)/(sig1-sig3).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pinricpal_stresses</code></strong> :&ensp;<code>numpy array</code> or <code>list</code></dt>
<dd>Contains the three eigenvalues of the stress tensor
ordered such that: <br>
<code>principal_stresses[0]</code> &lt; <code>principal_stresses[1]</code> &lt; <code>principal_stresses[2]</code>
with <code>principal_stresses[0]</code> being the most compressional stress.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>shape_ratio</code></strong> :&ensp;<code>scalar float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def R_(principal_stresses):
    &#34;&#34;&#34;
    Computes the shape ratio R=(sig1-sig2)/(sig1-sig3).

    Parameters
    -----------
    pinricpal_stresses: numpy array or list
        Contains the three eigenvalues of the stress tensor
        ordered such that:   
        `principal_stresses[0]` &lt; `principal_stresses[1]` &lt; `principal_stresses[2]`
        with `principal_stresses[0]` being the most compressional stress.

    Returns
    ---------
    shape_ratio: scalar float
    &#34;&#34;&#34;
    return (principal_stresses[0]-principal_stresses[1])\
          /(principal_stresses[0]-principal_stresses[2])</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.angular_residual"><code class="name flex">
<span>def <span class="ident">angular_residual</span></span>(<span>stress_tensor, strikes, dips, rakes)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angle between the direction of the resolved shear
stress predicted by the stress tensor and the direction of
slip given by the strike/dip/rake data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stress_tensor</code></strong> :&ensp;<code>(3, 3) array</code></dt>
<dd>The Cauchy stress tensor.</dd>
<dt><strong><code>strikes</code></strong> :&ensp;<code>(n_earthquakes) list</code> or <code>array</code></dt>
<dd>Fault strikes.</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>(n_earthquakes) list</code> or <code>array</code></dt>
<dd>Fault dips.</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>(n_earthquakes) list</code> or <code>array</code></dt>
<dd>Fault rakes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>angles</code></strong> :&ensp;<code>(n_earthquakes) array</code></dt>
<dd>Angles between shear stress and slip.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angular_residual(stress_tensor, strikes, dips, rakes):
    &#34;&#34;&#34;
    Compute the angle between the direction of the resolved shear
    stress predicted by the stress tensor and the direction of
    slip given by the strike/dip/rake data.

    Parameters
    ------------
    stress_tensor: (3, 3) array
        The Cauchy stress tensor.
    strikes: (n_earthquakes) list or array
        Fault strikes.
    dips: (n_earthquakes) list or array
        Fault dips.
    rakes: (n_earthquakes) list or array
        Fault rakes.

    Returns
    ----------
    angles: (n_earthquakes) array
        Angles between shear stress and slip.
    &#34;&#34;&#34;
    angles = np.zeros(len(strikes), dtype=np.float32)
    for i in range(len(strikes)):
        angles[i] = shear_slip_angle_difference(
                stress_tensor, strikes[i], dips[i], rakes[i])
    return angles</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.aux_plane"><code class="name flex">
<span>def <span class="ident">aux_plane</span></span>(<span>s1, d1, r1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get Strike and dip of second plane.</p>
<p>Adapted from MATLAB script
<code>bb.m &lt;http://www.ceri.memphis.edu/people/olboyd/Software/Software.html&gt;</code>_
written by Andy Michael, Chen Ji and Oliver Boyd.</p>
<p>Taken from <a href="https://docs.obspy.org/_modules/obspy/imaging/beachball.html#aux_plane">https://docs.obspy.org/_modules/obspy/imaging/beachball.html#aux_plane</a>.<br>
See Obspy project at <a href="https://github.com/obspy/obspy">https://github.com/obspy/obspy</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aux_plane(s1, d1, r1):
    &#34;&#34;&#34;
    Get Strike and dip of second plane.
    
    Adapted from MATLAB script
    `bb.m &lt;http://www.ceri.memphis.edu/people/olboyd/Software/Software.html&gt;`_
    written by Andy Michael, Chen Ji and Oliver Boyd.

    Taken from &lt;https://docs.obspy.org/_modules/obspy/imaging/beachball.html#aux_plane&gt;.  
    See Obspy project at &lt;https://github.com/obspy/obspy&gt;.
    &#34;&#34;&#34;
    r2d = 180 / np.pi

    def _strike_dip(n, e, u):
        &#34;&#34;&#34;
        Finds strike and dip of plane given normal vector having components n, e,
        and u.
        
        Adapted from MATLAB script
        `bb.m &lt;http://www.ceri.memphis.edu/people/olboyd/Software/Software.html&gt;`_
        written by Andy Michael, Chen Ji and Oliver Boyd.
        &#34;&#34;&#34;
        r2d = 180 / np.pi
        if u &lt; 0:
            n = -n
            e = -e
            u = -u

        strike = np.arctan2(e, n) * r2d
        strike = strike - 90
        while strike &gt;= 360:
            strike = strike - 360
        while strike &lt; 0:
            strike = strike + 360
        x = np.sqrt(np.power(n, 2) + np.power(e, 2))
        dip = np.arctan2(x, u) * r2d
        return (strike, dip)

    # modified by me:
    if r1 &gt; 180.:
        # convert rake between 0 and 360
        # to rake between -180 and +180
        r1 = r1-360.
    
    z = (s1 + 90) / r2d
    z2 = d1 / r2d
    z3 = r1 / r2d
    # slick vector in plane 1
    sl1 = -np.cos(z3) * np.cos(z) - np.sin(z3) * np.sin(z) * np.cos(z2)
    sl2 = np.cos(z3) * np.sin(z) - np.sin(z3) * np.cos(z) * np.cos(z2)
    sl3 = np.sin(z3) * np.sin(z2)
    (strike, dip) = _strike_dip(sl2, sl1, sl3)
    
    n1 = np.sin(z) * np.sin(z2)  # normal vector to plane 1
    n2 = np.cos(z) * np.sin(z2)
    h1 = -sl2  # strike vector of plane 2
    h2 = sl1
    # note h3=0 always so we leave it out
    # n3 = np.cos(z2)
    
    z = h1 * n1 + h2 * n2
    z = z / np.sqrt(h1 * h1 + h2 * h2)
    # we might get above 1.0 only due to floating point
    # precision. Clip for those cases.
    float64epsilon = 2.2204460492503131e-16
    if 1.0 &lt; abs(z) &lt; 1.0 + 100 * float64epsilon:
        z = np.copysign(1.0, z)
    z = np.arccos(round_cos(z))
    rake = 0
    if sl3 &gt; 0:
        rake = z * r2d
    if sl3 &lt;= 0:
        rake = -z * r2d
    return strike%360., dip, rake%360.</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.check_right_handedness"><code class="name flex">
<span>def <span class="ident">check_right_handedness</span></span>(<span>basis)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure the matrix of column vectors forms
a right-handed basis. This is particularly important
when re-ordering the principal stress directions
based on their eigenvalues.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>basis</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>Matrix with column vectors that form the basis of interest.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rh_basis</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>Matrix with column vectors that form the right-handed
version of the input basis. One of the unit vectors
might have been reversed in the process.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_right_handedness(basis):
    &#34;&#34;&#34;
    Make sure the matrix of column vectors forms
    a right-handed basis. This is particularly important
    when re-ordering the principal stress directions
    based on their eigenvalues.

    Parameters
    -----------
    basis: (3, 3) numpy array
        Matrix with column vectors that form the basis of interest.

    Returns
    ----------
    rh_basis: (3, 3) numpy array
        Matrix with column vectors that form the right-handed
        version of the input basis. One of the unit vectors
        might have been reversed in the process.
    &#34;&#34;&#34;
    vector1 = basis[:, 0]
    vector2 = basis[:, 1]
    vector3 = np.cross(vector1, vector2)
    return np.stack([vector1, vector2, vector3], axis=1)</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.compute_traction"><code class="name flex">
<span>def <span class="ident">compute_traction</span></span>(<span>stress_tensor, normal)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stress_tensor</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>Cauchy stress tensor.</dd>
<dt><strong><code>normal</code></strong> :&ensp;<code>(n_earthquakes, 3) numpy array</code></dt>
<dd>Matrix of n_earthquakes row vectors of fault normals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>traction</code></strong> :&ensp;<code>(n_earthquakes, 3) numpy array</code></dt>
<dd>Tractions on the surfaces defined by normal.</dd>
<dt><strong><code>normal_traction</code></strong> :&ensp;<code>(n_earthquakes, 3) numpy array</code></dt>
<dd>Normal component of the tractions.</dd>
<dt><strong><code>shear_traction</code></strong> :&ensp;<code>(n_earthquakes, 3) numpy array</code></dt>
<dd>Tangential component of the tractions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_traction(stress_tensor, normal):
    &#34;&#34;&#34;
    Parameters
    -----------
    stress_tensor: (3, 3) numpy array
        Cauchy stress tensor.
    normal: (n_earthquakes, 3) numpy array
        Matrix of n_earthquakes row vectors of fault normals.

    Returns
    --------
    traction: (n_earthquakes, 3) numpy array
        Tractions on the surfaces defined by normal.
    normal_traction: (n_earthquakes, 3) numpy array
        Normal component of the tractions.
    shear_traction: (n_earthquakes, 3) numpy array
        Tangential component of the tractions.
    &#34;&#34;&#34;
    traction = np.dot(stress_tensor, normal.T).T
    normal_traction = np.sum(traction*normal, axis=-1)[:, np.newaxis]\
                      *normal
    shear_traction = traction - normal_traction
    return traction, normal_traction, shear_traction</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.errors_in_data"><code class="name flex">
<span>def <span class="ident">errors_in_data</span></span>(<span>strike, dip, rake, jack_strikes_1, jack_dips_1, jack_rakes_1, jack_strikes_2, jack_dips_2, jack_rakes_2)</span>
</code></dt>
<dd>
<div class="desc"><p>This routines was tailored for my applications.
Use the multiple solutions obtained during the jackknife resampling
of the focal mechanism inversion to compute the deviation of these
multiple solutions from the best solution. A low deviation means a
good quality focal mechanism. Because there are two possible slip vectors
for each focal mechanism solution, we systematically look among the
jackknife solutions 1 and 2 for the closest slip vector to the target
vector, defined by (strike, dip, rake).
We recommend to run this function for (strike, dip, rake)_1 and
(strike, dip, rake)_2 of the best focal mechanism solution, and
average the outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def errors_in_data(strike, dip, rake,
                   jack_strikes_1, jack_dips_1, jack_rakes_1,
                   jack_strikes_2, jack_dips_2, jack_rakes_2):
    &#34;&#34;&#34;
    This routines was tailored for my applications.
    Use the multiple solutions obtained during the jackknife resampling
    of the focal mechanism inversion to compute the deviation of these
    multiple solutions from the best solution. A low deviation means a
    good quality focal mechanism. Because there are two possible slip vectors
    for each focal mechanism solution, we systematically look among the
    jackknife solutions 1 and 2 for the closest slip vector to the target
    vector, defined by (strike, dip, rake).
    We recommend to run this function for (strike, dip, rake)_1 and
    (strike, dip, rake)_2 of the best focal mechanism solution, and
    average the outputs.
    &#34;&#34;&#34;
    r2d = 180./np.pi
    n_jackknife = len(jack_strikes_1)
    # slip vector from the best nodal plane
    _, slip_vector_best = normal_slip_vectors(strike, dip, rake)
    # slip vectors from the jackknife nodal planes
    slip_vectors = np.zeros((n_jackknife, 2, 3), dtype=np.float32)
    # angles between the jackknife slip vectors and the best slip vector
    # since it is ambiguous which of the planes are the fault planes,
    # we simply systematically compute the angle between both planes
    # and keep the lowest angle.
    slip_angles = np.zeros(n_jackknife, dtype=np.float32)
    for i in range(n_jackknife):
        _, slip_vectors[i, 0, :] = normal_slip_vectors(
                jack_strikes_1[i], jack_dips_1[i], jack_rakes_1[i])
        _, slip_vectors[i, 1, :] = normal_slip_vectors(
                jack_strikes_2[i], jack_dips_2[i], jack_rakes_2[i])
    # a little bit of clipping is necessary in case of numerical errors
    # putting the scalar products sligthly above or below +1/-1.
    scalar_prod1 = np.clip(np.sum(slip_vectors[:, 0, :]*slip_vector_best, axis=-1), -1., +1.)
    scalar_prod2 = np.clip(np.sum(slip_vectors[:, 1, :]*slip_vector_best, axis=-1), -1., +1.)
    angles_1 = np.arccos(scalar_prod1)
    angles_2 = np.arccos(scalar_prod2)
    abs_angles_1 = np.abs(np.arccos(scalar_prod1))
    abs_angles_2 = np.abs(np.arccos(scalar_prod2))
    slip_angles = np.minimum(abs_angles_1, abs_angles_2)*r2d
    mask1 = abs_angles_1 &lt; abs_angles_2
    slip_angles[mask1] *= np.sign(angles_1[mask1])
    mask2 = abs_angles_2 &lt;= abs_angles_1
    slip_angles[mask2] *= np.sign(angles_2[mask2])
    slip_vectors_ = np.zeros((n_jackknife, 3), dtype=np.float32)
    # get the closest slip vectors
    slip_vectors_[mask1, :] = slip_vectors[mask1, 0, :]
    slip_vectors_[mask2, :] = slip_vectors[mask2, 1, :]
    # we can now use the standard deviations on each of the
    # 3 components to estimate errors in the data and use
    # Tarantola and Valette formula
    dev_n = 1.42*np.median(np.abs(slip_vectors_[:, 0] - slip_vector_best[0]))
    dev_w = 1.42*np.median(np.abs(slip_vectors_[:, 1] - slip_vector_best[1]))
    dev_z = 1.42*np.median(np.abs(slip_vectors_[:, 2] - slip_vector_best[2]))
    #for i in range(3):
    #    plt.hist(slip_vectors_[:, i], bins=20)
    #    plt.axvline(slip_vector_best[i], lw=2, color=&#39;C{:d}&#39;.format(i))
    #plt.show()
    return dev_n, dev_w, dev_z</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.get_CI_levels"><code class="name flex">
<span>def <span class="ident">get_CI_levels</span></span>(<span>azimuths, plunges, confidence_intervals=[95.0, 90.0], nbins=200, smoothing_sig=1, return_count=False, plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the 2d histogram in the stereographic space
of a collection lines described by their azimuth and plunge.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>azimuths</code></strong> :&ensp;<code>(n_lines) list</code> or <code>array, float</code></dt>
<dd>Azimuths of the lines.</dd>
<dt><strong><code>plunges</code></strong> :&ensp;<code>(n_lines) list</code> or <code>array, float</code></dt>
<dd>Plunges (angle from horizontal) of the lines.</dd>
<dt><strong><code>nbins</code></strong> :&ensp;<code>integer</code>, default <code>to 200</code></dt>
<dd>Number of bins, in both axes, used to discretized
the 2d space.</dd>
<dt><strong><code>smoothing_sig</code></strong> :&ensp;<code>float</code>, default <code>to 1</code></dt>
<dd>If greater than 0, smooth the 2d distribution
with a gaussian kernel. This is useful to derive
smooth confidence intervals.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, plot the 2d histogram.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>(nbins, nbins) array, integer</code>, optional</dt>
<dd>2D histogram of the lines dsecribed by azimuths and plunges.
Only provided if <code>return_count</code> is True.</dd>
<dt><strong><code>lons_g</code></strong> :&ensp;<code>(nbins, nbins) array, float</code>, optional</dt>
<dd>2D grid of the longitudinal coordinate of each bin.
Only provided if <code>return_count</code> is True.</dd>
<dt><strong><code>lats_g</code></strong> :&ensp;<code>(nbins, nbins) array, float</code>, optional</dt>
<dd>2D grid f the latitudinal coordinate of each bin.
Only provided if <code>return_count</code> is True.</dd>
<dt><strong><code>confidence_intervals</code></strong> :&ensp;<code>(nbins, nbins) array, float</code></dt>
<dd>2D distribution of the mass.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_CI_levels(azimuths, plunges, confidence_intervals=[95., 90.],
                  nbins=200, smoothing_sig=1, return_count=False,
                  plot=False):
    &#34;&#34;&#34;
    Computes the 2d histogram in the stereographic space
    of a collection lines described by their azimuth and plunge.

    Parameters
    -----------
    azimuths: (n_lines) list or array, float
        Azimuths of the lines.
    plunges: (n_lines) list or array, float
        Plunges (angle from horizontal) of the lines.
    nbins: integer, default to 200
        Number of bins, in both axes, used to discretized
        the 2d space.
    smoothing_sig: float, default to 1
        If greater than 0, smooth the 2d distribution
        with a gaussian kernel. This is useful to derive
        smooth confidence intervals.
    plot: boolean, default to False
        If True, plot the 2d histogram.

    Returns
    ---------
    count: (nbins, nbins) array, integer, optional
        2D histogram of the lines dsecribed by azimuths and plunges.
        Only provided if `return_count` is True.
    lons_g: (nbins, nbins) array, float, optional
        2D grid of the longitudinal coordinate of each bin.
        Only provided if `return_count` is True.
    lats_g: (nbins, nbins) array, float, optional
        2D grid f the latitudinal coordinate of each bin.
        Only provided if `return_count` is True.
    confidence_intervals: (nbins, nbins) array, float
        2D distribution of the mass.
    &#34;&#34;&#34;
    from scipy.interpolate import interp1d
    # get histogram on a 2d grid
    count, lons_g, lats_g = hist2d(
            azimuths, plunges, nbins=nbins, smoothing_sig=smoothing_sig)
    # flatten the count array and sort it from largest to smallest
    count_vector = np.sort(count.copy().flatten())[::-1]
    # compute the &#34;CDF&#34; of the counts
    count_CDF = np.hstack(
            ([0.], np.cumsum(count_vector)/count_vector.sum(), [1.]))
    count_vector = np.hstack(([count_vector.max()+1.], count_vector, [0.]))
    # build an interpolator that gives the count number 
    # for a given % of the total mass
    mass_dist = interp1d(100.*count_CDF, count_vector)
    mass_dist_ = lambda x: mass_dist(x).item()
    confidence_intervals = list(
            map(mass_dist_, [k for k in confidence_intervals]))
    if plot:
        import matplotlib.pyplot as plt
        fig = plt.figure(&#39;2d_histogram_stereo&#39;, figsize=(18, 9))
        ax = fig.add_subplot(111, projection=&#39;stereonet&#39;)
        pcl = ax.pcolormesh(lons_g, lats_g, count)
        ax.contour(
                lons_g, lats_g, count,
                levels=confidence_intervals, zorder=2, cmap=&#39;jet&#39;)
        plt.colorbar(mappable=pcl)
    if return_count:
        return count, lons_g, lats_g, confidence_intervals
    else:
        return confidence_intervals</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.get_CI_levels_joint"><code class="name flex">
<span>def <span class="ident">get_CI_levels_joint</span></span>(<span>azimuths, plunges, confidence_intervals=[90.0, 95.0], nbins=200, smoothing_sig=1, return_count=False, plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the 2d histogram in the stereographic space
of a collection lines described by their azimuth and plunge.
This is an EXPERIMENTAL function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>azimuths</code></strong> :&ensp;<code>(n_lines) list</code> or <code>array, float</code></dt>
<dd>Azimuths of the lines.</dd>
<dt><strong><code>plunges</code></strong> :&ensp;<code>(n_lines) list</code> or <code>array, float</code></dt>
<dd>Plunges (angle from horizontal) of the lines.</dd>
<dt><strong><code>nbins</code></strong> :&ensp;<code>integer</code>, default <code>to 200</code></dt>
<dd>Number of bins, in both axes, used to discretized
the 2d space.</dd>
<dt><strong><code>smoothing_sig</code></strong> :&ensp;<code>float</code>, default <code>to 1</code></dt>
<dd>If greater than 0, smooth the 2d distribution
with a gaussian kernel. This is useful to derive
smooth confidence intervals.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, plot the 2d histogram.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>(nbins, nbins) array, integer</code>, optional</dt>
<dd>2D histogram of the lines dsecribed by azimuths and plunges.
Only provided if <code>return_count</code> is True.</dd>
<dt><strong><code>lons_g</code></strong> :&ensp;<code>(nbins, nbins) array, float</code>, optional</dt>
<dd>2D grid of the longitudinal coordinate of each bin.
Only provided if <code>return_count</code> is True.</dd>
<dt><strong><code>lats_g</code></strong> :&ensp;<code>(nbins, nbins) array, float</code>, optional</dt>
<dd>2D grid f the latitudinal coordinate of each bin.
Only provided if <code>return_count</code> is True.</dd>
<dt><strong><code>confidence_intervals</code></strong> :&ensp;<code>(nbins, nbins) array, float</code></dt>
<dd>2D distribution of the mass.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_CI_levels_joint(azimuths, plunges, confidence_intervals=[90., 95.],
                        nbins=200, smoothing_sig=1, return_count=False,
                        plot=False):
    &#34;&#34;&#34;
    Computes the 2d histogram in the stereographic space
    of a collection lines described by their azimuth and plunge.
    This is an EXPERIMENTAL function.

    Parameters
    -----------
    azimuths: (n_lines) list or array, float
        Azimuths of the lines.
    plunges: (n_lines) list or array, float
        Plunges (angle from horizontal) of the lines.
    nbins: integer, default to 200
        Number of bins, in both axes, used to discretized
        the 2d space.
    smoothing_sig: float, default to 1
        If greater than 0, smooth the 2d distribution
        with a gaussian kernel. This is useful to derive
        smooth confidence intervals.
    plot: boolean, default to False
        If True, plot the 2d histogram.

    Returns
    ---------
    count: (nbins, nbins) array, integer, optional
        2D histogram of the lines dsecribed by azimuths and plunges.
        Only provided if `return_count` is True.
    lons_g: (nbins, nbins) array, float, optional
        2D grid of the longitudinal coordinate of each bin.
        Only provided if `return_count` is True.
    lats_g: (nbins, nbins) array, float, optional
        2D grid f the latitudinal coordinate of each bin.
        Only provided if `return_count` is True.
    confidence_intervals: (nbins, nbins) array, float
        2D distribution of the mass.
    &#34;&#34;&#34;
    from scipy.interpolate import interp1d
    # get histogram on a 2d grid
    count, lons_g, lats_g = hist2d(
            azimuths, plunges, nbins=nbins, smoothing_sig=smoothing_sig)
    # compute the joint cumulative distribution function (CDF)
    joint = joint_CDF(count)
    # because we define the (1-2a) confidence interval from the
    # a-th and the (1-a)-th percentiles, we conveniently define the
    # following function:
    g = 2.*np.abs(joint - 0.5)*100.
    # all points for which g &lt; 1-2a are within the 1-2a confidence interval
    if plot:
        import matplotlib.pyplot as plt
        confidence_intervals.sort()
        fig = plt.figure(&#39;2d_histogram_stereo&#39;, figsize=(18, 9))
        ax1 = fig.add_subplot(221, projection=&#39;stereonet&#39;)
        pcl1 = ax1.pcolormesh(lons_g, lats_g, count)
        ax1.contour(lons_g, lats_g, g,
                    levels=confidence_intervals, zorder=2, cmap=&#39;jet&#39;)
        plt.colorbar(mappable=pcl1)
        ax2 = fig.add_subplot(222, projection=&#39;stereonet&#39;)
        pcl2 = ax2.pcolormesh(lons_g, lats_g, joint)
        ax2.contour(lons_g, lats_g, g,
                    levels=confidence_intervals, zorder=2, cmap=&#39;jet&#39;)
        plt.colorbar(mappable=pcl2)
        ax3 = fig.add_subplot(223, projection=&#39;stereonet&#39;)
        pcl3 = ax3.pcolormesh(lons_g, lats_g, g)
        ax3.contour(lons_g, lats_g, g,
                    levels=confidence_intervals, zorder=2, cmap=&#39;jet&#39;)
        plt.colorbar(mappable=pcl3)
    if return_count:
        return count, lons_g, lats_g, confidence_intervals
    else:
        return confidence_intervals</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.get_bearing_plunge"><code class="name flex">
<span>def <span class="ident">get_bearing_plunge</span></span>(<span>u, degrees=True, hemisphere='lower')</span>
</code></dt>
<dd>
<div class="desc"><p>The vectors are in the coordinate system (x1, x2, x3):<br>
x1: north<br>
x2: west<br>
x3: upward
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>(3) array</code> or <code>list</code></dt>
<dd>Vector for which we want the bearing (azimuth) and plunge.</dd>
<dt><strong><code>degrees</code></strong> :&ensp;<code>boolean</code>, default <code>to True</code></dt>
<dd>If True, returns bearing and plunge in degrees.
In radians otherwise.</dd>
<dt><strong><code>hemisphere</code></strong> :&ensp;<code>string</code>, default <code>to 'lower'</code></dt>
<dd>Consider the intersection of the line defined by u
with the lower hemisphere if <code>hemisphere</code> is 'lower', or
with the upper hemisphere if <code>hemisphere</code> is 'upper'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bearing</code></strong> :&ensp;<code>float</code></dt>
<dd>Angle between the north and the line.</dd>
<dt><strong><code>plunge</code></strong> :&ensp;<code>float</code></dt>
<dd>Angle between the horizontal plane and the line.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bearing_plunge(u, degrees=True, hemisphere=&#39;lower&#39;):
    &#34;&#34;&#34;
    The vectors are in the coordinate system (x1, x2, x3):  
    x1: north  
    x2: west  
    x3: upward  

    Parameters
    -----------
    u: (3) array or list
        Vector for which we want the bearing (azimuth) and plunge.
    degrees: boolean, default to True
        If True, returns bearing and plunge in degrees.
        In radians otherwise.
    hemisphere: string, default to &#39;lower&#39;
        Consider the intersection of the line defined by u
        with the lower hemisphere if `hemisphere` is &#39;lower&#39;, or
        with the upper hemisphere if `hemisphere` is &#39;upper&#39;.

    Returns
    ---------
    bearing: float
        Angle between the north and the line.
    plunge: float
        Angle between the horizontal plane and the line.
    &#34;&#34;&#34;
    r2d = 180./np.pi
    if hemisphere == &#39;lower&#39; and u[2] &gt; 0.:
        # we need to consider the end of the line
        # that plunges downward and crosses the
        # lower hemisphere
        u = -1.*u
    elif hemisphere == &#39;upper&#39; and u[2] &lt; 0.:
        u = -1.*u
    # the trigonometric sense is the opposite of the azimuthal sense,
    # therefore we need a -1 multiplicative factor
    bearing = -1.*np.arctan2(u[1], u[0])
    # the plunge is measured downward from the end of the
    # line specified by the bearing
    # this formula is valid for p_axis[2] &lt; 0
    plunge = (np.arccos(round_cos(u[2])) - np.pi/2.)
    if hemisphere == &#39;upper&#39;:
        plunge *= -1.
    if degrees:
        return (bearing*r2d)%360., plunge*r2d
    else:
        return bearing, plunge</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.hist2d"><code class="name flex">
<span>def <span class="ident">hist2d</span></span>(<span>azimuths, plunges, nbins=200, smoothing_sig=0, plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the 2d histogram in the stereographic space
of a collection lines described by their azimuth and plunge.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>azimuths</code></strong> :&ensp;<code>(n_lines) list</code> or <code>array, float</code></dt>
<dd>Azimuths of the lines.</dd>
<dt><strong><code>plunges</code></strong> :&ensp;<code>(n_lines) list</code> or <code>array, float</code></dt>
<dd>Plunges (angle from horizontal) of the lines.</dd>
<dt><strong><code>nbins</code></strong> :&ensp;<code>integer</code>, default <code>to 200</code></dt>
<dd>Number of bins, in both axes, used to discretized
the 2d space.</dd>
<dt><strong><code>smoothing_sih</code></strong> :&ensp;<code>float</code>, default <code>to 0</code></dt>
<dd>If greater than 0, smooth the 2d distribution
with a gaussian kernel. This is useful to derive
smooth confidence intervals.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>boolean</code>, default <code>to False</code></dt>
<dd>If True, plot the 2d histogram.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hist2d(azimuths, plunges,
           nbins=200, smoothing_sig=0,
           plot=False):
    &#34;&#34;&#34;
    Computes the 2d histogram in the stereographic space
    of a collection lines described by their azimuth and plunge.

    Parameters
    -----------
    azimuths: (n_lines) list or array, float
        Azimuths of the lines.
    plunges: (n_lines) list or array, float
        Plunges (angle from horizontal) of the lines.
    nbins: integer, default to 200
        Number of bins, in both axes, used to discretized
        the 2d space.
    smoothing_sih: float, default to 0
        If greater than 0, smooth the 2d distribution
        with a gaussian kernel. This is useful to derive
        smooth confidence intervals.
    plot: boolean, default to False
        If True, plot the 2d histogram.
    &#34;&#34;&#34;
    import mplstereonet
    from scipy.ndimage.filters import gaussian_filter
    # convert azimuths and plunges to longitudes and latitudes
    # on a stereographic plot
    lons, lats = mplstereonet.stereonet_math.line(plunges, azimuths)
    count, lon_bins, lat_bins = np.histogram2d(
            lons, lats, range=([-np.pi/2., np.pi/2.], [-np.pi/2., np.pi/2.]), bins=nbins)
    lons_g, lats_g = np.meshgrid((lon_bins[1:] + lon_bins[:-1])/2.,
                                 (lat_bins[1:] + lat_bins[:-1])/2.,
                                 indexing=&#39;ij&#39;)
    if smoothing_sig &gt; 0:
        count = gaussian_filter(count, smoothing_sig)
    if plot:
        fig = plt.figure(&#39;2d_histogram_stereo&#39;, figsize=(18, 9))
        ax = fig.add_subplot(111, projection=&#39;stereonet&#39;)
        pcl = ax.pcolormesh(lons_g, lats_g, count)
        plt.colorbar(mappable=pcl)
    return count, lons_g, lats_g</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.joint_CDF"><code class="name flex">
<span>def <span class="ident">joint_CDF</span></span>(<span>count)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joint_CDF(count):
    # normalize the histogram
    density = count / np.sum(count)
    # integrate along first axis, and then along second axis
    # while keeping the original shape
    joint = np.cumsum(np.cumsum(density, axis=0), axis=1)
    return joint</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.kagan_angle"><code class="name flex">
<span>def <span class="ident">kagan_angle</span></span>(<span>tensor1, tensor2)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the minimum rotation about <em>some</em> axis required
to match the two tensors. This angle is a measure of their
difference.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tensor1</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>First tensor, e.g. moment or stress tensor.</dd>
<dt><strong><code>tensor2</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>Second tensor, e.g. moment of stress tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rotation_angle</code></strong> :&ensp;<code>scalar float</code></dt>
<dd>Smallest angle, in degrees, required to superimpose
the two tensors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kagan_angle(tensor1, tensor2):
    &#34;&#34;&#34;
    Compute the minimum rotation about *some* axis required
    to match the two tensors. This angle is a measure of their
    difference.

    Parameters
    -----------
    tensor1: (3, 3) numpy array
        First tensor, e.g. moment or stress tensor.
    tensor2: (3, 3) numpy array
        Second tensor, e.g. moment of stress tensor.

    Returns
    --------
    rotation_angle: scalar float
        Smallest angle, in degrees, required to superimpose
        the two tensors.
    &#34;&#34;&#34;
    theta = np.pi
    Rx = np.array([[1., 0., 0.],
                   [0., np.cos(theta), -np.sin(theta)],
                   [0., np.sin(theta), np.cos(theta)]])
    # first, compute the eigendecomposition of each tensor using
    # the stress tensor eigendecomposition routine, i.e. that returns
    # the eigen values and vectors ordered from the most to least
    # compressive axes
    # make sure to do the change of basis from
    # (north, west, up) to (north, east, down)
    #eigval1, eigvec1 = stress_tensor_eigendecomposition(Rx.dot(tensor1.dot(Rx.T)))
    #eigval2, eigvec2 = stress_tensor_eigendecomposition(Rx.dot(tensor2.dot(Rx.T)))
    eigval1, eigvec1 = stress_tensor_eigendecomposition(tensor1)
    eigval2, eigvec2 = stress_tensor_eigendecomposition(tensor2)
    eigvec1 = check_right_handedness(np.stack([eigvec1[:, 2], eigvec1[:, 0], eigvec1[:, 1]], axis=1))
    eigvec2 = check_right_handedness(np.stack([eigvec2[:, 2], eigvec2[:, 0], eigvec2[:, 1]], axis=1))
    # second, compute the rotation matrix that takes one basis to the other
    R12 = np.dot(eigvec1.T, eigvec2)
    # compute the quaternion associated with this rotation matrix
    q = quaternion(R12[:, 0], R12[:, 1], R12[:, 2])
    # the minimum angle about some axis to superimpose the two
    # input tensors is:
    min_angle = np.arccos(round_cos(np.max(np.abs(q))))
    return 2.*np.rad2deg(min_angle)</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.mean_angular_residual"><code class="name flex">
<span>def <span class="ident">mean_angular_residual</span></span>(<span>stress_tensor, strikes, dips, rakes)</span>
</code></dt>
<dd>
<div class="desc"><p>Mean of the absolute value of the angles returned by
angular_residual. See angular_residual for more info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_angular_residual(stress_tensor, strikes, dips, rakes):
    &#34;&#34;&#34;
    Mean of the absolute value of the angles returned by
    angular_residual. See angular_residual for more info.
    &#34;&#34;&#34;
    return np.mean(np.abs(angular_residual(stress_tensor, strikes, dips, rakes)))</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.mean_kagan_angle"><code class="name flex">
<span>def <span class="ident">mean_kagan_angle</span></span>(<span>strikes, dips, rakes, strike0=None, dip0=None, rake0=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the mean kagan angle as a measure of dispersion.
</p>
<p>The mean kagan angle within a population of focal mechanisms
described by strikes/dips/rakes. If strike0, dip0, and rake0
are specified, then the mean kagan angle is computed not from
all pairs of focal mechanisms, but only between all focal mechanisms
and the reference focal mechanism described by strike0/dip0/rake0.
The mean kagan angle can be interpreted as a measure of dispersion
within the population.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strikes</code></strong> :&ensp;<code>numpy array</code> or <code>list, float</code></dt>
<dd>Strikes of the moment tensors.</dd>
<dt><strong><code>dips</code></strong> :&ensp;<code>numpy array</code> or <code>list, float</code></dt>
<dd>Dips of the moment tensors.</dd>
<dt><strong><code>rakes</code></strong> :&ensp;<code>numpy array</code> or <code>list, float</code></dt>
<dd>Rakes of the moment tensors.</dd>
<dt><strong><code>strike0</code></strong> :&ensp;<code>scalar, float</code>, default <code>to None</code></dt>
<dd>Strike of the reference moment tensor.</dd>
<dt><strong><code>dip0</code></strong> :&ensp;<code>scalar, float</code>, default <code>to None</code></dt>
<dd>Dip of the reference moment tensor.</dd>
<dt><strong><code>rake0</code></strong> :&ensp;<code>scalar, float</code>, default <code>to None</code></dt>
<dd>Rake of the reference moment tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean_angle</code></strong> :&ensp;<code>scalar, float</code></dt>
<dd>Mean kagan angle between the moment tensors given as input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_kagan_angle(strikes, dips, rakes,
                     strike0=None, dip0=None, rake0=None):
    &#34;&#34;&#34;Computes the mean kagan angle as a measure of dispersion.  

    The mean kagan angle within a population of focal mechanisms
    described by strikes/dips/rakes. If strike0, dip0, and rake0
    are specified, then the mean kagan angle is computed not from
    all pairs of focal mechanisms, but only between all focal mechanisms
    and the reference focal mechanism described by strike0/dip0/rake0.
    The mean kagan angle can be interpreted as a measure of dispersion
    within the population.

    Parameters
    -----------
    strikes: numpy array or list, float
        Strikes of the moment tensors.
    dips: numpy array or list, float
        Dips of the moment tensors.
    rakes: numpy array or list, float
        Rakes of the moment tensors.
    strike0: scalar, float, default to None
        Strike of the reference moment tensor.
    dip0: scalar, float, default to None
        Dip of the reference moment tensor.
    rake0: scalar, float, default to None
        Rake of the reference moment tensor.

    Returns
    --------
    mean_angle: scalar, float
        Mean kagan angle between the moment tensors given as input.
    &#34;&#34;&#34;
    from functools import partial
    mts = np.zeros((len(strikes), 3, 3), dtype=np.float32)
    for i in range(len(strikes)):
        mts[i, ...] = strike_dip_rake_to_mt(strikes[i], dips[i], rakes[i])
    if strike0 is not None:
        mt0 = strike_dip_rake_to_mt(strike0, dip0, rake0)
        angles = list(map(partial(kagan_angle, mt0), mts))
    else:
        angles = sum([list(map(
            partial(kagan_angle, mts[i, ...]), mts))
            for i in range(mts.shape[0])], [])
    return np.mean(np.asarray(angles))</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.normal_slip_vectors"><code class="name flex">
<span>def <span class="ident">normal_slip_vectors</span></span>(<span>strike, dip, rake, direction='inward')</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the normal and the slip vectors of the
focal mechanism defined by (strike, dip, rake).
From Stein and Wysession 2002.
</p>
<p>N.B.: This is the normal of the FOOT WALL and the slip
of the HANGING WALL w.r.t the foot wall. It means that the
normal is an inward-pointing normal for the hanging wall,
and an outward pointing-normal for the foot wall.</p>
<p>The vectors are in the coordinate system (x1, x2, x3):<br>
x1: north<br>
x2: west<br>
x3: upward
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strike</code></strong> :&ensp;<code>float</code></dt>
<dd>Strike of the fault.</dd>
<dt><strong><code>dip</code></strong> :&ensp;<code>float</code></dt>
<dd>Dip of the fault.</dd>
<dt><strong><code>rake</code></strong> :&ensp;<code>float</code></dt>
<dd>Rake of the fault.</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>string</code>, default <code>to 'inward'</code></dt>
<dd>If 'inward', returns the inward normal of the HANGING wall,
which is the formula given in Stein and Wysession. Equivalently,
this is the outward normal of the foot wall.
If 'outward', returns the outward normal of the HANGING wall,
or, equivalently, the inward normal of the hanging wall.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>(3) array</code></dt>
<dd>The fault normal.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>(3) array</code></dt>
<dd>The slip vector given as the direction of motion
of the hanging wall w.r.t. the foot wall.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_slip_vectors(strike, dip, rake, direction=&#39;inward&#39;):
    &#34;&#34;&#34;
    Determine the normal and the slip vectors of the
    focal mechanism defined by (strike, dip, rake).
    From Stein and Wysession 2002.  

    N.B.: This is the normal of the FOOT WALL and the slip
    of the HANGING WALL w.r.t the foot wall. It means that the
    normal is an inward-pointing normal for the hanging wall,
    and an outward pointing-normal for the foot wall.

    The vectors are in the coordinate system (x1, x2, x3):  
    x1: north  
    x2: west  
    x3: upward  

    Parameters
    ------------
    strike: float
        Strike of the fault.
    dip: float
        Dip of the fault.
    rake: float
        Rake of the fault.
    direction: string, default to &#39;inward&#39;
        If &#39;inward&#39;, returns the inward normal of the HANGING wall,
        which is the formula given in Stein and Wysession. Equivalently,
        this is the outward normal of the foot wall.
        If &#39;outward&#39;, returns the outward normal of the HANGING wall,
        or, equivalently, the inward normal of the hanging wall.

    Returns
    -----------
    n: (3) array
        The fault normal.
    d: (3) array
        The slip vector given as the direction of motion
        of the hanging wall w.r.t. the foot wall.
    &#34;&#34;&#34;
    d2r = np.pi/180.
    strike = strike*d2r
    dip = dip*d2r
    rake = rake*d2r
    n = np.array([-np.sin(dip)*np.sin(strike),
                  -np.sin(dip)*np.cos(strike),
                  np.cos(dip)])
    if direction == &#39;inward&#39;:
        # this formula already gives the inward-pointing
        # normal of the hanging wall
        pass
    elif direction == &#39;outward&#39;:
        n *= -1.
    else:
        print(&#39;direction should be either &#34;inward&#34; or &#34;outward&#34;&#39;)
        return
    # slip on the hanging wall
    d = np.array([np.cos(rake)*np.cos(strike) + np.sin(rake)*np.cos(dip)*np.sin(strike),
                  -np.cos(rake)*np.sin(strike) + np.sin(rake)*np.cos(dip)*np.cos(strike),
                  np.sin(rake)*np.sin(dip)])
    return n, d</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.p_t_b_axes"><code class="name flex">
<span>def <span class="ident">p_t_b_axes</span></span>(<span>normal, slip)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the P (most compressive), T (least compressive)
and B (intermediate, or neutral axis) axes
from the normal and the slip vectors, following
Stein and Wysession 2002, Section 4.5.2.
(P, T, B) forms an orthogonal basis.</p>
<p>The vectors are in the coordinate system (x1, x2, x3):
x1: north
x2: west
x3: upward</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def p_t_b_axes(normal, slip):
    &#34;&#34;&#34;
    Determine the P (most compressive), T (least compressive)
    and B (intermediate, or neutral axis) axes 
    from the normal and the slip vectors, following
    Stein and Wysession 2002, Section 4.5.2.
    (P, T, B) forms an orthogonal basis.

    The vectors are in the coordinate system (x1, x2, x3):
    x1: north
    x2: west
    x3: upward
    &#34;&#34;&#34;
    p = normal - slip
    p /= np.sqrt(np.sum(p**2))
    t = normal + slip
    t /= np.sqrt(np.sum(t**2))
    b = np.cross(normal, slip)
    b /= np.sqrt(np.sum(b**2))
    return p, t, b</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.principal_faults"><code class="name flex">
<span>def <span class="ident">principal_faults</span></span>(<span>stress_tensor, friction_coefficient)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the orientation of the most unstable fault planes given
a stress tensor and a coefficient of friction. These faults are
called the principal faults.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stress_tensor</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>Cauchy stress tensor.</dd>
<dt><strong><code>friction_coefficient</code></strong> :&ensp;<code>scalar float</code></dt>
<dd>Coefficient of friction used for the Mohr-Coulomb
failure criterion.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>n1</code></strong> :&ensp;<code>(3, 1) numpy array</code></dt>
<dd>Normal of the first principal faults.</dd>
<dt><strong><code>n2</code></strong> :&ensp;<code>(3, 1) numpy array</code></dt>
<dd>Normal of the second principal faults. The two
faults form a pair of conjugate faults.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def principal_faults(stress_tensor, friction_coefficient):
    &#34;&#34;&#34;
    Compute the orientation of the most unstable fault planes given
    a stress tensor and a coefficient of friction. These faults are
    called the principal faults.

    Parameters
    -----------
    stress_tensor: (3, 3) numpy array
        Cauchy stress tensor.
    friction_coefficient: scalar float
        Coefficient of friction used for the Mohr-Coulomb
        failure criterion.

    Returns
    ---------
    n1: (3, 1) numpy array
        Normal of the first principal faults.
    n2: (3, 1) numpy array
        Normal of the second principal faults. The two
        faults form a pair of conjugate faults.
    &#34;&#34;&#34;
    # first, compute the angle between sigma 1 and the normal
    # of the most unstable plane
    lbd = np.pi/4. + 1./2.*np.arctan(friction_coefficient)
    # the coordinates of the fault normal in the eigenbasis is:
    n1 = np.array([np.cos(lbd), 0., np.sin(lbd)])
    n2 = np.array([np.cos(lbd), 0., np.sin(-1.*lbd)])
    # compute the eigenbasis
    principal_sig, principal_dir = stress_tensor_eigendecomposition(
            stress_tensor)
    n1 = np.dot(principal_dir, n1[:, np.newaxis])
    n2 = np.dot(principal_dir, n2[:, np.newaxis])
    return n1, n2</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.quaternion"><code class="name flex">
<span>def <span class="ident">quaternion</span></span>(<span>t, p, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Formula of quaternion of rotation matrix with <code>t</code> (least compressive),
<code>p</code> (most compressive), <code>b</code> (neutral) components expressed in the
(north, east, down) frame of reference.
<code>t</code>, <code>p</code>, <code>b</code> can equivalently be the sigma_3, sigma_1, sigma_2 components.
Make sure (<code>t</code>, <code>p</code>, <code>b</code>) form a right-handed basis.
This routine was copied from the _tpb2q routine of the Pyrocko Python
project (see at <a href="https://pyrocko.org/docs/current/_modules/pyrocko/moment_tensor.html#kagan_angle">https://pyrocko.org/docs/current/_modules/pyrocko/moment_tensor.html#kagan_angle</a>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>(3,) numpy array</code> or <code>list</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>(3,) numpy array</code> or <code>list</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>(3,) numpy array</code> or <code>list</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>quaternion</code></strong> :&ensp;<code>(4,) numpy array</code></dt>
<dd>The quaternion that represents the rotation represented by
the matrix (t, p, b), where t, p, b are column vectors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quaternion(t, p, b):
    &#34;&#34;&#34;
    Formula of quaternion of rotation matrix with `t` (least compressive),
    `p` (most compressive), `b` (neutral) components expressed in the
    (north, east, down) frame of reference.
    `t`, `p`, `b` can equivalently be the sigma_3, sigma_1, sigma_2 components.
    Make sure (`t`, `p`, `b`) form a right-handed basis.
    This routine was copied from the _tpb2q routine of the Pyrocko Python
    project (see at https://pyrocko.org/docs/current/_modules/pyrocko/moment_tensor.html#kagan_angle).

    Parameters
    -----------
    t: (3,) numpy array or list
    p: (3,) numpy array or list
    b: (3,) numpy array or list

    Returns
    --------
    quaternion: (4,) numpy array
        The quaternion that represents the rotation represented by
        the matrix (t, p, b), where t, p, b are column vectors.
    &#34;&#34;&#34;
    eps = 0.0001
    x1, x2, x3 = np.float64(t), np.float64(p), np.float64(b) 
    q0 = 1. + x1[0] + x2[1] + x3[2]
    q1 = 1. + x1[0] - x2[1] - x3[2]
    q2 = 1. - x1[0] + x2[1] - x3[2]
    q3 = 1. - x1[0] - x2[1] + x3[2]

    q = np.zeros(4, dtype=np.float64)
    if q0 &gt; eps:
        q[0] = 0.5 * np.sqrt(q0)
        q[1] = x2[2] - x3[1]
        q[2] = x3[0] - x1[2]
        q[3] = x1[1] - x2[0]
    elif q1 &gt; eps:
        q[0] = 0.5 * np.sqrt(q1)
        q[1] = x2[2] - x3[1]
        q[2] = x2[0] + x1[1]
        q[3] = x3[0] + x1[2]
    elif q2 &gt; eps:
        q[0] = 0.5 * np.sqrt(q2)
        q[1] = x3[0] - x1[2]
        q[2] = x2[0] + x1[1]
        q[3] = x3[1] + x2[2]
    elif q3 &gt; eps:
        q[0] = 0.5 * np.sqrt(q3)
        q[1] = x1[1] - x2[0]
        q[2] = x3[0] + x1[2]
        q[3] = x3[1] + x2[2]
    else:
        print(&#39;Could not find the lowest component!&#39;)
        sys.exit(0)

    # normalize the components of the quaternion
    q[1:] /= 4.0*q[0]
    q /= np.sqrt(np.sum(q**2))

    return q</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.random_rotation"><code class="name flex">
<span>def <span class="ident">random_rotation</span></span>(<span>max_angle=360.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a random rotation matrix.
</p>
<p>Generate a random rotation matrix by:<br>
1) Generate a random unit vector in 3D.<br>
2) Generate a random rotation angle between 0 and max_angle (degrees)
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max_angle</code></strong> :&ensp;<code>scalar float</code>, default <code>to 360</code></dt>
<dd>Upper bound of the uniform distribution from which the rotation
angle is randomly drawn.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>(3, 3) numpy array</code></dt>
<dd>Rotation matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_rotation(max_angle=360.):
    &#34;&#34;&#34;Generate a random rotation matrix.  

    Generate a random rotation matrix by:  
      1) Generate a random unit vector in 3D.  
      2) Generate a random rotation angle between 0 and max_angle (degrees)  

    Parameters
    ------------
    max_angle: scalar float, default to 360
        Upper bound of the uniform distribution from which the rotation
        angle is randomly drawn.

    Returns
    --------
    R: (3, 3) numpy array
        Rotation matrix.
    &#34;&#34;&#34;
    x1, x2, x3 = np.random.uniform(low=-1., high=1., size=3)
    dir_ = np.array([x1, x2, x3])
    # normalize
    dir_ /= np.linalg.norm(dir_, 2)
    # draw the angle
    a = max_angle*np.random.random()
    R = rotation(dir_, a)
    return R</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.reduced_stress_tensor"><code class="name flex">
<span>def <span class="ident">reduced_stress_tensor</span></span>(<span>principal_directions, R)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a normalized stress tensor where the most
and least compressive principal stresses are set to
-1 and +1, respectively, and the intermediate stress
is determined by the shape ratio.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>principal_directions: (3, 3) numpy array.</dt>
<dt>The three eigenvectors of the stress tensor, stored in</dt>
<dt>a matrix as column vectors and ordered from</dt>
<dt>most compressive (sigma1) to least compressive (sigma3).</dt>
<dt>The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.</dt>
<dt><strong><code>R</code></strong> :&ensp;<code>float</code></dt>
<dd>The shape ratio (sig1 - sig2)/(sig1 - sig3).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>stress_tensor</code></strong> :&ensp;<code>(3, 3) array</code></dt>
<dd>The stress tensor built from the principal directions
and the shape ratio.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduced_stress_tensor(principal_directions, R):
    &#34;&#34;&#34;
    Computes a normalized stress tensor where the most
    and least compressive principal stresses are set to
    -1 and +1, respectively, and the intermediate stress
    is determined by the shape ratio.

    Parameters
    -----------
    principal_directions: (3, 3) numpy array.
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`. 
    R: float
        The shape ratio (sig1 - sig2)/(sig1 - sig3).
       
    Returns
    ----------
    stress_tensor: (3, 3) array
        The stress tensor built from the principal directions
        and the shape ratio.
    &#34;&#34;&#34;
    sig1 = -1.
    sig2 = 2.*R-1.
    sig3 = +1
    Sigma = np.diag(np.array([sig1, sig2, sig3]))
    Sigma /= np.sqrt(np.sum(Sigma**2))
    # make sure the principal directions form a right-handed basis
    principal_directions = check_right_handedness(principal_directions)
    stress_tensor = np.dot(principal_directions,
                           np.dot(Sigma, principal_directions.T))
    return stress_tensor</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.rotation"><code class="name flex">
<span>def <span class="ident">rotation</span></span>(<span>axis, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the rotation matrix about axis with angle <code>angle</code>.
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>(3) numpy array, float</code></dt>
<dd>Axis about which the rotation is computed.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>scalar, float</code></dt>
<dd>Angle, in degrees, of the rotation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>(3, 3) numpy array, float</code></dt>
<dd>Rotation matrix of angle <code>angle</code> degrees about <code>axis</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation(axis, angle):
    &#34;&#34;&#34;Compute the rotation matrix about axis with angle `angle`.  

    Parameters
    ------------
    axis: (3) numpy array, float
        Axis about which the rotation is computed.
    angle: scalar, float
        Angle, in degrees, of the rotation.

    Returns
    --------
    R: (3, 3) numpy array, float
        Rotation matrix of angle `angle` degrees about `axis`.
    &#34;&#34;&#34;
    x1, x2, x3 = axis
    a = angle*np.pi/180.
    # build the rotation matrix
    ca, sa = np.cos(a), np.sin(a)
    R = np.array([[ca + x1**2*(1.-ca), x1*x2*(1.-ca) - x3*sa, x1*x3*(1.-ca) + x2*sa],
                  [x1*x2*(1.-ca) + x3*sa, ca + x2**2*(1.-ca), x2*x3*(1.-ca) - x1*sa],
                  [x1*x3*(1.-ca) - x2*sa, x2*x3*(1.-ca) + x1*sa, ca + x3**2*(1.-ca)]])
    return R</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.round_cos"><code class="name flex">
<span>def <span class="ident">round_cos</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Clip x so that it fits with the [-1,1] interval.
</p>
<p>If x is slightly outside the [-1,1] because of numerical
imprecision, x is rounded, and can then be safely passed
to arccos or arcsin. If x is truly outside of [-1,1], x
is returned unchanged.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>scalar, float</code></dt>
<dd>Float variable that represents a cos or sin that
is supposed to be within the [-1,1] interval.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x_r</code></strong> :&ensp;<code>scalar, float</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>A rounded version of x, if necessary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_cos(x):
    &#34;&#34;&#34;Clip x so that it fits with the [-1,1] interval.  

    If x is slightly outside the [-1,1] because of numerical
    imprecision, x is rounded, and can then be safely passed
    to arccos or arcsin. If x is truly outside of [-1,1], x
    is returned unchanged.

    Parameters
    -----------
    x: scalar, float
        Float variable that represents a cos or sin that
        is supposed to be within the [-1,1] interval.

    Returns
    -----------
    x_r: scalar, float
       A rounded version of x, if necessary. 
    &#34;&#34;&#34;
    if (abs(x) &gt; 1.0) and (abs(x) &lt; 1.005):
        return 1.0*np.sign(x)
    else:
        return x</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.shear_slip_angle_difference"><code class="name flex">
<span>def <span class="ident">shear_slip_angle_difference</span></span>(<span>stress_tensor, strike, dip, rake)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the angle difference between the slip vector
from the focal mechanism solution and the shear traction
on the fault determined from the inverted stress tensor.
Given that the stress inversion is made under the Wallace-Bott
assumption, shear stress on the fault is parallel to slip, then
this angle difference is a measure of misfit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stress_tensor</code></strong> :&ensp;<code>(3, 3) array</code></dt>
<dd>The Cauchy stress tensor.</dd>
<dt><strong><code>strike</code></strong> :&ensp;<code>float</code></dt>
<dd>Strike of the fault.</dd>
<dt><strong><code>dip</code></strong> :&ensp;<code>float</code></dt>
<dd>Dip of the fault.</dd>
<dt><strong><code>rake</code></strong> :&ensp;<code>float</code></dt>
<dd>Rake of the fault.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle between shear stress and slip, in degrees.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shear_slip_angle_difference(stress_tensor, strike, dip, rake):
    &#34;&#34;&#34;
    Return the angle difference between the slip vector
    from the focal mechanism solution and the shear traction
    on the fault determined from the inverted stress tensor.
    Given that the stress inversion is made under the Wallace-Bott
    assumption, shear stress on the fault is parallel to slip, then
    this angle difference is a measure of misfit.

    Parameters
    -----------
    stress_tensor: (3, 3) array
        The Cauchy stress tensor.
    strike: float
        Strike of the fault.
    dip: float
        Dip of the fault.
    rake: float
        Rake of the fault.

    Returns
    -----------
    angle: float
        The angle between shear stress and slip, in degrees.
    &#34;&#34;&#34;
    # first, get the normal and slip vectors corresponding
    # to (strike, dip, rake)
    n, d = normal_slip_vectors(strike, dip, rake, direction=&#39;inward&#39;)
    n = n.reshape(1, -1) # make sure it&#39;s a row vector
    # second, compute the shear stress on the fault
    traction, normal_traction, shear_traction = compute_traction(
            stress_tensor, n)
    shear_dir = shear_traction/np.sqrt(np.sum(shear_traction**2))
    # the angle difference is the Arccos(dot product)
    angle = np.arccos(round_cos(np.sum(d.squeeze()*shear_dir.squeeze())))
    # return the result in degrees
    return angle*180./np.pi</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.stress_tensor_eigendecomposition"><code class="name flex">
<span>def <span class="ident">stress_tensor_eigendecomposition</span></span>(<span>stress_tensor)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<p>stress_tensor: (3, 3) numpy array.
The stress tensor for which to solve the
eigenvalue problem.
Returns</p>
<hr>
<p>principal_stresses: (3,) numpy array.
The three eigenvalues of the stress tensor, ordered
from most compressive (sigma1) to least compressive (sigma3).
principal_directions: (3, 3) numpy array.
The three eigenvectors of the stress tensor, stored in
a matrix as column vectors and ordered from
most compressive (sigma1) to least compressive (sigma3).
The direction of sigma_i is given by: <code>principal_directions[:, i]</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stress_tensor_eigendecomposition(stress_tensor):
    &#34;&#34;&#34;
    Parameters
    -----------
    stress_tensor: (3, 3) numpy array.
        The stress tensor for which to solve the
        eigenvalue problem.
    Returns
    --------
    principal_stresses: (3,) numpy array.
        The three eigenvalues of the stress tensor, ordered
        from most compressive (sigma1) to least compressive (sigma3).
    principal_directions: (3, 3) numpy array.
        The three eigenvectors of the stress tensor, stored in
        a matrix as column vectors and ordered from
        most compressive (sigma1) to least compressive (sigma3).
        The direction of sigma_i is given by: `principal_directions[:, i]`. 
    &#34;&#34;&#34;
    try:
        principal_stresses, principal_directions = \
                              np.linalg.eigh(stress_tensor)
    except LinAlgError:
        print(stress_tensor)
        sys.exit()
    #order = np.argsort(principal_stresses)[::-1]
    order = np.argsort(principal_stresses)
    # reorder from most compressive to most extensional
    # with tension positive convention
    # (note: principal_directions is the matrix a column-eigenvectors)
    principal_stresses = principal_stresses[order]
    principal_directions = check_right_handedness(principal_directions[:, order])
    return principal_stresses, principal_directions</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.strike_dip_rake"><code class="name flex">
<span>def <span class="ident">strike_dip_rake</span></span>(<span>n, d)</span>
</code></dt>
<dd>
<div class="desc"><p>Invert the relationships between strike/dip/rake
and normal (n) and slip (d) vectors found in Stein.
n and d are required to be given as the default format
returned by normal_slip_vectors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>(3) array</code></dt>
<dd>The outward pointing normal of the FOOT wall.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>(3) array</code></dt>
<dd>The slip direction of the hanging wall w.r.t.
the foot wall.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>strike</code></strong> :&ensp;<code>float</code></dt>
<dd>Strike of the fault, in degress.</dd>
<dt><strong><code>dip</code></strong> :&ensp;<code>float</code></dt>
<dd>Dip of the fault, in degrees.</dd>
<dt><strong><code>rake</code></strong> :&ensp;<code>float</code></dt>
<dd>Rake of the fault, in degrees.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strike_dip_rake(n, d):
    &#34;&#34;&#34;
    Invert the relationships between strike/dip/rake
    and normal (n) and slip (d) vectors found in Stein.
    n and d are required to be given as the default format
    returned by normal_slip_vectors.

    Parameters
    -----------
    n: (3) array
        The outward pointing normal of the FOOT wall.
    d: (3) array
        The slip direction of the hanging wall w.r.t.
        the foot wall.

    Returns
    ---------
    strike: float
        Strike of the fault, in degress.
    dip: float
        Dip of the fault, in degrees.
    rake: float
        Rake of the fault, in degrees.
    &#34;&#34;&#34;
    r2d = 180./np.pi
    # ----------------
    # dip is straightforward:
    dip = np.arccos(round_cos(n[2]))
    sin_dip = np.sin(dip)
    if sin_dip != 0.:
        # ----------------
        # strike is more complicated because it spans 0-360 degrees
        sin_strike = -n[0]/sin_dip
        cos_strike = -n[1]/sin_dip
        strike = np.arctan2(sin_strike, cos_strike)
        # ---------------
        # rake is even more complicated
        sin_rake = d[2]/sin_dip
        cos_rake = (d[0] - sin_rake*np.cos(dip)*sin_strike)/cos_strike
        rake = np.arctan2(sin_rake, cos_rake)
    else:
        print(&#39;Dip is zero! The strike and rake cannot be determined&#39;)
        # the solution is ill-defined, we can only
        # determine rake - strike
        cos_rake_m_strike = d[0]
        sin_rake_m_strike = d[1]
        rake_m_strike = np.arctan2(sin_rake_m_strike, cos_rake_m_strike)
        # fix arbitrarily the rake to zero
        rake = 0.
        strike = -rake_m_strike
    return (strike*r2d)%360., dip*r2d, (rake*r2d)%360.</code></pre>
</details>
</dd>
<dt id="ILSI.utils_stress.strike_dip_rake_to_mt"><code class="name flex">
<span>def <span class="ident">strike_dip_rake_to_mt</span></span>(<span>strike, dip, rake)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the <em>normalized</em> moment tensor described by strike/dip/rake.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strike</code></strong> :&ensp;<code>scalar, float</code></dt>
<dd>Strike of the input focal mechanism.</dd>
<dt><strong><code>dip</code></strong> :&ensp;<code>scalar, float</code></dt>
<dd>Dip of the input focal mechanism.</dd>
<dt><strong><code>rake</code></strong> :&ensp;<code>scalar, float</code></dt>
<dd>Rake of the input focal mechanism.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mt</code></strong> :&ensp;<code>(3, 3) numpy array, float</code></dt>
<dd>Normalized moment tensor. Its columns are the
(p, b, t) axes. Note: we return (p, b, t) to be
consistent with our stress tensor convention (sig1, sig2, sig3).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strike_dip_rake_to_mt(strike, dip, rake):
    &#34;&#34;&#34;Compute the *normalized* moment tensor described by strike/dip/rake.

    Parameters
    -----------
    strike: scalar, float
        Strike of the input focal mechanism.
    dip: scalar, float
        Dip of the input focal mechanism.
    rake: scalar, float
        Rake of the input focal mechanism.

    Returns
    ---------
    mt: (3, 3) numpy array, float
        Normalized moment tensor. Its columns are the
        (p, b, t) axes. Note: we return (p, b, t) to be
        consistent with our stress tensor convention (sig1, sig2, sig3).
    &#34;&#34;&#34;
    # first, compute the normal and slip vectors
    n, d = normal_slip_vectors(strike, dip, rake)
    # second, compute the t, p, b axes
    p, t, b = p_t_b_axes(n, d)
    # build a matrix with columns (p b t) and make sure these form
    # a right-handed basis, this is the eigenbasis of the moment tensor
    U = check_right_handedness(np.stack([p, b, t], axis=1))
    # build the matrix of eigenvalues (a double-couple is a deviatoric
    # moment tensor with determinant = 0, see Tape and Tape 2012)
    Lambda = np.array([[-1., 0., 0.],
                       [0., 0., 0.],
                       [0., 0., +1.]], dtype=np.float32)
    mt = U.dot(Lambda.dot(U.T))
    mt /= np.sqrt(np.sum(mt**2))
    return mt</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ILSI" href="index.html">ILSI</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ILSI.utils_stress.R_" href="#ILSI.utils_stress.R_">R_</a></code></li>
<li><code><a title="ILSI.utils_stress.angular_residual" href="#ILSI.utils_stress.angular_residual">angular_residual</a></code></li>
<li><code><a title="ILSI.utils_stress.aux_plane" href="#ILSI.utils_stress.aux_plane">aux_plane</a></code></li>
<li><code><a title="ILSI.utils_stress.check_right_handedness" href="#ILSI.utils_stress.check_right_handedness">check_right_handedness</a></code></li>
<li><code><a title="ILSI.utils_stress.compute_traction" href="#ILSI.utils_stress.compute_traction">compute_traction</a></code></li>
<li><code><a title="ILSI.utils_stress.errors_in_data" href="#ILSI.utils_stress.errors_in_data">errors_in_data</a></code></li>
<li><code><a title="ILSI.utils_stress.get_CI_levels" href="#ILSI.utils_stress.get_CI_levels">get_CI_levels</a></code></li>
<li><code><a title="ILSI.utils_stress.get_CI_levels_joint" href="#ILSI.utils_stress.get_CI_levels_joint">get_CI_levels_joint</a></code></li>
<li><code><a title="ILSI.utils_stress.get_bearing_plunge" href="#ILSI.utils_stress.get_bearing_plunge">get_bearing_plunge</a></code></li>
<li><code><a title="ILSI.utils_stress.hist2d" href="#ILSI.utils_stress.hist2d">hist2d</a></code></li>
<li><code><a title="ILSI.utils_stress.joint_CDF" href="#ILSI.utils_stress.joint_CDF">joint_CDF</a></code></li>
<li><code><a title="ILSI.utils_stress.kagan_angle" href="#ILSI.utils_stress.kagan_angle">kagan_angle</a></code></li>
<li><code><a title="ILSI.utils_stress.mean_angular_residual" href="#ILSI.utils_stress.mean_angular_residual">mean_angular_residual</a></code></li>
<li><code><a title="ILSI.utils_stress.mean_kagan_angle" href="#ILSI.utils_stress.mean_kagan_angle">mean_kagan_angle</a></code></li>
<li><code><a title="ILSI.utils_stress.normal_slip_vectors" href="#ILSI.utils_stress.normal_slip_vectors">normal_slip_vectors</a></code></li>
<li><code><a title="ILSI.utils_stress.p_t_b_axes" href="#ILSI.utils_stress.p_t_b_axes">p_t_b_axes</a></code></li>
<li><code><a title="ILSI.utils_stress.principal_faults" href="#ILSI.utils_stress.principal_faults">principal_faults</a></code></li>
<li><code><a title="ILSI.utils_stress.quaternion" href="#ILSI.utils_stress.quaternion">quaternion</a></code></li>
<li><code><a title="ILSI.utils_stress.random_rotation" href="#ILSI.utils_stress.random_rotation">random_rotation</a></code></li>
<li><code><a title="ILSI.utils_stress.reduced_stress_tensor" href="#ILSI.utils_stress.reduced_stress_tensor">reduced_stress_tensor</a></code></li>
<li><code><a title="ILSI.utils_stress.rotation" href="#ILSI.utils_stress.rotation">rotation</a></code></li>
<li><code><a title="ILSI.utils_stress.round_cos" href="#ILSI.utils_stress.round_cos">round_cos</a></code></li>
<li><code><a title="ILSI.utils_stress.shear_slip_angle_difference" href="#ILSI.utils_stress.shear_slip_angle_difference">shear_slip_angle_difference</a></code></li>
<li><code><a title="ILSI.utils_stress.stress_tensor_eigendecomposition" href="#ILSI.utils_stress.stress_tensor_eigendecomposition">stress_tensor_eigendecomposition</a></code></li>
<li><code><a title="ILSI.utils_stress.strike_dip_rake" href="#ILSI.utils_stress.strike_dip_rake">strike_dip_rake</a></code></li>
<li><code><a title="ILSI.utils_stress.strike_dip_rake_to_mt" href="#ILSI.utils_stress.strike_dip_rake_to_mt">strike_dip_rake_to_mt</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>